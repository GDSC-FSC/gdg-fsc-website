{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/HashRing.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 3.19.0\n * @experimental\n */\nimport { dual } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as Iterable from \"./Iterable.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nimport * as PrimaryKey from \"./PrimaryKey.js\";\nconst TypeId = \"~effect/cluster/HashRing\";\n/**\n * @since 3.19.0\n * @category Guards\n * @experimental\n */\nexport const isHashRing = u => hasProperty(u, TypeId);\n/**\n * @since 3.19.0\n * @category Constructors\n * @experimental\n */\nexport const make = options => {\n  const self = Object.create(Proto);\n  self.baseWeight = Math.max(options?.baseWeight ?? 128, 1);\n  self.totalWeightCache = 0;\n  self.nodes = new Map();\n  self.ring = [];\n  return self;\n};\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    return Iterable.map(this.nodes.values(), ([n]) => n)[Symbol.iterator]();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  ...Inspectable.BaseProto,\n  toJSON() {\n    return {\n      _id: \"HashRing\",\n      baseWeight: this.baseWeight,\n      nodes: this.ring.map(([, n]) => this.nodes.get(n)[0])\n    };\n  }\n};\n/**\n * Add new nodes to the ring. If a node already exists in the ring, it\n * will be updated. For example, you can use this to update the node's weight.\n *\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const addMany = /*#__PURE__*/dual(args => isHashRing(args[0]), (self, nodes, options) => {\n  const weight = Math.max(options?.weight ?? 1, 0.1);\n  const keys = [];\n  let toRemove;\n  for (const node of nodes) {\n    const key = PrimaryKey.value(node);\n    const entry = self.nodes.get(key);\n    if (entry) {\n      if (entry[1] === weight) continue;\n      toRemove ??= new Set();\n      toRemove.add(key);\n      self.totalWeightCache -= entry[1];\n      self.totalWeightCache += weight;\n      entry[1] = weight;\n    } else {\n      self.nodes.set(key, [node, weight]);\n      self.totalWeightCache += weight;\n    }\n    keys.push(key);\n  }\n  if (toRemove) {\n    self.ring = self.ring.filter(([, n]) => !toRemove.has(n));\n  }\n  addNodesToRing(self, keys, Math.round(weight * self.baseWeight));\n  return self;\n});\nfunction addNodesToRing(self, keys, weight) {\n  for (let i = weight; i > 0; i--) {\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      self.ring.push([Hash.string(`${key}:${i}`), key]);\n    }\n  }\n  self.ring.sort((a, b) => a[0] - b[0]);\n}\n/**\n * Add a new node to the ring. If the node already exists in the ring, it\n * will be updated. For example, you can use this to update the node's weight.\n *\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const add = /*#__PURE__*/dual(args => isHashRing(args[0]), (self, node, options) => addMany(self, [node], options));\n/**\n * Removes the node from the ring. No-op's if the node does not exist.\n *\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const remove = /*#__PURE__*/dual(2, (self, node) => {\n  const key = PrimaryKey.value(node);\n  const entry = self.nodes.get(key);\n  if (entry) {\n    self.nodes.delete(key);\n    self.ring = self.ring.filter(([, n]) => n !== key);\n    self.totalWeightCache -= entry[1];\n  }\n  return self;\n});\n/**\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const has = /*#__PURE__*/dual(2, (self, node) => self.nodes.has(PrimaryKey.value(node)));\n/**\n * Gets the node which should handle the given input. Returns undefined if\n * the hashring has no elements with weight.\n *\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const get = (self, input) => {\n  if (self.ring.length === 0) {\n    return undefined;\n  }\n  const index = getIndexForInput(self, Hash.string(input))[0];\n  const node = self.ring[index][1];\n  return self.nodes.get(node)[0];\n};\n/**\n * Distributes `count` shards across the nodes in the ring, attempting to\n * balance the number of shards allocated to each node. Returns undefined if\n * the hashring has no elements with weight.\n *\n * @since 3.19.0\n * @category Combinators\n * @experimental\n */\nexport const getShards = (self, count) => {\n  if (self.ring.length === 0) {\n    return undefined;\n  }\n  const shards = new Array(count);\n  // for tracking how many shards have been allocated to each node\n  const allocations = new Map();\n  // for tracking which shards still need to be allocated\n  const remaining = new Set();\n  // for tracking which nodes have reached the max allocation\n  const exclude = new Set();\n  // First pass - allocate the closest nodes, skipping nodes that have reached\n  // max\n  const distances = new Array(count);\n  for (let shard = 0; shard < count; shard++) {\n    const hash = shardHashes[shard] ??= Hash.string(`shard-${shard}`);\n    const [index, distance] = getIndexForInput(self, hash);\n    const node = self.ring[index][1];\n    distances[shard] = [shard, node, distance];\n    remaining.add(shard);\n  }\n  distances.sort((a, b) => a[2] - b[2]);\n  for (let i = 0; i < count; i++) {\n    const [shard, node] = distances[i];\n    if (exclude.has(node)) continue;\n    const [value, weight] = self.nodes.get(node);\n    shards[shard] = value;\n    remaining.delete(shard);\n    const nodeCount = (allocations.get(node) ?? 0) + 1;\n    allocations.set(node, nodeCount);\n    const maxPerNode = Math.max(1, Math.floor(count * (weight / self.totalWeightCache)));\n    if (nodeCount >= maxPerNode) {\n      exclude.add(node);\n    }\n  }\n  // Second pass - allocate any remaining shards, skipping nodes that have\n  // reached max\n  let allAtMax = exclude.size === self.nodes.size;\n  remaining.forEach(shard => {\n    const index = getIndexForInput(self, shardHashes[shard], allAtMax ? undefined : exclude)[0];\n    const node = self.ring[index][1];\n    const [value, weight] = self.nodes.get(node);\n    shards[shard] = value;\n    if (allAtMax) return;\n    const nodeCount = (allocations.get(node) ?? 0) + 1;\n    allocations.set(node, nodeCount);\n    const maxPerNode = Math.max(1, Math.floor(count * (weight / self.totalWeightCache)));\n    if (nodeCount >= maxPerNode) {\n      exclude.add(node);\n      if (exclude.size === self.nodes.size) {\n        allAtMax = true;\n      }\n    }\n  });\n  return shards;\n};\nconst shardHashes = [];\nfunction getIndexForInput(self, hash, exclude) {\n  const ring = self.ring;\n  const len = ring.length;\n  let mid;\n  let lo = 0;\n  let hi = len - 1;\n  while (lo <= hi) {\n    mid = (lo + hi) / 2 >>> 0;\n    if (ring[mid][0] >= hash) {\n      hi = mid - 1;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const a = lo === len ? lo - 1 : lo;\n  const distA = Math.abs(ring[a][0] - hash);\n  if (exclude === undefined) {\n    const b = lo - 1;\n    if (b < 0) {\n      return [a, distA];\n    }\n    const distB = Math.abs(ring[b][0] - hash);\n    return distA <= distB ? [a, distA] : [b, distB];\n  } else if (!exclude.has(ring[a][1])) {\n    return [a, distA];\n  }\n  const range = Math.max(lo, len - lo);\n  for (let i = 1; i < range; i++) {\n    let index = lo - i;\n    if (index >= 0 && index < len && !exclude.has(ring[index][1])) {\n      return [index, Math.abs(ring[index][0] - hash)];\n    }\n    index = lo + i;\n    if (index >= 0 && index < len && !exclude.has(ring[index][1])) {\n      return [index, Math.abs(ring[index][0] - hash)];\n    }\n  }\n  return [a, distA];\n}\n//# sourceMappingURL=HashRing.js.map",
      "start": 1768772628413,
      "end": 1768772628413
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628413,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
