{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/find-my-way-ts/dist/esm/internal/router.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as QS from \"../QueryString.js\";\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//;\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/;\n/** @internal */\nexport const make = (options = {}) => new RouterImpl(options);\nclass RouterImpl {\n  constructor(options = {}) {\n    this.options = {\n      ignoreTrailingSlash: true,\n      ignoreDuplicateSlashes: true,\n      caseSensitive: false,\n      maxParamLength: 100,\n      ...options\n    };\n  }\n  options;\n  routes = [];\n  trees = {};\n  on(method, path, handler) {\n    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);\n    if (optionalParamMatch && optionalParamMatch.index !== undefined) {\n      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, \"Optional Parameter needs to be the last parameter of the path\");\n      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, \"$1$2\");\n      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, \"$2\");\n      this.on(method, pathFull, handler);\n      this.on(method, pathOptional, handler);\n      return;\n    }\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const methods = typeof method === \"string\" ? [method] : method;\n    for (const method of methods) {\n      this._on(method, path, handler);\n    }\n  }\n  all(path, handler) {\n    this.on(httpMethods, path, handler);\n  }\n  _on(method, path, handler) {\n    if (this.trees[method] === undefined) {\n      this.trees[method] = new StaticNode(\"/\");\n    }\n    let pattern = path;\n    if (pattern === \"*\" && this.trees[method].prefix.length !== 0) {\n      const currentRoot = this.trees[method];\n      this.trees[method] = new StaticNode(\"\");\n      this.trees[method].staticChildren[\"/\"] = currentRoot;\n    }\n    let parentNodePathIndex = this.trees[method].prefix.length;\n    let currentNode = this.trees[method];\n    const params = [];\n    for (let i = 0; i <= pattern.length; i++) {\n      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {\n        // It's a double colon\n        i++;\n        continue;\n      }\n      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;\n      const isWildcardNode = pattern.charCodeAt(i) === 42;\n      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {\n        let staticNodePath = pattern.slice(parentNodePathIndex, i);\n        if (!this.options.caseSensitive) {\n          staticNodePath = staticNodePath.toLowerCase();\n        }\n        staticNodePath = staticNodePath.split(\"::\").join(\":\");\n        staticNodePath = staticNodePath.split(\"%\").join(\"%25\");\n        // add the static part of the route to the tree\n        currentNode = currentNode.createStaticChild(staticNodePath);\n      }\n      if (isParametricNode) {\n        let isRegexNode = false;\n        const regexps = [];\n        let lastParamStartIndex = i + 1;\n        for (let j = lastParamStartIndex;; j++) {\n          const charCode = pattern.charCodeAt(j);\n          const isRegexParam = charCode === 40;\n          const isStaticPart = charCode === 45 || charCode === 46;\n          const isEndOfNode = charCode === 47 || j === pattern.length;\n          if (isRegexParam || isStaticPart || isEndOfNode) {\n            const paramName = pattern.slice(lastParamStartIndex, j);\n            params.push(paramName);\n            isRegexNode = isRegexNode || isRegexParam || isStaticPart;\n            if (isRegexParam) {\n              const endOfRegexIndex = getClosingParenthensePosition(pattern, j);\n              const regexString = pattern.slice(j, endOfRegexIndex + 1);\n              regexps.push(trimRegExpStartAndEnd(regexString));\n              j = endOfRegexIndex + 1;\n            } else {\n              regexps.push(\"(.*?)\");\n            }\n            const staticPartStartIndex = j;\n            for (; j < pattern.length; j++) {\n              const charCode = pattern.charCodeAt(j);\n              if (charCode === 47) break;\n              if (charCode === 58) {\n                const nextCharCode = pattern.charCodeAt(j + 1);\n                if (nextCharCode === 58) j++;else break;\n              }\n            }\n            let staticPart = pattern.slice(staticPartStartIndex, j);\n            if (staticPart) {\n              staticPart = staticPart.split(\"::\").join(\":\");\n              staticPart = staticPart.split(\"%\").join(\"%25\");\n              regexps.push(escapeRegExp(staticPart));\n            }\n            lastParamStartIndex = j + 1;\n            if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {\n              const nodePattern = isRegexNode ? \"()\" + staticPart : staticPart;\n              const nodePath = pattern.slice(i, j);\n              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);\n              i += nodePattern.length;\n              const regex = isRegexNode ? new RegExp(\"^\" + regexps.join(\"\") + \"$\") : undefined;\n              currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);\n              parentNodePathIndex = i + 1;\n              break;\n            }\n          }\n        }\n      } else if (isWildcardNode) {\n        // add the wildcard parameter\n        params.push(\"*\");\n        currentNode = currentNode.createWildcardChild();\n        parentNodePathIndex = i + 1;\n        if (i !== pattern.length - 1) {\n          throw new Error(\"Wildcard must be the last character in the route\");\n        }\n      }\n    }\n    if (!this.options.caseSensitive) {\n      pattern = pattern.toLowerCase();\n    }\n    if (pattern === \"*\") {\n      pattern = \"/*\";\n    }\n    for (const existRoute of this.routes) {\n      if (existRoute.method === method && existRoute.pattern === pattern) {\n        throw new Error(`Method '${method}' already declared for route '${pattern}'`);\n      }\n    }\n    const route = {\n      method,\n      path,\n      pattern,\n      params,\n      handler\n    };\n    this.routes.push(route);\n    currentNode.addRoute(route);\n  }\n  has(method, path) {\n    const node = this.trees[method];\n    if (node === undefined) {\n      return false;\n    }\n    const staticNode = node.getStaticChild(path);\n    if (staticNode === undefined) {\n      return false;\n    }\n    return staticNode.isLeafNode;\n  }\n  find(method, path) {\n    let currentNode = this.trees[method];\n    if (currentNode === undefined) return undefined;\n    if (path.charCodeAt(0) !== 47) {\n      // 47 is '/'\n      path = path.replace(FULL_PATH_REGEXP, \"/\");\n    }\n    // This must be run before sanitizeUrl as the resulting function\n    // .sliceParameter must be constructed with same URL string used\n    // throughout the rest of this function.\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    let sanitizedUrl;\n    let querystring;\n    let shouldDecodeParam;\n    try {\n      sanitizedUrl = safeDecodeURI(path);\n      path = sanitizedUrl.path;\n      querystring = sanitizedUrl.querystring;\n      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;\n    } catch (error) {\n      return undefined;\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const originPath = path;\n    if (this.options.caseSensitive === false) {\n      path = path.toLowerCase();\n    }\n    const maxParamLength = this.options.maxParamLength;\n    let pathIndex = currentNode.prefix.length;\n    const params = [];\n    const pathLen = path.length;\n    const brothersNodesStack = [];\n    while (true) {\n      if (pathIndex === pathLen && currentNode.isLeafNode) {\n        const handle = currentNode.handlerStorage?.find();\n        if (handle !== undefined) {\n          return {\n            handler: handle.handler,\n            params: handle.createParams(params),\n            searchParams: QS.parse(querystring)\n          };\n        }\n      }\n      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);\n      if (node === undefined) {\n        if (brothersNodesStack.length === 0) {\n          return undefined;\n        }\n        const brotherNodeState = brothersNodesStack.pop();\n        pathIndex = brotherNodeState.brotherPathIndex;\n        params.splice(brotherNodeState.paramsCount);\n        node = brotherNodeState.brotherNode;\n      }\n      currentNode = node;\n      // static route\n      if (currentNode._tag === \"StaticNode\") {\n        pathIndex += currentNode.prefix.length;\n        continue;\n      }\n      if (currentNode._tag === \"WildcardNode\") {\n        let param = originPath.slice(pathIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        params.push(param);\n        pathIndex = pathLen;\n        continue;\n      }\n      if (currentNode._tag === \"ParametricNode\") {\n        let paramEndIndex = originPath.indexOf(\"/\", pathIndex);\n        if (paramEndIndex === -1) {\n          paramEndIndex = pathLen;\n        }\n        let param = originPath.slice(pathIndex, paramEndIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        if (currentNode.regex !== undefined) {\n          const matchedParameters = currentNode.regex.exec(param);\n          if (matchedParameters === null) continue;\n          for (let i = 1; i < matchedParameters.length; i++) {\n            const matchedParam = matchedParameters[i];\n            if (matchedParam.length > maxParamLength) {\n              return undefined;\n            }\n            params.push(matchedParam);\n          }\n        } else {\n          if (param.length > maxParamLength) {\n            return undefined;\n          }\n          params.push(param);\n        }\n        pathIndex = paramEndIndex;\n      }\n    }\n  }\n}\nclass HandlerStorage {\n  handlers = [];\n  unconstrainedHandler;\n  find() {\n    return this.unconstrainedHandler;\n  }\n  add(route) {\n    const handler = {\n      params: route.params,\n      handler: route.handler,\n      createParams: compileCreateParams(route.params)\n    };\n    this.handlers.push(handler);\n    this.unconstrainedHandler = this.handlers[0];\n  }\n}\nclass NodeBase {\n  isLeafNode = false;\n  routes;\n  handlerStorage;\n  addRoute(route) {\n    if (this.routes === undefined) {\n      this.routes = [route];\n    } else {\n      this.routes.push(route);\n    }\n    if (this.handlerStorage === undefined) {\n      this.handlerStorage = new HandlerStorage();\n    }\n    this.isLeafNode = true;\n    this.handlerStorage.add(route);\n  }\n}\nclass ParentNode extends NodeBase {\n  staticChildren = {};\n  findStaticMatchingChild(path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)];\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return undefined;\n    }\n    return staticChild;\n  }\n  getStaticChild(path, pathIndex = 0) {\n    if (path.length === pathIndex) {\n      return this;\n    }\n    const staticChild = this.findStaticMatchingChild(path, pathIndex);\n    if (staticChild === undefined) {\n      return undefined;\n    }\n    return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);\n  }\n  createStaticChild(path) {\n    if (path.length === 0) {\n      return this;\n    }\n    let staticChild = this.staticChildren[path.charAt(0)];\n    if (staticChild) {\n      let i = 1;\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i);\n          break;\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i));\n    }\n    const label = path.charAt(0);\n    this.staticChildren[label] = new StaticNode(path);\n    return this.staticChildren[label];\n  }\n}\nclass StaticNode extends ParentNode {\n  _tag = \"StaticNode\";\n  constructor(prefix) {\n    super();\n    this.setPrefix(prefix);\n  }\n  prefix;\n  matchPrefix;\n  parametricChildren = [];\n  wildcardChild;\n  setPrefix(prefix) {\n    this.prefix = prefix;\n    if (prefix.length === 1) {\n      this.matchPrefix = (_path, _pathIndex) => true;\n    } else {\n      const len = prefix.length;\n      this.matchPrefix = function (path, pathIndex) {\n        for (let i = 1; i < len; i++) {\n          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n  }\n  getParametricChild(regex) {\n    if (regex === undefined) {\n      return this.parametricChildren.find(child => child.isRegex === false);\n    }\n    const source = regex.source;\n    return this.parametricChildren.find(child => {\n      if (child.regex === undefined) {\n        return false;\n      }\n      return child.regex.source === source;\n    });\n  }\n  createParametricChild(regex, staticSuffix, nodePath) {\n    let child = this.getParametricChild(regex);\n    if (child !== undefined) {\n      child.nodePaths.add(nodePath);\n      return child;\n    }\n    child = new ParametricNode(regex, staticSuffix, nodePath);\n    this.parametricChildren.push(child);\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1;\n      if (!child2.isRegex) return -1;\n      if (child1.staticSuffix === undefined) return 1;\n      if (child2.staticSuffix === undefined) return -1;\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;\n      return 0;\n    });\n    return child;\n  }\n  createWildcardChild() {\n    if (this.wildcardChild === undefined) {\n      this.wildcardChild = new WildcardNode();\n    }\n    return this.wildcardChild;\n  }\n  split(parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length);\n    const childPrefix = this.prefix.slice(length);\n    this.setPrefix(childPrefix);\n    const staticNode = new StaticNode(parentPrefix);\n    staticNode.staticChildren[childPrefix.charAt(0)] = this;\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;\n    return staticNode;\n  }\n  getNextNode(path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex);\n    let parametricBrotherNodeIndex = 0;\n    if (node === undefined) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild;\n      }\n      node = this.parametricChildren[0];\n      parametricBrotherNodeIndex = 1;\n    }\n    if (this.wildcardChild !== undefined) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      });\n    }\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      });\n    }\n    return node;\n  }\n}\nclass ParametricNode extends ParentNode {\n  regex;\n  staticSuffix;\n  _tag = \"ParametricNode\";\n  constructor(regex, staticSuffix, nodePath) {\n    super();\n    this.regex = regex;\n    this.staticSuffix = staticSuffix;\n    this.isRegex = !!regex;\n    this.nodePaths = new Set([nodePath]);\n  }\n  isRegex;\n  nodePaths;\n  getNextNode(path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex);\n  }\n}\nclass WildcardNode extends NodeBase {\n  _tag = \"WildcardNode\";\n  getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {\n    return undefined;\n  }\n}\nconst assert = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\nfunction removeDuplicateSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n}\nfunction trimLastSlash(path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1);\n  }\n  return path;\n}\nfunction compileCreateParams(params) {\n  const len = params.length;\n  return function (paramsArray) {\n    const paramsObject = {};\n    for (let i = 0; i < len; i++) {\n      paramsObject[params[i]] = paramsArray[i];\n    }\n    return paramsObject;\n  };\n}\nfunction getClosingParenthensePosition(path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n  let parentheses = 1;\n  while (idx < path.length) {\n    idx++;\n    // ignore skipped chars\n    if (path[idx] === \"\\\\\") {\n      idx++;\n      continue;\n    }\n    if (path[idx] === \")\") {\n      parentheses--;\n    } else if (path[idx] === \"(\") {\n      parentheses++;\n    }\n    if (!parentheses) return idx;\n  }\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"');\n}\nfunction trimRegExpStartAndEnd(regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2);\n  }\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);\n  }\n  return regexString;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar(highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return \"%\";\n    if (lowCharCode === 51) return \"#\";\n    if (lowCharCode === 52) return \"$\";\n    if (lowCharCode === 54) return \"&\";\n    if (lowCharCode === 66) return \"+\";\n    if (lowCharCode === 98) return \"+\";\n    if (lowCharCode === 67) return \",\";\n    if (lowCharCode === 99) return \",\";\n    if (lowCharCode === 70) return \"/\";\n    if (lowCharCode === 102) return \"/\";\n    return undefined;\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return \":\";\n    if (lowCharCode === 97) return \":\";\n    if (lowCharCode === 66) return \";\";\n    if (lowCharCode === 98) return \";\";\n    if (lowCharCode === 68) return \"=\";\n    if (lowCharCode === 100) return \"=\";\n    if (lowCharCode === 70) return \"?\";\n    if (lowCharCode === 102) return \"?\";\n    return undefined;\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return \"@\";\n  }\n  return undefined;\n}\nfunction safeDecodeURI(path) {\n  let shouldDecode = false;\n  let shouldDecodeParam = false;\n  let querystring = \"\";\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i);\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1);\n      const lowCharCode = path.charCodeAt(i + 2);\n      if (decodeComponentChar(highCharCode, lowCharCode) === undefined) {\n        shouldDecode = true;\n      } else {\n        shouldDecodeParam = true;\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true;\n          path = path.slice(0, i + 1) + \"25\" + path.slice(i + 1);\n          i += 2;\n        }\n        i += 2;\n      }\n      // Some systems do not follow RFC and separate the path and query\n      // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n      // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1);\n      path = path.slice(0, i);\n      break;\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path;\n  return {\n    path: decodedPath,\n    querystring,\n    shouldDecodeParam\n  };\n}\nfunction safeDecodeURIComponent(uriComponent) {\n  const startIndex = uriComponent.indexOf(\"%\");\n  if (startIndex === -1) return uriComponent;\n  let decoded = \"\";\n  let lastIndex = startIndex;\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1);\n      const lowCharCode = uriComponent.charCodeAt(i + 2);\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar;\n      lastIndex = i + 3;\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);\n}\nconst httpMethods = [\"ACL\", \"BIND\", \"CHECKOUT\", \"CONNECT\", \"COPY\", \"DELETE\", \"GET\", \"HEAD\", \"LINK\", \"LOCK\", \"M-SEARCH\", \"MERGE\", \"MKACTIVITY\", \"MKCALENDAR\", \"MKCOL\", \"MOVE\", \"NOTIFY\", \"OPTIONS\", \"PATCH\", \"POST\", \"PROPFIND\", \"PROPPATCH\", \"PURGE\", \"PUT\", \"REBIND\", \"REPORT\", \"SEARCH\", \"SOURCE\", \"SUBSCRIBE\", \"TRACE\", \"UNBIND\", \"UNLINK\", \"UNLOCK\", \"UNSUBSCRIBE\"];\n//# sourceMappingURL=router.js.map",
      "start": 1768772628847,
      "end": 1768772628847
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628847,
      "end": 1768772628849,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628851,
      "end": 1768772628852,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628854,
      "end": 1768772628856,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628858,
      "end": 1768772628859,
      "order": "post-post"
    }
  ]
}
