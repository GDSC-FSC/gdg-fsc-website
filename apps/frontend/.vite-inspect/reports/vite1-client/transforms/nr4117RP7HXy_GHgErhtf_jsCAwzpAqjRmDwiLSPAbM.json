{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Match.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as internal from \"./internal/matcher.js\";\nimport * as Predicate from \"./Predicate.js\";\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport const MatcherTypeId = internal.TypeId;\n/**\n * Creates a matcher for a specific type.\n *\n * **Details**\n *\n * This function defines a `Matcher` that operates on a given type, allowing you\n * to specify conditions for handling different cases. Once the matcher is\n * created, you can use pattern-matching functions like {@link when} to define\n * how different values should be processed.\n *\n * **Example** (Matching Numbers and Strings)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for values that are either strings or numbers\n * //\n * //      ┌─── (u: string | number) => string\n * //      ▼\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match when the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are handled\n *   Match.exhaustive\n * )\n *\n * console.log(match(0))\n * // Output: \"number: 0\"\n *\n * console.log(match(\"hello\"))\n * // Output: \"string: hello\"\n * ```\n *\n * @see {@link value} for creating a matcher from a specific value.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const type = internal.type;\n/**\n * Creates a matcher from a specific value.\n *\n * **Details**\n *\n * This function allows you to define a `Matcher` directly from a given value,\n * rather than from a type. This is useful when working with known values,\n * enabling structured pattern matching on objects, primitives, or any data\n * structure.\n *\n * Once the matcher is created, you can use pattern-matching functions like\n * {@link when} to define how different cases should be handled.\n *\n * **Example** (Matching an Object by Property)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const input = { name: \"John\", age: 30 }\n *\n * // Create a matcher for the specific object\n * const result = Match.value(input).pipe(\n *   // Match when the 'name' property is \"John\"\n *   Match.when(\n *     { name: \"John\" },\n *     (user) => `${user.name} is ${user.age} years old`\n *   ),\n *   // Provide a fallback if no match is found\n *   Match.orElse(() => \"Oh, not John\")\n * )\n *\n * console.log(result)\n * // Output: \"John is 30 years old\"\n * ```\n *\n * @see {@link type} for creating a matcher from a specific type.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const value = internal.value;\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const valueTags = internal.valueTags;\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const typeTags = internal.typeTags;\n/**\n * Ensures that all branches of a matcher return a specific type.\n *\n * **Details**\n *\n * This function enforces a consistent return type across all pattern-matching\n * branches. By specifying a return type, TypeScript will check that every\n * matching condition produces a value of the expected type.\n *\n * **Important:** This function must be the first step in the matcher pipeline.\n * If used later, TypeScript will not enforce type consistency correctly.\n *\n * **Example** (Validating Return Type Consistency)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const match = Match.type<{ a: number } | { b: string }>().pipe(\n *   // Ensure all branches return a string\n *   Match.withReturnType<string>(),\n *   // ❌ Type error: 'number' is not assignable to type 'string'\n *   // @ts-expect-error\n *   Match.when({ a: Match.number }, (_) => _.a),\n *   // ✅ Correct: returns a string\n *   Match.when({ b: Match.string }, (_) => _.b),\n *   Match.exhaustive\n * )\n * ```\n *\n * @since 1.0.0\n */\nexport const withReturnType = internal.withReturnType;\n/**\n * Defines a condition for matching values.\n *\n * **Details**\n *\n * This function enables pattern matching by checking whether a given value\n * satisfies a condition. It supports both direct value comparisons and\n * predicate functions. If the condition is met, the associated function is\n * executed.\n *\n * This function is useful when defining matchers that need to check for\n * specific values or apply logical conditions to determine a match. It works\n * well with structured objects and primitive types.\n *\n * **Example** (Matching with Values and Predicates)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for objects with an \"age\" property\n * const match = Match.type<{ age: number }>().pipe(\n *   // Match when age is greater than 18\n *   Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n *   // Match when age is exactly 18\n *   Match.when({ age: 18 }, () => \"You can vote\"),\n *   // Fallback case for all other ages\n *   Match.orElse((user) => `${user.age} is too young`)\n * )\n *\n * console.log(match({ age: 20 }))\n * // Output: \"Age: 20\"\n *\n * console.log(match({ age: 18 }))\n * // Output: \"You can vote\"\n *\n * console.log(match({ age: 4 }))\n * // Output: \"4 is too young\"\n * ```\n *\n * @see {@link whenOr} Use this when multiple patterns should match in a single\n * condition.\n * @see {@link whenAnd} Use this when a value must match all provided patterns.\n * @see {@link orElse} Provides a fallback when no patterns match.\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const when = internal.when;\n/**\n * Matches one of multiple patterns in a single condition.\n *\n * **Details**\n *\n * This function allows defining a condition where a value matches any of the\n * provided patterns. If a match is found, the associated function is executed.\n * It simplifies cases where multiple patterns share the same handling logic.\n *\n * Unlike {@link when}, which requires separate conditions for each pattern,\n * this function enables combining them into a single statement, making the\n * matcher more concise.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type ErrorType =\n *   | { readonly _tag: \"NetworkError\"; readonly message: string }\n *   | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n *   | { readonly _tag: \"ValidationError\"; readonly field: string }\n *\n * const handleError = Match.type<ErrorType>().pipe(\n *   Match.whenOr(\n *     { _tag: \"NetworkError\" },\n *     { _tag: \"TimeoutError\" },\n *     () => \"Retry the request\"\n *   ),\n *   Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n *   Match.exhaustive\n * )\n *\n * console.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n * // Output: \"Retry the request\"\n *\n * console.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n * // Output: \"Invalid field: email\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenOr = internal.whenOr;\n/**\n * Matches a value that satisfies all provided patterns.\n *\n * **Details**\n *\n * This function allows defining a condition where a value must match all the\n * given patterns simultaneously. If the value satisfies every pattern, the\n * associated function is executed.\n *\n * Unlike {@link when}, which matches a single pattern at a time, this function\n * ensures that multiple conditions are met before executing the callback. It is\n * useful when checking for values that need to fulfill multiple criteria at\n * once.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n *\n * const checkUser = Match.type<User>().pipe(\n *   Match.whenAnd(\n *     { age: (n) => n >= 18 },\n *     { role: \"admin\" },\n *     () => \"Admin access granted\"\n *   ),\n *   Match.orElse(() => \"Access denied\")\n * )\n *\n * console.log(checkUser({ age: 20, role: \"admin\" }))\n * // Output: \"Admin access granted\"\n *\n * console.log(checkUser({ age: 20, role: \"user\" }))\n * // Output: \"Access denied\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenAnd = internal.whenAnd;\n/**\n * Matches values based on a specified discriminant field.\n *\n * **Details**\n *\n * This function is used to define pattern matching on objects that follow a\n * **discriminated union** structure, where a specific field (e.g., `type`,\n * `kind`, `_tag`) determines the variant of the object. It allows matching\n * multiple values of the discriminant and provides a function to handle the\n * matched cases.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n *   Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminator = internal.discriminator;\n/**\n * Matches values where a specified field starts with a given prefix.\n *\n * **Details**\n *\n * This function is useful for working with discriminated unions where the\n * discriminant field follows a hierarchical or namespaced structure. It allows\n * you to match values based on whether the specified field starts with a given\n * prefix, making it easier to handle grouped cases.\n *\n * Instead of checking for exact matches, this function lets you match values\n * that share a common prefix. For example, if your discriminant field contains\n * hierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\n * starting with `\"A\"` using a single rule.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n *   Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n *   Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ type: \"A\" })) // 1\n * console.log(match({ type: \"B\" })) // 2\n * console.log(match({ type: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorStartsWith = internal.discriminatorStartsWith;\n/**\n * Matches values based on a field that serves as a discriminator, mapping each\n * possible value to a corresponding handler.\n *\n * **Details**\n *\n * This function simplifies working with discriminated unions by letting you\n * define a set of handlers for each possible value of a given field. Instead of\n * chaining multiple calls to {@link discriminator}, this function allows\n * defining all possible cases at once using an object where the keys are the\n * possible values of the field, and the values are the corresponding handler\n * functions.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminators(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminators = internal.discriminators;\n/**\n * Matches values based on a discriminator field and **ensures all cases are\n * handled**.\n *\n * **Details*+\n *\n * This function is similar to {@link discriminators}, but **requires that all\n * possible cases** are explicitly handled. It is useful when working with\n * discriminated unions, where a specific field (e.g., `\"type\"`) determines the\n * shape of an object. Each possible value of the field must have a\n * corresponding handler, ensuring **exhaustiveness checking** at compile time.\n *\n * This function **does not require** `Match.exhaustive` at the end of the\n * pipeline because it enforces exhaustiveness by design.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminatorsExhaustive(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorsExhaustive = internal.discriminatorsExhaustive;\n/**\n * The `Match.tag` function allows pattern matching based on the `_tag` field in\n * a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\n * You can specify multiple tags to match within a single pattern.\n *\n * **Note**\n *\n * The `Match.tag` function relies on the convention within the Effect ecosystem\n * of naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\n * follow this naming convention for proper functionality.\n *\n * **Example** (Matching a Discriminated Union by Tag)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type Event =\n *   | { readonly _tag: \"fetch\" }\n *   | { readonly _tag: \"success\"; readonly data: string }\n *   | { readonly _tag: \"error\"; readonly error: Error }\n *   | { readonly _tag: \"cancel\" }\n *\n * // Create a Matcher for Either<number, string>\n * const match = Match.type<Event>().pipe(\n *   // Match either \"fetch\" or \"success\"\n *   Match.tag(\"fetch\", \"success\", () => `Ok!`),\n *   // Match \"error\" and extract the error message\n *   Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n *   // Match \"cancel\"\n *   Match.tag(\"cancel\", () => \"Cancelled\"),\n *   Match.exhaustive\n * )\n *\n * console.log(match({ _tag: \"success\", data: \"Hello\" }))\n * // Output: \"Ok!\"\n *\n * console.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n * // Output: \"Error: Oops!\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tag = internal.tag;\n/**\n * Matches values where the `_tag` field starts with a given prefix.\n *\n * **Details**\n *\n * This function allows you to match on values in a **discriminated union**\n * based on whether the `_tag` field starts with a specified prefix. It is\n * useful for handling hierarchical or namespaced tags, where multiple related\n * cases share a common prefix.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n *   Match.tagStartsWith(\"A\", (_) => 1 as const),\n *   Match.tagStartsWith(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ _tag: \"A\" })) // 1\n * console.log(match({ _tag: \"B\" })) // 2\n * console.log(match({ _tag: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagStartsWith = internal.tagStartsWith;\n/**\n * Matches values based on their `_tag` field, mapping each tag to a\n * corresponding handler.\n *\n * **Details**\n *\n * This function provides a way to handle discriminated unions by mapping `_tag`\n * values to specific functions. Each handler receives the matched value and\n * returns a transformed result. If all possible tags are handled, you can\n * enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tags({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tags = internal.tags;\n/**\n * Matches values based on their `_tag` field and requires handling of all\n * possible cases.\n *\n * **Details**\n *\n * This function is designed for **discriminated unions** where every possible\n * `_tag` value must have a corresponding handler. Unlike {@link tags}, this\n * function ensures **exhaustiveness**, meaning all cases must be explicitly\n * handled. If a `_tag` value is missing from the mapping, TypeScript will\n * report an error.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tagsExhaustive({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagsExhaustive = internal.tagsExhaustive;\n/**\n * Excludes a specific value from matching while allowing all others.\n *\n * **Details**\n *\n * This function is useful when you need to **handle all values except one or\n * more specific cases**. Instead of listing all possible matches manually, this\n * function simplifies the logic by allowing you to specify values to exclude.\n * Any excluded value will bypass the provided function and continue matching\n * through other cases.\n *\n * **Example** (Ignoring a Specific Value)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match any value except \"hi\", returning \"ok\"\n *   Match.not(\"hi\", () => \"ok\"),\n *   // Fallback case for when the value is \"hi\"\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"hello\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"hi\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const not = internal.not;\n/**\n * Matches non-empty strings.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const nonEmptyString = internal.nonEmptyString;\n/**\n * Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const is = internal.is;\n/**\n * Matches values of type `string`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const string = Predicate.isString;\n/**\n * Matches values of type `number`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const number = Predicate.isNumber;\n/**\n * Matches any value without restrictions.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const any = internal.any;\n/**\n * Matches any defined (non-null and non-undefined) value.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const defined = internal.defined;\n/**\n * Matches values of type `boolean`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const boolean = Predicate.isBoolean;\nconst _undefined = Predicate.isUndefined;\nexport {\n/**\n * Matches the value `undefined`.\n *\n * @category Predicates\n * @since 1.0.0\n */\n_undefined as undefined };\nconst _null = Predicate.isNull;\nexport {\n/**\n * Matches the value `null`.\n *\n * @category Predicates\n * @since 1.0.0\n */\n_null as null };\n/**\n * Matches values of type `bigint`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const bigint = Predicate.isBigInt;\n/**\n * Matches values of type `symbol`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const symbol = Predicate.isSymbol;\n/**\n * Matches values that are instances of `Date`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const date = Predicate.isDate;\n/**\n * Matches objects where keys are `string` or `symbol` and values are `unknown`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const record = Predicate.isRecord;\n/**\n * Matches instances of a given class.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOf = internal.instanceOf;\n/**\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOfUnsafe = internal.instanceOf;\n/**\n * Provides a fallback value when no patterns match.\n *\n * **Details**\n *\n * This function ensures that a matcher always returns a valid result, even if\n * no defined patterns match. It acts as a default case, similar to the\n * `default` clause in a `switch` statement or the final `else` in an `if-else`\n * chain.\n *\n * **Example** (Providing a Default Value When No Patterns Match)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is \"a\"\n *   Match.when(\"a\", () => \"ok\"),\n *   // Fallback when no patterns match\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"a\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"b\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElse = internal.orElse;\n// TODO(4.0): Rename to \"orThrow\"? Like Either.getOrThrow\n/**\n * Throws an error if no pattern matches.\n *\n * **Details**\n *\n * This function finalizes a matcher by ensuring that if no patterns match, an\n * error is thrown. It is useful when all cases should be covered, and any\n * unexpected input should trigger an error instead of returning a default\n * value.\n *\n * When used, this function removes the need for an explicit fallback case and\n * ensures that an unmatched value is never silently ignored.\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElseAbsurd = internal.orElseAbsurd;\n/**\n * Wraps the match result in an `Either`, distinguishing matched and unmatched\n * cases.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is always wrapped in an\n * `Either`, allowing clear differentiation between successful matches\n * (`Right(value)`) and cases where no pattern matched (`Left(unmatched\n * value)`).\n *\n * This approach is particularly useful when handling optional values or when an\n * unmatched case should be explicitly handled rather than returning a default\n * value or throwing an error.\n *\n * **Example** (Extracting a User Role with `Match.either`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.either // Wrap the result in an Either\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const either = internal.either;\n/**\n * Wraps the match result in an `Option`, representing an optional match.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is wrapped in an `Option`,\n * making it easy to handle cases where no pattern matches. If a match is found,\n * it returns `Some(value)`, otherwise, it returns `None`.\n *\n * This is useful in cases where a missing match is expected and should be\n * handled explicitly rather than throwing an error or returning a default\n * value.\n *\n * **Example** (Extracting a User Role with `Match.option`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.option // Wrap the result in an Option\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const option = internal.option;\n/**\n * The `Match.exhaustive` method finalizes the pattern matching process by\n * ensuring that all possible cases are accounted for. If any case is missing,\n * TypeScript will produce a type error. This is particularly useful when\n * working with unions, as it helps prevent unintended gaps in pattern matching.\n *\n * **Example** (Ensuring All Cases Are Covered)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Mark the match as exhaustive, ensuring all cases are handled\n *   // TypeScript will throw an error if any case is missing\n *   // @ts-expect-error Type 'string' is not assignable to type 'never'\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const exhaustive = internal.exhaustive;\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport const SafeRefinementId = /*#__PURE__*/Symbol.for(\"effect/SafeRefinement\");\nconst Fail = /*#__PURE__*/Symbol.for(\"effect/Fail\");\n//# sourceMappingURL=Match.js.map",
      "start": 1768772628416,
      "end": 1768772628416
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628416,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628419,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628478,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
