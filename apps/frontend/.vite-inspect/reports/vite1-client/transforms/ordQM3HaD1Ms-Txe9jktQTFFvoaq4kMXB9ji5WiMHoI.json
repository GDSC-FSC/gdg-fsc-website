{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/Headers.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as FiberRefs from \"effect/FiberRefs\";\nimport { dual, identity } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport { symbolRedactable } from \"effect/Inspectable\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as Record from \"effect/Record\";\nimport * as Redacted from \"effect/Redacted\";\nimport * as Schema from \"effect/Schema\";\nimport * as String from \"effect/String\";\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const HeadersTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Headers\");\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHeaders = u => Predicate.hasProperty(u, HeadersTypeId);\nconst Proto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), {\n  [HeadersTypeId]: HeadersTypeId,\n  [symbolRedactable](fiberRefs) {\n    return redact(this, FiberRefs.getOrDefault(fiberRefs, currentRedactedNames));\n  }\n});\nconst make = input => Object.assign(Object.create(Proto), input);\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schemaFromSelf = /*#__PURE__*/Schema.declare(isHeaders, {\n  typeConstructor: {\n    _tag: \"effect/platform/Headers\"\n  },\n  identifier: \"Headers\",\n  equivalence: () => Record.getEquivalence(String.Equivalence)\n});\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schema = /*#__PURE__*/Schema.transform(/*#__PURE__*/Schema.Record({\n  key: Schema.String,\n  value: Schema.String\n}), schemaFromSelf, {\n  strict: true,\n  decode: record => fromInput(record),\n  encode: identity\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = /*#__PURE__*/Object.create(Proto);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromInput = input => {\n  if (input === undefined) {\n    return empty;\n  } else if (Symbol.iterator in input) {\n    const out = Object.create(Proto);\n    for (const [k, v] of input) {\n      out[k.toLowerCase()] = v;\n    }\n    return out;\n  }\n  const out = Object.create(Proto);\n  for (const [k, v] of Object.entries(input)) {\n    if (Array.isArray(v)) {\n      out[k.toLowerCase()] = v.join(\", \");\n    } else if (v !== undefined) {\n      out[k.toLowerCase()] = v;\n    }\n  }\n  return out;\n};\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeFromRecord = input => Object.setPrototypeOf(input, Proto);\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const has = /*#__PURE__*/dual(2, (self, key) => key.toLowerCase() in self);\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const get = /*#__PURE__*/dual(2, (self, key) => Record.get(self, key.toLowerCase()));\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const set = /*#__PURE__*/dual(3, (self, key, value) => {\n  const out = make(self);\n  out[key.toLowerCase()] = value;\n  return out;\n});\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll = /*#__PURE__*/dual(2, (self, headers) => make({\n  ...self,\n  ...fromInput(headers)\n}));\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const merge = /*#__PURE__*/dual(2, (self, headers) => {\n  const out = make(self);\n  Object.assign(out, headers);\n  return out;\n});\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const remove = /*#__PURE__*/dual(2, (self, key) => {\n  const out = make(self);\n  const modify = key => {\n    if (typeof key === \"string\") {\n      const k = key.toLowerCase();\n      if (k in self) {\n        delete out[k];\n      }\n    } else {\n      for (const name in self) {\n        if (key.test(name)) {\n          delete out[name];\n        }\n      }\n    }\n  };\n  if (Array.isArray(key)) {\n    for (let i = 0; i < key.length; i++) {\n      modify(key[i]);\n    }\n  } else {\n    modify(key);\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const redact = /*#__PURE__*/dual(2, (self, key) => {\n  const out = {\n    ...self\n  };\n  const modify = key => {\n    if (typeof key === \"string\") {\n      const k = key.toLowerCase();\n      if (k in self) {\n        out[k] = Redacted.make(self[k]);\n      }\n    } else {\n      for (const name in self) {\n        if (key.test(name)) {\n          out[name] = Redacted.make(self[name]);\n        }\n      }\n    }\n  };\n  if (Array.isArray(key)) {\n    for (let i = 0; i < key.length; i++) {\n      modify(key[i]);\n    }\n  } else {\n    modify(key);\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentRedactedNames = /*#__PURE__*/globalValue(\"@effect/platform/Headers/currentRedactedNames\", () => FiberRef.unsafeMake([\"authorization\", \"cookie\", \"set-cookie\", \"x-api-key\"]));\n//# sourceMappingURL=Headers.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628703,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
