{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../../Array.js\";\nimport * as Chunk from \"../../Chunk.js\";\nimport { dual, pipe } from \"../../Function.js\";\nimport * as Option from \"../../Option.js\";\nimport * as SortedMap from \"../../SortedMap.js\";\nimport * as core from \"./core.js\";\nimport * as tRef from \"./tRef.js\";\n/** @internal */\nconst TPriorityQueueSymbolKey = \"effect/TPriorityQueue\";\n/** @internal */\nexport const TPriorityQueueTypeId = /*#__PURE__*/Symbol.for(TPriorityQueueSymbolKey);\nconst tPriorityQueueVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport class TPriorityQueueImpl {\n  ref;\n  [TPriorityQueueTypeId] = tPriorityQueueVariance;\n  constructor(ref) {\n    this.ref = ref;\n  }\n}\n/** @internal */\nexport const empty = order => pipe(tRef.make(SortedMap.empty(order)), core.map(ref => new TPriorityQueueImpl(ref)));\n/** @internal */\nexport const fromIterable = order => iterable => pipe(tRef.make(Arr.fromIterable(iterable).reduce((map, value) => pipe(map, SortedMap.set(value, pipe(map, SortedMap.get(value), Option.match({\n  onNone: () => Arr.of(value),\n  onSome: Arr.prepend(value)\n})))), SortedMap.empty(order))), core.map(ref => new TPriorityQueueImpl(ref)));\n/** @internal */\nexport const isEmpty = self => core.map(tRef.get(self.ref), SortedMap.isEmpty);\n/** @internal */\nexport const isNonEmpty = self => core.map(tRef.get(self.ref), SortedMap.isNonEmpty);\n/** @internal */\nexport const make = order => (...elements) => fromIterable(order)(elements);\n/** @internal */\nexport const offer = /*#__PURE__*/dual(2, (self, value) => tRef.update(self.ref, map => SortedMap.set(map, value, Option.match(SortedMap.get(map, value), {\n  onNone: () => Arr.of(value),\n  onSome: Arr.prepend(value)\n}))));\n/** @internal */\nexport const offerAll = /*#__PURE__*/dual(2, (self, values) => tRef.update(self.ref, map => Arr.fromIterable(values).reduce((map, value) => SortedMap.set(map, value, Option.match(SortedMap.get(map, value), {\n  onNone: () => Arr.of(value),\n  onSome: Arr.prepend(value)\n})), map)));\n/** @internal */\nexport const peek = self => core.withSTMRuntime(runtime => {\n  const map = tRef.unsafeGet(self.ref, runtime.journal);\n  return Option.match(SortedMap.headOption(map), {\n    onNone: () => core.retry,\n    onSome: elements => core.succeed(elements[0])\n  });\n});\n/** @internal */\nexport const peekOption = self => tRef.modify(self.ref, map => [Option.map(SortedMap.headOption(map), elements => elements[0]), map]);\n/** @internal */\nexport const removeIf = /*#__PURE__*/dual(2, (self, predicate) => retainIf(self, a => !predicate(a)));\n/** @internal */\nexport const retainIf = /*#__PURE__*/dual(2, (self, predicate) => tRef.update(self.ref, map => SortedMap.reduce(map, SortedMap.empty(SortedMap.getOrder(map)), (map, value, key) => {\n  const filtered = Arr.filter(value, predicate);\n  return filtered.length > 0 ? SortedMap.set(map, key, filtered) : SortedMap.remove(map, key);\n})));\n/** @internal */\nexport const size = self => tRef.modify(self.ref, map => [SortedMap.reduce(map, 0, (n, as) => n + as.length), map]);\n/** @internal */\nexport const take = self => core.withSTMRuntime(runtime => {\n  const map = tRef.unsafeGet(self.ref, runtime.journal);\n  return Option.match(SortedMap.headOption(map), {\n    onNone: () => core.retry,\n    onSome: values => {\n      const head = values[1][0];\n      const tail = values[1].slice(1);\n      tRef.unsafeSet(self.ref, tail.length > 0 ? SortedMap.set(map, head, tail) : SortedMap.remove(map, head), runtime.journal);\n      return core.succeed(head);\n    }\n  });\n});\n/** @internal */\nexport const takeAll = self => tRef.modify(self.ref, map => {\n  const builder = [];\n  for (const entry of map) {\n    for (const value of entry[1]) {\n      builder.push(value);\n    }\n  }\n  return [builder, SortedMap.empty(SortedMap.getOrder(map))];\n});\n/** @internal */\nexport const takeOption = self => core.effect(journal => {\n  const map = pipe(self.ref, tRef.unsafeGet(journal));\n  return Option.match(SortedMap.headOption(map), {\n    onNone: () => Option.none(),\n    onSome: ([key, value]) => {\n      const tail = value.slice(1);\n      tRef.unsafeSet(self.ref, tail.length > 0 ? SortedMap.set(map, key, tail) : SortedMap.remove(map, key), journal);\n      return Option.some(value[0]);\n    }\n  });\n});\n/** @internal */\nexport const takeUpTo = /*#__PURE__*/dual(2, (self, n) => tRef.modify(self.ref, map => {\n  const builder = [];\n  const iterator = map[Symbol.iterator]();\n  let updated = map;\n  let index = 0;\n  let next;\n  while ((next = iterator.next()) && !next.done && index < n) {\n    const [key, value] = next.value;\n    const [left, right] = pipe(value, Arr.splitAt(n - index));\n    for (const value of left) {\n      builder.push(value);\n    }\n    if (right.length > 0) {\n      updated = SortedMap.set(updated, key, right);\n    } else {\n      updated = SortedMap.remove(updated, key);\n    }\n    index = index + left.length;\n  }\n  return [builder, updated];\n}));\n/** @internal */\nexport const toChunk = self => tRef.modify(self.ref, map => {\n  const builder = [];\n  for (const entry of map) {\n    for (const value of entry[1]) {\n      builder.push(value);\n    }\n  }\n  return [Chunk.unsafeFromArray(builder), map];\n});\n/** @internal */\nexport const toArray = self => tRef.modify(self.ref, map => {\n  const builder = [];\n  for (const entry of map) {\n    for (const value of entry[1]) {\n      builder.push(value);\n    }\n  }\n  return [builder, map];\n});\n//# sourceMappingURL=tPriorityQueue.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
