{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/internal/platformConfigProvider.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as ConfigProvider from \"effect/ConfigProvider\";\nimport * as Context from \"effect/Context\";\nimport * as DefaultServices from \"effect/DefaultServices\";\nimport * as Effect from \"effect/Effect\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as Layer from \"effect/Layer\";\nimport * as FileSystem from \"../FileSystem.js\";\n/**\n * dot env ConfigProvider\n *\n * Based on\n * - https://github.com/motdotla/dotenv\n * - https://github.com/motdotla/dotenv-expand\n */\n/** @internal */\nexport const fromDotEnv = (path, config) => Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem;\n  const content = yield* fs.readFileString(path);\n  const obj = parseDotEnv(content);\n  return ConfigProvider.fromMap(new Map(Object.entries(obj)), Object.assign({}, {\n    pathDelim: \"_\",\n    seqDelim: \",\"\n  }, config));\n});\n/** @internal */\nexport const layerDotEnv = path => fromDotEnv(path).pipe(Effect.map(Layer.setConfigProvider), Layer.unwrapEffect);\n/** @internal */\nexport const layerDotEnvAdd = path => Effect.gen(function* () {\n  const dotEnvConfigProvider = yield* Effect.orElseSucceed(fromDotEnv(path), () => null);\n  if (dotEnvConfigProvider === null) {\n    yield* Effect.logDebug(`File '${path}' not found, skipping dotenv ConfigProvider.`);\n    return Layer.empty;\n  }\n  const currentConfigProvider = yield* FiberRef.get(DefaultServices.currentServices).pipe(Effect.map(services => Context.get(services, ConfigProvider.ConfigProvider)));\n  const configProvider = ConfigProvider.orElse(currentConfigProvider, () => dotEnvConfigProvider);\n  return Layer.setConfigProvider(configProvider);\n}).pipe(Layer.unwrapEffect);\n/** @internal */\nconst DOT_ENV_LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n/** @internal */\nconst parseDotEnv = lines => {\n  const obj = {};\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/gm, \"\\n\");\n  let match;\n  while ((match = DOT_ENV_LINE.exec(lines)) != null) {\n    const key = match[1];\n    // Default undefined or null to empty string\n    let value = match[2] || \"\";\n    // Remove whitespace\n    value = value.trim();\n    // Check if double quoted\n    const maybeQuote = value[0];\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, \"$2\");\n    // Expand newlines if double quoted\n    if (maybeQuote === \"\\\"\") {\n      value = value.replace(/\\\\n/g, \"\\n\");\n      value = value.replace(/\\\\r/g, \"\\r\");\n    }\n    // Add to object\n    obj[key] = value;\n  }\n  return expand(obj);\n};\n/** @internal */\nconst expand = parsed => {\n  const newParsed = {};\n  for (const configKey in parsed) {\n    // resolve escape sequences\n    newParsed[configKey] = interpolate(parsed[configKey], parsed).replace(/\\\\\\$/g, \"$\");\n  }\n  return newParsed;\n};\n/** @internal */\nconst interpolate = (envValue, parsed) => {\n  // find the last unescaped dollar sign in the\n  // value so that we can evaluate it\n  const lastUnescapedDollarSignIndex = searchLast(envValue, /(?!(?<=\\\\))\\$/g);\n  // If we couldn't match any unescaped dollar sign\n  // let's return the string as is\n  if (lastUnescapedDollarSignIndex === -1) return envValue;\n  // This is the right-most group of variables in the string\n  const rightMostGroup = envValue.slice(lastUnescapedDollarSignIndex);\n  /**\n   * This finds the inner most variable/group divided\n   * by variable name and default value (if present)\n   * (\n   *   (?!(?<=\\\\))\\$        // only match dollar signs that are not escaped\n   *   {?                   // optional opening curly brace\n   *     ([\\w]+)            // match the variable name\n   *     (?::-([^}\\\\]*))?   // match an optional default value\n   *   }?                   // optional closing curly brace\n   * )\n   */\n  const matchGroup = /((?!(?<=\\\\))\\${?([\\w]+)(?::-([^}\\\\]*))?}?)/;\n  const match = rightMostGroup.match(matchGroup);\n  if (match !== null) {\n    const [_, group, variableName, defaultValue] = match;\n    return interpolate(envValue.replace(group, defaultValue || parsed[variableName] || \"\"), parsed);\n  }\n  return envValue;\n};\n/** @internal */\nconst searchLast = (str, rgx) => {\n  const matches = Array.from(str.matchAll(rgx));\n  return matches.length > 0 ? matches.slice(-1)[0].index : -1;\n};\n//# sourceMappingURL=platformConfigProvider.js.map",
      "start": 1768772628755,
      "end": 1768772628755
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628755,
      "end": 1768772628768,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628771,
      "end": 1768772628785,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628790,
      "end": 1768772628803,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628807,
      "end": 1768772628811,
      "order": "post-post"
    }
  ]
}
