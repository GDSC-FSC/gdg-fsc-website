{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/FiberSet.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Cause from \"./Cause.js\";\nimport * as Deferred from \"./Deferred.js\";\nimport * as Effect from \"./Effect.js\";\nimport * as Exit from \"./Exit.js\";\nimport * as Fiber from \"./Fiber.js\";\nimport * as FiberId from \"./FiberId.js\";\nimport { constFalse, constVoid, dual } from \"./Function.js\";\nimport * as HashSet from \"./HashSet.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as Iterable from \"./Iterable.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport * as Predicate from \"./Predicate.js\";\nimport * as Runtime from \"./Runtime.js\";\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/FiberSet\");\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberSet = u => Predicate.hasProperty(u, TypeId);\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    if (this.state._tag === \"Closed\") {\n      return Iterable.empty();\n    }\n    return this.state.backing[Symbol.iterator]();\n  },\n  toString() {\n    return Inspectable.format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"FiberMap\",\n      state: this.state\n    };\n  },\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst unsafeMake = (backing, deferred) => {\n  const self = Object.create(Proto);\n  self.state = {\n    _tag: \"Open\",\n    backing\n  };\n  self.deferred = deferred;\n  return self;\n};\n/**\n * A FiberSet can be used to store a collection of fibers.\n * When the associated Scope is closed, all fibers in the set will be interrupted.\n *\n * You can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will\n * be automatically removed from the FiberSet when they complete.\n *\n * @example\n * ```ts\n * import { Effect, FiberSet } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const set = yield* FiberSet.make()\n *\n *   // run some effects and add the fibers to the set\n *   yield* FiberSet.run(set, Effect.never)\n *   yield* FiberSet.run(set, Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(new Set(), deferred)), set => Effect.withFiberRuntime(parent => {\n  const state = set.state;\n  if (state._tag === \"Closed\") return Effect.void;\n  set.state = {\n    _tag: \"Closed\"\n  };\n  const fibers = state.backing;\n  return Fiber.interruptAllAs(fibers, FiberId.combine(parent.id(), internalFiberId)).pipe(Effect.intoDeferred(set.deferred));\n}));\n/**\n * Create an Effect run function that is backed by a FiberSet.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = () => Effect.flatMap(make(), self => runtime(self)());\n/**\n * Create an Effect run function that is backed by a FiberSet.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = () => Effect.flatMap(make(), self => runtimePromise(self)());\nconst internalFiberIdId = -1;\nconst internalFiberId = /*#__PURE__*/FiberId.make(internalFiberIdId, 0);\nconst isInternalInterruption = /*#__PURE__*/Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n});\n/**\n * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeAdd = /*#__PURE__*/dual(args => isFiberSet(args[0]), (self, fiber, options) => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n    return;\n  } else if (self.state.backing.has(fiber)) {\n    return;\n  }\n  self.state.backing.add(fiber);\n  fiber.addObserver(exit => {\n    if (self.state._tag === \"Closed\") {\n      return;\n    }\n    self.state.backing.delete(fiber);\n    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {\n      Deferred.unsafeDone(self.deferred, exit);\n    }\n  });\n});\n/**\n * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const add = /*#__PURE__*/dual(args => isFiberSet(args[0]), (self, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeAdd(self, fiber, {\n  ...options,\n  interruptAs: fiberId\n}))));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = self => Effect.withFiberRuntime(clearFiber => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.void;\n  }\n  return Effect.forEach(self.state.backing, fiber =>\n  // will be removed by the observer\n  Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)));\n});\nconst constInterruptedFiber = /*#__PURE__*/function () {\n  let fiber = undefined;\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt);\n    }\n    return fiber;\n  };\n}();\n/**\n * Fork an Effect and add the forked fiber to the FiberSet.\n * When the fiber completes, it will be removed from the FiberSet.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run = function () {\n  const self = arguments[0];\n  if (!Effect.isEffect(arguments[1])) {\n    const options = arguments[1];\n    return effect => runImpl(self, effect, options);\n  }\n  return runImpl(self, arguments[1], arguments[2]);\n};\nconst runImpl = (self, effect, options) => Effect.fiberIdWith(fiberId => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.sync(constInterruptedFiber);\n  }\n  return Effect.tap(Effect.forkDaemon(effect), fiber => unsafeAdd(self, fiber, {\n    ...options,\n    interruptAs: fiberId\n  }));\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberSet } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const set = yield* FiberSet.make()\n *   const run = yield* FiberSet.runtime(set)<Users>()\n *\n *   // run some effects and add the fibers to the set\n *   run(Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime = self => () => Effect.map(Effect.runtime(), runtime => {\n  const runFork = Runtime.runFork(runtime);\n  return (effect, options) => {\n    if (self.state._tag === \"Closed\") {\n      return constInterruptedFiber();\n    }\n    const fiber = runFork(effect, options);\n    unsafeAdd(self, fiber);\n    return fiber;\n  };\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n *\n * The returned run function will return Promise's.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = self => () => Effect.map(runtime(self)(), runFork => (effect, options) => new Promise((resolve, reject) => runFork(effect, options).addObserver(exit => {\n  if (Exit.isSuccess(exit)) {\n    resolve(exit.value);\n  } else {\n    reject(Cause.squash(exit.cause));\n  }\n})));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const size = self => Effect.sync(() => self.state._tag === \"Closed\" ? 0 : self.state.backing.size);\n/**\n * Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberSet } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const set = yield* _(FiberSet.make());\n *   yield* _(FiberSet.add(set, Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberSet.join(set));\n * });\n * ```\n */\nexport const join = self => Deferred.await(self.deferred);\n/**\n * Wait until the fiber set is empty.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = self => Effect.whileLoop({\n  while: () => self.state._tag === \"Open\" && self.state.backing.size > 0,\n  body: () => Fiber.await(Iterable.unsafeHead(self)),\n  step: constVoid\n});\n//# sourceMappingURL=FiberSet.js.map",
      "start": 1768772628410,
      "end": 1768772628410
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628410,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628416,
      "end": 1768772628420,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
