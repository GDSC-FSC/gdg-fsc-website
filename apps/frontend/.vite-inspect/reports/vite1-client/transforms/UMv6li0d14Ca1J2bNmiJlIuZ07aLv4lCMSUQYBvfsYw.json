{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/core-effect.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Clock from \"../Clock.js\";\nimport * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as FiberRefs from \"../FiberRefs.js\";\nimport { constFalse, constTrue, constVoid, dual, identity, pipe } from \"../Function.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport * as List from \"../List.js\";\nimport * as LogLevel from \"../LogLevel.js\";\nimport * as LogSpan from \"../LogSpan.js\";\nimport * as Option from \"../Option.js\";\nimport * as Predicate from \"../Predicate.js\";\nimport * as Ref from \"../Ref.js\";\nimport * as Tracer from \"../Tracer.js\";\nimport { internalCall } from \"../Utils.js\";\nimport * as internalCause from \"./cause.js\";\nimport { clockTag } from \"./clock.js\";\nimport * as core from \"./core.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport * as doNotation from \"./doNotation.js\";\nimport * as fiberRefsPatch from \"./fiberRefs/patch.js\";\nimport * as metricLabel from \"./metric/label.js\";\nimport * as runtimeFlags from \"./runtimeFlags.js\";\nimport * as internalTracer from \"./tracer.js\";\n/* @internal */\nexport const annotateLogs = /*#__PURE__*/dual(args => core.isEffect(args[0]), function () {\n  const args = arguments;\n  return core.fiberRefLocallyWith(args[0], core.currentLogAnnotations, typeof args[1] === \"string\" ? HashMap.set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap.set(acc, key, value), annotations));\n});\n/* @internal */\nexport const asSome = self => core.map(self, Option.some);\n/* @internal */\nexport const asSomeError = self => core.mapError(self, Option.some);\n/* @internal */\nexport const try_ = arg => {\n  let evaluate;\n  let onFailure = undefined;\n  if (typeof arg === \"function\") {\n    evaluate = arg;\n  } else {\n    evaluate = arg.try;\n    onFailure = arg.catch;\n  }\n  return core.suspend(() => {\n    try {\n      return core.succeed(internalCall(evaluate));\n    } catch (error) {\n      return core.fail(onFailure ? internalCall(() => onFailure(error)) : new core.UnknownException(error, \"An unknown error occurred in Effect.try\"));\n    }\n  });\n};\n/* @internal */\nexport const _catch = /*#__PURE__*/dual(3, (self, tag, options) => core.catchAll(self, e => {\n  if (Predicate.hasProperty(e, tag) && e[tag] === options.failure) {\n    return options.onFailure(e);\n  }\n  return core.fail(e);\n}));\n/* @internal */\nexport const catchAllDefect = /*#__PURE__*/dual(2, (self, f) => core.catchAllCause(self, cause => {\n  const option = internalCause.find(cause, _ => internalCause.isDieType(_) ? Option.some(_) : Option.none());\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(cause);\n      }\n    case \"Some\":\n      {\n        return f(option.value.defect);\n      }\n  }\n}));\n/* @internal */\nexport const catchSomeCause = /*#__PURE__*/dual(2, (self, f) => core.matchCauseEffect(self, {\n  onFailure: cause => {\n    const option = f(cause);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.failCause(cause);\n        }\n      case \"Some\":\n        {\n          return option.value;\n        }\n    }\n  },\n  onSuccess: core.succeed\n}));\n/* @internal */\nexport const catchSomeDefect = /*#__PURE__*/dual(2, (self, pf) => core.catchAllCause(self, cause => {\n  const option = internalCause.find(cause, _ => internalCause.isDieType(_) ? Option.some(_) : Option.none());\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(cause);\n      }\n    case \"Some\":\n      {\n        const optionEffect = pf(option.value.defect);\n        return optionEffect._tag === \"Some\" ? optionEffect.value : core.failCause(cause);\n      }\n  }\n}));\n/* @internal */\nexport const catchTag = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, ...args) => {\n  const f = args[args.length - 1];\n  let predicate;\n  if (args.length === 2) {\n    predicate = Predicate.isTagged(args[0]);\n  } else {\n    predicate = e => {\n      const tag = Predicate.hasProperty(e, \"_tag\") ? e[\"_tag\"] : undefined;\n      if (!tag) return false;\n      for (let i = 0; i < args.length - 1; i++) {\n        if (args[i] === tag) return true;\n      }\n      return false;\n    };\n  }\n  return core.catchIf(self, predicate, f);\n});\n/** @internal */\nexport const catchTags = /*#__PURE__*/dual(2, (self, cases) => {\n  let keys;\n  return core.catchIf(self, e => {\n    keys ??= Object.keys(cases);\n    return Predicate.hasProperty(e, \"_tag\") && Predicate.isString(e[\"_tag\"]) && keys.includes(e[\"_tag\"]);\n  }, e => cases[e[\"_tag\"]](e));\n});\n/* @internal */\nexport const cause = self => core.matchCause(self, {\n  onFailure: identity,\n  onSuccess: () => internalCause.empty\n});\n/* @internal */\nexport const clockWith = Clock.clockWith;\n/* @internal */\nexport const clock = /*#__PURE__*/clockWith(core.succeed);\n/* @internal */\nexport const delay = /*#__PURE__*/dual(2, (self, duration) => core.zipRight(Clock.sleep(duration), self));\n/* @internal */\nexport const descriptorWith = f => core.withFiberRuntime((state, status) => f({\n  id: state.id(),\n  status,\n  interruptors: internalCause.interruptors(state.getFiberRef(core.currentInterruptedCause))\n}));\n/* @internal */\nexport const allowInterrupt = /*#__PURE__*/descriptorWith(descriptor => HashSet.size(descriptor.interruptors) > 0 ? core.interrupt : core.void);\n/* @internal */\nexport const descriptor = /*#__PURE__*/descriptorWith(core.succeed);\n/* @internal */\nexport const diffFiberRefs = self => summarized(self, fiberRefs, fiberRefsPatch.diff);\n/* @internal */\nexport const diffFiberRefsAndRuntimeFlags = self => summarized(self, core.zip(fiberRefs, core.runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [fiberRefsPatch.diff(refs, refsNew), runtimeFlags.diff(flags, flagsNew)]);\n/* @internal */\nexport const Do = /*#__PURE__*/core.succeed({});\n/* @internal */\nexport const bind = /*#__PURE__*/doNotation.bind(core.map, core.flatMap);\n/* @internal */\nexport const bindTo = /*#__PURE__*/doNotation.bindTo(core.map);\n/* @internal */\nexport const let_ = /*#__PURE__*/doNotation.let_(core.map);\n/* @internal */\nexport const dropUntil = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(false);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    dropping = core.flatMap(dropping, bool => {\n      if (bool) {\n        builder.push(a);\n        return core.succeed(true);\n      }\n      return predicate(a, index);\n    });\n  }\n  return core.map(dropping, () => builder);\n}));\n/* @internal */\nexport const dropWhile = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(true);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    dropping = core.flatMap(dropping, d => core.map(d ? predicate(a, index) : core.succeed(false), b => {\n      if (!b) {\n        builder.push(a);\n      }\n      return b;\n    }));\n  }\n  return core.map(dropping, () => builder);\n}));\n/* @internal */\nexport const contextWith = f => core.map(core.context(), f);\n/* @internal */\nexport const eventually = self => core.orElse(self, () => core.flatMap(core.yieldNow(), () => eventually(self)));\n/* @internal */\nexport const filterMap = /*#__PURE__*/dual(2, (elements, pf) => core.map(core.forEachSequential(elements, identity), Arr.filterMap(pf)));\n/* @internal */\nexport const filterOrDie = /*#__PURE__*/dual(3, (self, predicate, orDieWith) => filterOrElse(self, predicate, a => core.dieSync(() => orDieWith(a))));\n/* @internal */\nexport const filterOrDieMessage = /*#__PURE__*/dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => core.dieMessage(message)));\n/* @internal */\nexport const filterOrElse = /*#__PURE__*/dual(3, (self, predicate, orElse) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : orElse(a)));\n/** @internal */\nexport const liftPredicate = /*#__PURE__*/dual(3, (self, predicate, orFailWith) => core.suspend(() => predicate(self) ? core.succeed(self) : core.fail(orFailWith(self))));\n/* @internal */\nexport const filterOrFail = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, a => orFailWith === undefined ? core.fail(new core.NoSuchElementException()) : core.failSync(() => orFailWith(a))));\n/* @internal */\nexport const findFirst = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const next = iterator.next();\n  if (!next.done) {\n    return findLoop(iterator, 0, predicate, next.value);\n  }\n  return core.succeed(Option.none());\n}));\nconst findLoop = (iterator, index, f, value) => core.flatMap(f(value, index), result => {\n  if (result) {\n    return core.succeed(Option.some(value));\n  }\n  const next = iterator.next();\n  if (!next.done) {\n    return findLoop(iterator, index + 1, f, next.value);\n  }\n  return core.succeed(Option.none());\n});\n/* @internal */\nexport const firstSuccessOf = effects => core.suspend(() => {\n  const list = Chunk.fromIterable(effects);\n  if (!Chunk.isNonEmpty(list)) {\n    return core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  return pipe(Chunk.tailNonEmpty(list), Arr.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right)));\n});\n/* @internal */\nexport const flipWith = /*#__PURE__*/dual(2, (self, f) => core.flip(f(core.flip(self))));\n/* @internal */\nexport const match = /*#__PURE__*/dual(2, (self, options) => core.matchEffect(self, {\n  onFailure: e => core.succeed(options.onFailure(e)),\n  onSuccess: a => core.succeed(options.onSuccess(a))\n}));\n/* @internal */\nexport const every = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));\nconst forAllLoop = (iterator, index, f) => {\n  const next = iterator.next();\n  return next.done ? core.succeed(true) : core.flatMap(f(next.value, index), b => b ? forAllLoop(iterator, index + 1, f) : core.succeed(b));\n};\n/* @internal */\nexport const forever = self => {\n  const loop = core.flatMap(core.flatMap(self, () => core.yieldNow()), () => loop);\n  return loop;\n};\n/* @internal */\nexport const fiberRefs = /*#__PURE__*/core.withFiberRuntime(state => core.succeed(state.getFiberRefs()));\n/* @internal */\nexport const head = self => core.flatMap(self, as => {\n  const iterator = as[Symbol.iterator]();\n  const next = iterator.next();\n  if (next.done) {\n    return core.fail(new core.NoSuchElementException());\n  }\n  return core.succeed(next.value);\n});\n/* @internal */\nexport const ignore = self => match(self, {\n  onFailure: constVoid,\n  onSuccess: constVoid\n});\n/* @internal */\nexport const ignoreLogged = self => core.matchCauseEffect(self, {\n  onFailure: cause => logDebug(cause, \"An error was silently ignored because it is not anticipated to be useful\"),\n  onSuccess: () => core.void\n});\n/* @internal */\nexport const inheritFiberRefs = childFiberRefs => updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs));\n/* @internal */\nexport const isFailure = self => match(self, {\n  onFailure: constTrue,\n  onSuccess: constFalse\n});\n/* @internal */\nexport const isSuccess = self => match(self, {\n  onFailure: constFalse,\n  onSuccess: constTrue\n});\n/* @internal */\nexport const iterate = (initial, options) => core.suspend(() => {\n  if (options.while(initial)) {\n    return core.flatMap(options.body(initial), z2 => iterate(z2, options));\n  }\n  return core.succeed(initial);\n});\n/** @internal */\nexport const logWithLevel = level => (...message) => {\n  const levelOption = Option.fromNullable(level);\n  let cause = undefined;\n  for (let i = 0, len = message.length; i < len; i++) {\n    const msg = message[i];\n    if (internalCause.isCause(msg)) {\n      if (cause !== undefined) {\n        cause = internalCause.sequential(cause, msg);\n      } else {\n        cause = msg;\n      }\n      message = [...message.slice(0, i), ...message.slice(i + 1)];\n      i--;\n    }\n  }\n  if (cause === undefined) {\n    cause = internalCause.empty;\n  }\n  return core.withFiberRuntime(fiberState => {\n    fiberState.log(message, cause, levelOption);\n    return core.void;\n  });\n};\n/** @internal */\nexport const log = /*#__PURE__*/logWithLevel();\n/** @internal */\nexport const logTrace = /*#__PURE__*/logWithLevel(LogLevel.Trace);\n/** @internal */\nexport const logDebug = /*#__PURE__*/logWithLevel(LogLevel.Debug);\n/** @internal */\nexport const logInfo = /*#__PURE__*/logWithLevel(LogLevel.Info);\n/** @internal */\nexport const logWarning = /*#__PURE__*/logWithLevel(LogLevel.Warning);\n/** @internal */\nexport const logError = /*#__PURE__*/logWithLevel(LogLevel.Error);\n/** @internal */\nexport const logFatal = /*#__PURE__*/logWithLevel(LogLevel.Fatal);\n/* @internal */\nexport const withLogSpan = /*#__PURE__*/dual(2, (effect, label) => core.flatMap(Clock.currentTimeMillis, now => core.fiberRefLocallyWith(effect, core.currentLogSpan, List.prepend(LogSpan.make(label, now)))));\n/* @internal */\nexport const logAnnotations = /*#__PURE__*/core.fiberRefGet(core.currentLogAnnotations);\n/* @internal */\nexport const loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : core.map(loopInternal(initial, options.while, options.step, options.body), Arr.fromIterable);\nconst loopInternal = (initial, cont, inc, body) => core.suspend(() => cont(initial) ? core.flatMap(body(initial), a => core.map(loopInternal(inc(initial), cont, inc, body), List.prepend(a))) : core.sync(() => List.empty()));\nconst loopDiscard = (initial, cont, inc, body) => core.suspend(() => cont(initial) ? core.flatMap(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : core.void);\n/* @internal */\nexport const mapAccum = /*#__PURE__*/dual(3, (elements, initial, f) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let result = core.succeed(initial);\n  let next;\n  let i = 0;\n  while (!(next = iterator.next()).done) {\n    const index = i++;\n    const value = next.value;\n    result = core.flatMap(result, state => core.map(f(state, value, index), ([z, b]) => {\n      builder.push(b);\n      return z;\n    }));\n  }\n  return core.map(result, z => [z, builder]);\n}));\n/* @internal */\nexport const mapErrorCause = /*#__PURE__*/dual(2, (self, f) => core.matchCauseEffect(self, {\n  onFailure: c => core.failCauseSync(() => f(c)),\n  onSuccess: core.succeed\n}));\n/* @internal */\nexport const memoize = self => pipe(core.deferredMake(), core.flatMap(deferred => pipe(diffFiberRefsAndRuntimeFlags(self), core.intoDeferred(deferred), once, core.map(complete => core.zipRight(complete, pipe(core.deferredAwait(deferred), core.flatMap(([patch, a]) => core.as(core.zip(patchFiberRefs(patch[0]), core.updateRuntimeFlags(patch[1])), a))))))));\n/* @internal */\nexport const merge = self => core.matchEffect(self, {\n  onFailure: e => core.succeed(e),\n  onSuccess: core.succeed\n});\n/* @internal */\nexport const negate = self => core.map(self, b => !b);\n/* @internal */\nexport const none = self => core.flatMap(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      return core.void;\n    case \"Some\":\n      return core.fail(new core.NoSuchElementException());\n  }\n});\n/* @internal */\nexport const once = self => core.map(Ref.make(true), ref => core.asVoid(core.whenEffect(self, Ref.getAndSet(ref, false))));\n/* @internal */\nexport const option = self => core.matchEffect(self, {\n  onFailure: () => core.succeed(Option.none()),\n  onSuccess: a => core.succeed(Option.some(a))\n});\n/* @internal */\nexport const orElseFail = /*#__PURE__*/dual(2, (self, evaluate) => core.orElse(self, () => core.failSync(evaluate)));\n/* @internal */\nexport const orElseSucceed = /*#__PURE__*/dual(2, (self, evaluate) => core.orElse(self, () => core.sync(evaluate)));\n/* @internal */\nexport const parallelErrors = self => core.matchCauseEffect(self, {\n  onFailure: cause => {\n    const errors = Arr.fromIterable(internalCause.failures(cause));\n    return errors.length === 0 ? core.failCause(cause) : core.fail(errors);\n  },\n  onSuccess: core.succeed\n});\n/* @internal */\nexport const patchFiberRefs = patch => updateFiberRefs((fiberId, fiberRefs) => pipe(patch, fiberRefsPatch.patch(fiberId, fiberRefs)));\n/* @internal */\nexport const promise = evaluate => evaluate.length >= 1 ? core.async((resolve, signal) => {\n  try {\n    evaluate(signal).then(a => resolve(core.succeed(a)), e => resolve(core.die(e)));\n  } catch (e) {\n    resolve(core.die(e));\n  }\n}) : core.async(resolve => {\n  try {\n    ;\n    evaluate().then(a => resolve(core.succeed(a)), e => resolve(core.die(e)));\n  } catch (e) {\n    resolve(core.die(e));\n  }\n});\n/* @internal */\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, service) => core.contextWithEffect(env => core.provideContext(self, Context.add(env, tag, service))));\n/* @internal */\nexport const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => core.contextWithEffect(env => core.flatMap(effect, service => core.provideContext(self, pipe(env, Context.add(tag, service))))));\n/* @internal */\nexport const random = /*#__PURE__*/defaultServices.randomWith(core.succeed);\n/* @internal */\nexport const reduce = /*#__PURE__*/dual(3, (elements, zero, f) => Arr.fromIterable(elements).reduce((acc, el, i) => core.flatMap(acc, a => f(a, el, i)), core.succeed(zero)));\n/* @internal */\nexport const reduceRight = /*#__PURE__*/dual(3, (elements, zero, f) => Arr.fromIterable(elements).reduceRight((acc, el, i) => core.flatMap(acc, a => f(el, a, i)), core.succeed(zero)));\n/* @internal */\nexport const reduceWhile = /*#__PURE__*/dual(3, (elements, zero, options) => core.flatMap(core.sync(() => elements[Symbol.iterator]()), iterator => reduceWhileLoop(iterator, 0, zero, options.while, options.body)));\nconst reduceWhileLoop = (iterator, index, state, predicate, f) => {\n  const next = iterator.next();\n  if (!next.done && predicate(state)) {\n    return core.flatMap(f(state, next.value, index), nextState => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));\n  }\n  return core.succeed(state);\n};\n/* @internal */\nexport const repeatN = /*#__PURE__*/dual(2, (self, n) => core.suspend(() => repeatNLoop(self, n)));\n/* @internal */\nconst repeatNLoop = (self, n) => core.flatMap(self, a => n <= 0 ? core.succeed(a) : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1)));\n/* @internal */\nexport const sandbox = self => core.matchCauseEffect(self, {\n  onFailure: core.fail,\n  onSuccess: core.succeed\n});\n/* @internal */\nexport const setFiberRefs = fiberRefs => core.suspend(() => FiberRefs.setAll(fiberRefs));\n/* @internal */\nexport const sleep = Clock.sleep;\n/* @internal */\nexport const succeedNone = /*#__PURE__*/core.succeed(/*#__PURE__*/Option.none());\n/* @internal */\nexport const succeedSome = value => core.succeed(Option.some(value));\n/* @internal */\nexport const summarized = /*#__PURE__*/dual(3, (self, summary, f) => core.flatMap(summary, start => core.flatMap(self, value => core.map(summary, end => [f(start, end), value]))));\n/* @internal */\nexport const tagMetrics = /*#__PURE__*/dual(args => core.isEffect(args[0]), function () {\n  return labelMetrics(arguments[0], typeof arguments[1] === \"string\" ? [metricLabel.make(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => metricLabel.make(k, v)));\n});\n/* @internal */\nexport const labelMetrics = /*#__PURE__*/dual(2, (self, labels) => core.fiberRefLocallyWith(self, core.currentMetricLabels, old => Arr.union(old, labels)));\n/* @internal */\nexport const takeUntil = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let effect = core.succeed(false);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    effect = core.flatMap(effect, bool => {\n      if (bool) {\n        return core.succeed(true);\n      }\n      builder.push(a);\n      return predicate(a, index);\n    });\n  }\n  return core.map(effect, () => builder);\n}));\n/* @internal */\nexport const takeWhile = /*#__PURE__*/dual(2, (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let taking = core.succeed(true);\n  let i = 0;\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    const index = i++;\n    taking = core.flatMap(taking, taking => pipe(taking ? predicate(a, index) : core.succeed(false), core.map(bool => {\n      if (bool) {\n        builder.push(a);\n      }\n      return bool;\n    })));\n  }\n  return core.map(taking, () => builder);\n}));\n/* @internal */\nexport const tapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => core.matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = internalCause.failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return core.zipRight(onFailure(either.left), core.failCause(cause));\n        }\n      case \"Right\":\n        {\n          return core.failCause(cause);\n        }\n    }\n  },\n  onSuccess: a => core.as(onSuccess(a), a)\n}));\n/* @internal */\nexport const tapDefect = /*#__PURE__*/dual(2, (self, f) => core.catchAllCause(self, cause => Option.match(internalCause.keepDefects(cause), {\n  onNone: () => core.failCause(cause),\n  onSome: a => core.zipRight(f(a), core.failCause(cause))\n})));\n/* @internal */\nexport const tapError = /*#__PURE__*/dual(2, (self, f) => core.matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = internalCause.failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        return core.zipRight(f(either.left), core.failCause(cause));\n      case \"Right\":\n        return core.failCause(cause);\n    }\n  },\n  onSuccess: core.succeed\n}));\n/* @internal */\nexport const tapErrorTag = /*#__PURE__*/dual(3, (self, k, f) => tapError(self, e => {\n  if (Predicate.isTagged(e, k)) {\n    return f(e);\n  }\n  return core.void;\n}));\n/* @internal */\nexport const tapErrorCause = /*#__PURE__*/dual(2, (self, f) => core.matchCauseEffect(self, {\n  onFailure: cause => core.zipRight(f(cause), core.failCause(cause)),\n  onSuccess: core.succeed\n}));\n/* @internal */\nexport const timed = self => timedWith(self, Clock.currentTimeNanos);\n/* @internal */\nexport const timedWith = /*#__PURE__*/dual(2, (self, nanos) => summarized(self, nanos, (start, end) => Duration.nanos(end - start)));\n/* @internal */\nexport const tracerWith = Tracer.tracerWith;\n/** @internal */\nexport const tracer = /*#__PURE__*/tracerWith(core.succeed);\n/* @internal */\nexport const tryPromise = arg => {\n  let evaluate;\n  let catcher = undefined;\n  if (typeof arg === \"function\") {\n    evaluate = arg;\n  } else {\n    evaluate = arg.try;\n    catcher = arg.catch;\n  }\n  const fail = e => catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e, \"An unknown error occurred in Effect.tryPromise\"));\n  if (evaluate.length >= 1) {\n    return core.async((resolve, signal) => {\n      try {\n        evaluate(signal).then(a => resolve(core.succeed(a)), e => resolve(fail(e)));\n      } catch (e) {\n        resolve(fail(e));\n      }\n    });\n  }\n  return core.async(resolve => {\n    try {\n      evaluate().then(a => resolve(core.succeed(a)), e => resolve(fail(e)));\n    } catch (e) {\n      resolve(fail(e));\n    }\n  });\n};\n/* @internal */\nexport const tryMap = /*#__PURE__*/dual(2, (self, options) => core.flatMap(self, a => try_({\n  try: () => options.try(a),\n  catch: options.catch\n})));\n/* @internal */\nexport const tryMapPromise = /*#__PURE__*/dual(2, (self, options) => core.flatMap(self, a => tryPromise({\n  try: options.try.length >= 1 ? signal => options.try(a, signal) : () => options.try(a),\n  catch: options.catch\n})));\n/* @internal */\nexport const unless = /*#__PURE__*/dual(2, (self, condition) => core.suspend(() => condition() ? succeedNone : asSome(self)));\n/* @internal */\nexport const unlessEffect = /*#__PURE__*/dual(2, (self, condition) => core.flatMap(condition, b => b ? succeedNone : asSome(self)));\n/* @internal */\nexport const unsandbox = self => mapErrorCause(self, internalCause.flatten);\n/* @internal */\nexport const updateFiberRefs = f => core.withFiberRuntime(state => {\n  state.setFiberRefs(f(state.id(), state.getFiberRefs()));\n  return core.void;\n});\n/* @internal */\nexport const updateService = /*#__PURE__*/dual(3, (self, tag, f) => core.mapInputContext(self, context => Context.add(context, tag, f(Context.unsafeGet(context, tag)))));\n/* @internal */\nexport const when = /*#__PURE__*/dual(2, (self, condition) => core.suspend(() => condition() ? core.map(self, Option.some) : core.succeed(Option.none())));\n/* @internal */\nexport const whenFiberRef = /*#__PURE__*/dual(3, (self, fiberRef, predicate) => core.flatMap(core.fiberRefGet(fiberRef), s => predicate(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])));\n/* @internal */\nexport const whenRef = /*#__PURE__*/dual(3, (self, ref, predicate) => core.flatMap(Ref.get(ref), s => predicate(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])));\n/* @internal */\nexport const withMetric = /*#__PURE__*/dual(2, (self, metric) => metric(self));\n/** @internal */\nexport const serviceFunctionEffect = (getService, f) => (...args) => core.flatMap(getService, a => f(a)(...args));\n/** @internal */\nexport const serviceFunction = (getService, f) => (...args) => core.map(getService, a => f(a)(...args));\n/** @internal */\nexport const serviceFunctions = getService => new Proxy({}, {\n  get(_target, prop, _receiver) {\n    return (...args) => core.flatMap(getService, s => s[prop](...args));\n  }\n});\n/** @internal */\nexport const serviceConstants = getService => new Proxy({}, {\n  get(_target, prop, _receiver) {\n    return core.flatMap(getService, s => core.isEffect(s[prop]) ? s[prop] : core.succeed(s[prop]));\n  }\n});\n/** @internal */\nexport const serviceMembers = getService => ({\n  functions: serviceFunctions(getService),\n  constants: serviceConstants(getService)\n});\n/** @internal */\nexport const serviceOption = tag => core.map(core.context(), Context.getOption(tag));\n/** @internal */\nexport const serviceOptional = tag => core.flatMap(core.context(), Context.getOption(tag));\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n/* @internal */\nexport const annotateCurrentSpan = function () {\n  const args = arguments;\n  return ignore(core.flatMap(currentSpan, span => core.sync(() => {\n    if (typeof args[0] === \"string\") {\n      span.attribute(args[0], args[1]);\n    } else {\n      for (const key in args[0]) {\n        span.attribute(key, args[0][key]);\n      }\n    }\n  })));\n};\n/* @internal */\nexport const linkSpanCurrent = function () {\n  const args = arguments;\n  const links = Array.isArray(args[0]) ? args[0] : [{\n    _tag: \"SpanLink\",\n    span: args[0],\n    attributes: args[1] ?? {}\n  }];\n  return ignore(core.flatMap(currentSpan, span => core.sync(() => span.addLinks(links))));\n};\n/* @internal */\nexport const annotateSpans = /*#__PURE__*/dual(args => core.isEffect(args[0]), function () {\n  const args = arguments;\n  return core.fiberRefLocallyWith(args[0], core.currentTracerSpanAnnotations, typeof args[1] === \"string\" ? HashMap.set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap.set(acc, key, value), annotations));\n});\n/** @internal */\nexport const currentParentSpan = /*#__PURE__*/serviceOptional(internalTracer.spanTag);\n/** @internal */\nexport const currentSpan = /*#__PURE__*/core.flatMap(/*#__PURE__*/core.context(), context => {\n  const span = context.unsafeMap.get(internalTracer.spanTag.key);\n  return span !== undefined && span._tag === \"Span\" ? core.succeed(span) : core.fail(new core.NoSuchElementException());\n});\n/* @internal */\nexport const linkSpans = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, span, attributes) => core.fiberRefLocallyWith(self, core.currentTracerSpanLinks, Chunk.append({\n  _tag: \"SpanLink\",\n  span,\n  attributes: attributes ?? {}\n})));\nconst bigint0 = /*#__PURE__*/BigInt(0);\nconst filterDisablePropagation = /*#__PURE__*/Option.flatMap(span => Context.get(span.context, internalTracer.DisablePropagation) ? span._tag === \"Span\" ? filterDisablePropagation(span.parent) : Option.none() : Option.some(span));\n/** @internal */\nexport const unsafeMakeSpan = (fiber, name, options) => {\n  const disablePropagation = !fiber.getFiberRef(core.currentTracerEnabled) || options.context && Context.get(options.context, internalTracer.DisablePropagation);\n  const context = fiber.getFiberRef(core.currentContext);\n  const parent = options.parent ? Option.some(options.parent) : options.root ? Option.none() : filterDisablePropagation(Context.getOption(context, internalTracer.spanTag));\n  let span;\n  if (disablePropagation) {\n    span = core.noopSpan({\n      name,\n      parent,\n      context: Context.add(options.context ?? Context.empty(), internalTracer.DisablePropagation, true)\n    });\n  } else {\n    const services = fiber.getFiberRef(defaultServices.currentServices);\n    const tracer = Context.get(services, internalTracer.tracerTag);\n    const clock = Context.get(services, Clock.Clock);\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled);\n    const fiberRefs = fiber.getFiberRefs();\n    const annotationsFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanAnnotations);\n    const linksFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanLinks);\n    const links = linksFromEnv._tag === \"Some\" ? options.links !== undefined ? [...Chunk.toReadonlyArray(linksFromEnv.value), ...(options.links ?? [])] : Chunk.toReadonlyArray(linksFromEnv.value) : options.links ?? Arr.empty();\n    span = tracer.span(name, parent, options.context ?? Context.empty(), links, timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, options.kind ?? \"internal\", options);\n    if (annotationsFromEnv._tag === \"Some\") {\n      HashMap.forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value));\n    }\n    if (options.attributes !== undefined) {\n      Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v));\n    }\n  }\n  if (typeof options.captureStackTrace === \"function\") {\n    internalCause.spanToTrace.set(span, options.captureStackTrace);\n  }\n  return span;\n};\n/** @internal */\nexport const makeSpan = (name, options) => {\n  options = internalTracer.addSpanStackTrace(options);\n  return core.withFiberRuntime(fiber => core.succeed(unsafeMakeSpan(fiber, name, options)));\n};\n/* @internal */\nexport const spanAnnotations = /*#__PURE__*/core.fiberRefGet(core.currentTracerSpanAnnotations);\n/* @internal */\nexport const spanLinks = /*#__PURE__*/core.fiberRefGet(core.currentTracerSpanLinks);\n/** @internal */\nexport const endSpan = (span, exit, clock, timingEnabled) => core.sync(() => {\n  if (span.status._tag === \"Ended\") {\n    return;\n  }\n  if (core.exitIsFailure(exit) && internalCause.spanToTrace.has(span)) {\n    // https://opentelemetry.io/docs/specs/semconv/registry/attributes/code/#code-stacktrace\n    span.attribute(\"code.stacktrace\", internalCause.spanToTrace.get(span)());\n  }\n  span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit);\n});\n/** @internal */\nexport const useSpan = (name, ...args) => {\n  const options = internalTracer.addSpanStackTrace(args.length === 1 ? undefined : args[0]);\n  const evaluate = args[args.length - 1];\n  return core.withFiberRuntime(fiber => {\n    const span = unsafeMakeSpan(fiber, name, options);\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled);\n    const clock = Context.get(fiber.getFiberRef(defaultServices.currentServices), clockTag);\n    return core.onExit(evaluate(span), exit => endSpan(span, exit, clock, timingEnabled));\n  });\n};\n/** @internal */\nexport const withParentSpan = /*#__PURE__*/dual(2, (self, span) => provideService(self, internalTracer.spanTag, span));\n/** @internal */\nexport const withSpan = function () {\n  const dataFirst = typeof arguments[0] !== \"string\";\n  const name = dataFirst ? arguments[1] : arguments[0];\n  const options = internalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);\n  if (dataFirst) {\n    const self = arguments[0];\n    return useSpan(name, options, span => withParentSpan(self, span));\n  }\n  return self => useSpan(name, options, span => withParentSpan(self, span));\n};\nexport const functionWithSpan = options => function () {\n  let captureStackTrace = options.captureStackTrace ?? false;\n  if (options.captureStackTrace !== false) {\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 2;\n    const error = new Error();\n    Error.stackTraceLimit = limit;\n    let cache = false;\n    captureStackTrace = () => {\n      if (cache !== false) {\n        return cache;\n      }\n      if (error.stack) {\n        const stack = error.stack.trim().split(\"\\n\");\n        cache = stack.slice(2).join(\"\\n\").trim();\n        return cache;\n      }\n    };\n  }\n  return core.suspend(() => {\n    const opts = typeof options.options === \"function\" ? options.options.apply(null, arguments) : options.options;\n    return withSpan(core.suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {\n      ...opts,\n      captureStackTrace\n    });\n  });\n};\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n/* @internal */\nexport const fromNullable = value => value == null ? core.fail(new core.NoSuchElementException()) : core.succeed(value);\n/* @internal */\nexport const optionFromOptional = self => core.catchAll(core.map(self, Option.some), error => core.isNoSuchElementException(error) ? succeedNone : core.fail(error));\n//# sourceMappingURL=core-effect.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
