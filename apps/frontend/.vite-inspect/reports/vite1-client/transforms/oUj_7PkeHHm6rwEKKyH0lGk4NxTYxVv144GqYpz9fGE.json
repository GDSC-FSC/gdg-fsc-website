{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/List.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * A data type for immutable linked lists representing ordered collections of elements of type `A`.\n *\n * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n * **Performance**\n *\n * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.\n *\n * @since 2.0.0\n */\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\nimport * as Arr from \"./Array.js\";\nimport * as Chunk from \"./Chunk.js\";\nimport * as Either from \"./Either.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity, unsafeCoerce } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/List\");\n/**\n * Converts the specified `List` to an `Array`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = self => Arr.fromIterable(self);\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.mapInput(Arr.getEquivalence(isEquivalent), toArray);\nconst _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);\nconst ConsProto = {\n  [TypeId]: TypeId,\n  _tag: \"Cons\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Cons\",\n      values: toArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag && _equivalence(this, that);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(toArray(this)));\n  },\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeCons = (head, tail) => {\n  const cons = Object.create(ConsProto);\n  cons.head = head;\n  cons.tail = tail;\n  return cons;\n};\nconst NilHash = /*#__PURE__*/Hash.string(\"Nil\");\nconst NilProto = {\n  [TypeId]: TypeId,\n  _tag: \"Nil\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Nil\"\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Hash.symbol]() {\n    return NilHash;\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag;\n  },\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst _Nil = /*#__PURE__*/Object.create(NilProto);\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isList = u => hasProperty(u, TypeId);\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNil = self => self._tag === \"Nil\";\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isCons = self => self._tag === \"Cons\";\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nil = () => _Nil;\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cons = (head, tail) => makeCons(head, tail);\n/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = nil;\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of = value => makeCons(value, _Nil);\n/**\n * Creates a new `List` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = makeCons(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = makeCons(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (...elements) => fromIterable(elements);\n/**\n * Appends the specified element to the end of the `List`, creating a new `Cons`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, element) => appendAll(self, of(element)));\n/**\n * Concatenates two lists, combining their elements.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n *   [1, 2, \"a\", \"b\"]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => prependAll(that, self));\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, element) => cons(element, self));\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n *   [\"a\", \"b\", 1, 2]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = makeCons(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = makeCons(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAllReversed = /*#__PURE__*/dual(2, (self, prefix) => {\n  let out = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    out = makeCons(pres.head, out);\n    pres = pres.tail;\n  }\n  return out;\n});\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= size(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n/**\n * Check if a predicate holds true for every `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => {\n  for (const a of self) {\n    if (!refinement(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Check if a predicate holds true for some `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n/**\n * Filters a list using the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => noneIn(self, predicate, false));\n// everything seen so far is not included\nconst noneIn = (self, predicate, isFlipped) => {\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\n// everything from 'start' is included, if everything from this point is in we can return the origin\n// start otherwise if we discover an element that is out we must create a new partial list.\nconst allIn = (start, remaining, predicate, isFlipped) => {\n  while (true) {\n    if (isNil(remaining)) {\n      return start;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(start, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\n// we have seen elements that should be included then one that should be excluded, start building\nconst partialFill = (origStart, firstMiss, predicate, isFlipped) => {\n  const newHead = makeCons(unsafeHead(origStart), _Nil);\n  let toProcess = unsafeTail(origStart);\n  let currentLast = newHead;\n  // we know that all elements are :: until at least firstMiss.tail\n  while (!(toProcess === firstMiss)) {\n    const newElem = makeCons(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = unsafeCoerce(newElem);\n    toProcess = unsafeCoerce(toProcess.tail);\n  }\n  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.\n  // currentLast is the last element in that list.\n  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n  let next = firstMiss.tail;\n  let nextToCopy = unsafeCoerce(next); // the next element we would need to copy to our list if we cant share.\n  while (!isNil(next)) {\n    // generally recommended is next.isNonEmpty but this incurs an extra method call.\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      // its not a match - do we have outstanding elements?\n      while (!(nextToCopy === next)) {\n        const newElem = makeCons(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = unsafeCoerce(nextToCopy.tail);\n      }\n      nextToCopy = unsafeCoerce(next.tail);\n      next = next.tail;\n    }\n  }\n  // we have remaining elements - they are unchanged attach them to the end\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = f(a);\n    if (Option.isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head);\n    }\n    these = these.tail;\n  }\n  return Option.none();\n});\n/**\n * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = makeCons(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = self => isNil(self) ? Option.none() : Option.some(self.head);\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const last = self => isNil(self) ? Option.none() : Option.some(unsafeLast(self));\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    let i = 0;\n    const head = makeCons(f(self.head, i++), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = makeCons(f(rest.head, i++), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (Either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceRight = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const tail = self => isNil(self) ? Option.none() : Option.some(self.tail);\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= size(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = makeCons(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n/**\n * Converts the specified `List` to a `Chunk`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const toChunk = self => Chunk.fromIterable(self);\nconst getExpectedListToBeNonEmptyErrorMessage = \"Expected List to be non-empty\";\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.head;\n};\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.tail;\n};\n//# sourceMappingURL=List.js.map",
      "start": 1768772628411,
      "end": 1768772628411
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628411,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
