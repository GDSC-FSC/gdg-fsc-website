{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/internal/command.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Chunk from \"effect/Chunk\";\nimport * as Effect from \"effect/Effect\";\nimport { dual } from \"effect/Function\";\nimport * as HashMap from \"effect/HashMap\";\nimport * as Inspectable from \"effect/Inspectable\";\nimport * as Option from \"effect/Option\";\nimport { pipeArguments } from \"effect/Pipeable\";\nimport * as Stream from \"effect/Stream\";\nimport * as commandExecutor from \"./commandExecutor.js\";\n/** @internal */\nexport const CommandTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Command\");\n/** @internal */\nexport const isCommand = u => typeof u === \"object\" && u != null && CommandTypeId in u;\n/** @internal */\nexport const env = /*#__PURE__*/dual(2, (self, environment) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          env: HashMap.union(self.env, HashMap.fromIterable(Object.entries(environment).filter(([v]) => v !== undefined)))\n        });\n      }\n    case \"PipedCommand\":\n      {\n        return pipeTo(env(self.left, environment), env(self.right, environment));\n      }\n  }\n});\n/** @internal */\nexport const exitCode = self => Effect.flatMap(commandExecutor.CommandExecutor, executor => executor.exitCode(self));\n/** @internal */\nexport const feed = /*#__PURE__*/dual(2, (self, input) => stdin(self, Stream.fromChunk(Chunk.of(new TextEncoder().encode(input)))));\n/** @internal */\nexport const flatten = self => Array.from(flattenLoop(self));\n/** @internal */\nconst flattenLoop = self => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return Chunk.of(self);\n      }\n    case \"PipedCommand\":\n      {\n        return Chunk.appendAll(flattenLoop(self.left), flattenLoop(self.right));\n      }\n  }\n};\n/** @internal */\nexport const runInShell = /*#__PURE__*/dual(2, (self, shell) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          shell\n        });\n      }\n    case \"PipedCommand\":\n      {\n        return pipeTo(runInShell(self.left, shell), runInShell(self.right, shell));\n      }\n  }\n});\n/** @internal */\nexport const lines = (command, encoding = \"utf-8\") => Effect.flatMap(commandExecutor.CommandExecutor, executor => executor.lines(command, encoding));\nconst Proto = {\n  [CommandTypeId]: CommandTypeId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  ...Inspectable.BaseProto\n};\nconst StandardProto = {\n  ...Proto,\n  _tag: \"StandardCommand\",\n  toJSON() {\n    return {\n      _id: \"@effect/platform/Command\",\n      _tag: this._tag,\n      command: this.command,\n      args: this.args,\n      env: Object.fromEntries(this.env),\n      cwd: this.cwd.toJSON(),\n      shell: this.shell,\n      gid: this.gid.toJSON(),\n      uid: this.uid.toJSON()\n    };\n  }\n};\nconst makeStandard = options => Object.assign(Object.create(StandardProto), options);\nconst PipedProto = {\n  ...Proto,\n  _tag: \"PipedCommand\",\n  toJSON() {\n    return {\n      _id: \"@effect/platform/Command\",\n      _tag: this._tag,\n      left: this.left.toJSON(),\n      right: this.right.toJSON()\n    };\n  }\n};\nconst makePiped = options => Object.assign(Object.create(PipedProto), options);\n/** @internal */\nexport const make = (command, ...args) => makeStandard({\n  command,\n  args,\n  env: HashMap.empty(),\n  cwd: Option.none(),\n  shell: false,\n  stdin: \"pipe\",\n  stdout: \"pipe\",\n  stderr: \"pipe\",\n  gid: Option.none(),\n  uid: Option.none()\n});\n/** @internal */\nexport const pipeTo = /*#__PURE__*/dual(2, (self, into) => makePiped({\n  left: self,\n  right: into\n}));\n/** @internal */\nexport const stderr = /*#__PURE__*/dual(2, (self, output) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          stderr: output\n        });\n      }\n    // For piped commands it only makes sense to provide `stderr` for the\n    // right-most command as the rest will be piped in.\n    case \"PipedCommand\":\n      {\n        return makePiped({\n          ...self,\n          right: stderr(self.right, output)\n        });\n      }\n  }\n});\n/** @internal */\nexport const stdin = /*#__PURE__*/dual(2, (self, input) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          stdin: input\n        });\n      }\n    // For piped commands it only makes sense to provide `stdin` for the\n    // left-most command as the rest will be piped in.\n    case \"PipedCommand\":\n      {\n        return makePiped({\n          ...self,\n          left: stdin(self.left, input)\n        });\n      }\n  }\n});\n/** @internal */\nexport const stdout = /*#__PURE__*/dual(2, (self, output) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          stdout: output\n        });\n      }\n    // For piped commands it only makes sense to provide `stderr` for the\n    // right-most command as the rest will be piped in.\n    case \"PipedCommand\":\n      {\n        return makePiped({\n          ...self,\n          right: stdout(self.right, output)\n        });\n      }\n  }\n});\n/** @internal */\nexport const start = command => Effect.flatMap(commandExecutor.CommandExecutor, executor => executor.start(command));\n/** @internal */\nexport const stream = command => Stream.flatMap(commandExecutor.CommandExecutor, executor => executor.stream(command));\n/** @internal */\nexport const streamLines = (command, encoding) => Stream.flatMap(commandExecutor.CommandExecutor, executor => executor.streamLines(command, encoding));\n/** @internal */\nexport const string = /*#__PURE__*/dual(args => isCommand(args[0]), (command, encoding) => Effect.flatMap(commandExecutor.CommandExecutor, executor => executor.string(command, encoding)));\n/** @internal */\nexport const workingDirectory = /*#__PURE__*/dual(2, (self, cwd) => {\n  switch (self._tag) {\n    case \"StandardCommand\":\n      {\n        return makeStandard({\n          ...self,\n          cwd: Option.some(cwd)\n        });\n      }\n    case \"PipedCommand\":\n      {\n        return pipeTo(workingDirectory(self.left, cwd), workingDirectory(self.right, cwd));\n      }\n  }\n});\n//# sourceMappingURL=command.js.map",
      "start": 1768772628752,
      "end": 1768772628752
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628752,
      "end": 1768772628768,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628770,
      "end": 1768772628785,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628788,
      "end": 1768772628803,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628806,
      "end": 1768772628811,
      "order": "post-post"
    }
  ]
}
