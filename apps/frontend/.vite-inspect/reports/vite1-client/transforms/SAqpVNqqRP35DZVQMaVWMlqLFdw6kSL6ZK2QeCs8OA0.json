{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/layer.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"../Cause.js\";\nimport * as Clock from \"../Clock.js\";\nimport * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as FiberRefsPatch from \"../FiberRefsPatch.js\";\nimport { constTrue, dual, pipe } from \"../Function.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as ScheduleDecision from \"../ScheduleDecision.js\";\nimport * as Intervals from \"../ScheduleIntervals.js\";\nimport * as Scope from \"../Scope.js\";\nimport * as effect from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport * as circular from \"./effect/circular.js\";\nimport * as ExecutionStrategy from \"./executionStrategy.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\nimport * as circularManagedRuntime from \"./managedRuntime/circular.js\";\nimport * as EffectOpCodes from \"./opCodes/effect.js\";\nimport * as OpCodes from \"./opCodes/layer.js\";\nimport * as ref from \"./ref.js\";\nimport * as runtime from \"./runtime.js\";\nimport * as runtimeFlags from \"./runtimeFlags.js\";\nimport * as synchronized from \"./synchronizedRef.js\";\nimport * as tracer from \"./tracer.js\";\n/** @internal */\nconst LayerSymbolKey = \"effect/Layer\";\n/** @internal */\nexport const LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);\nconst layerVariance = {\n  /* c8 ignore next */\n  _RIn: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _ROut: _ => _\n};\n/** @internal */\nexport const proto = {\n  [LayerTypeId]: layerVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nconst MemoMapTypeIdKey = \"effect/Layer/MemoMap\";\n/** @internal */\nexport const MemoMapTypeId = /*#__PURE__*/Symbol.for(MemoMapTypeIdKey);\n/** @internal */\nexport const CurrentMemoMap = /*#__PURE__*/Context.Reference()(\"effect/Layer/CurrentMemoMap\", {\n  defaultValue: () => unsafeMakeMemoMap()\n});\n/** @internal */\nexport const isLayer = u => hasProperty(u, LayerTypeId);\n/** @internal */\nexport const isFresh = self => {\n  return self._op_layer === OpCodes.OP_FRESH;\n};\n// -----------------------------------------------------------------------------\n// MemoMap\n// -----------------------------------------------------------------------------\n/** @internal */\nclass MemoMapImpl {\n  ref;\n  [MemoMapTypeId];\n  constructor(ref) {\n    this.ref = ref;\n    this[MemoMapTypeId] = MemoMapTypeId;\n  }\n  /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */\n  getOrElseMemoize(layer, scope) {\n    return pipe(synchronized.modifyEffect(this.ref, map => {\n      const inMap = map.get(layer);\n      if (inMap !== undefined) {\n        const [acquire, release] = inMap;\n        const cached = pipe(acquire, core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b))), core.onExit(core.exitMatch({\n          onFailure: () => core.void,\n          onSuccess: () => core.scopeAddFinalizerExit(scope, release)\n        })));\n        return core.succeed([cached, map]);\n      }\n      return pipe(ref.make(0), core.flatMap(observers => pipe(core.deferredMake(), core.flatMap(deferred => pipe(ref.make(() => core.void), core.map(finalizerRef => {\n        const resource = core.uninterruptibleMask(restore => pipe(fiberRuntime.scopeMake(), core.flatMap(innerScope => pipe(restore(core.flatMap(makeBuilder(layer, innerScope, true), f => effect.diffFiberRefs(f(this)))), core.exit, core.flatMap(exit => {\n          switch (exit._tag) {\n            case EffectOpCodes.OP_FAILURE:\n              {\n                return pipe(core.deferredFailCause(deferred, exit.effect_instruction_i0), core.zipRight(core.scopeClose(innerScope, exit)), core.zipRight(core.failCause(exit.effect_instruction_i0)));\n              }\n            case EffectOpCodes.OP_SUCCESS:\n              {\n                return pipe(ref.set(finalizerRef, exit => pipe(core.scopeClose(innerScope, exit), core.whenEffect(ref.modify(observers, n => [n === 1, n - 1])), core.asVoid)), core.zipRight(ref.update(observers, n => n + 1)), core.zipRight(core.scopeAddFinalizerExit(scope, exit => pipe(core.sync(() => map.delete(layer)), core.zipRight(ref.get(finalizerRef)), core.flatMap(finalizer => finalizer(exit))))), core.zipRight(core.deferredSucceed(deferred, exit.effect_instruction_i0)), core.as(exit.effect_instruction_i0[1]));\n              }\n          }\n        })))));\n        const memoized = [pipe(core.deferredAwait(deferred), core.onExit(core.exitMatchEffect({\n          onFailure: () => core.void,\n          onSuccess: () => ref.update(observers, n => n + 1)\n        }))), exit => pipe(ref.get(finalizerRef), core.flatMap(finalizer => finalizer(exit)))];\n        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];\n      }))))));\n    }), core.flatten);\n  }\n}\n/** @internal */\nexport const makeMemoMap = /*#__PURE__*/core.suspend(() => core.map(circular.makeSynchronized(new Map()), ref => new MemoMapImpl(ref)));\n/** @internal */\nexport const unsafeMakeMemoMap = () => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()));\n/** @internal */\nexport const build = self => fiberRuntime.scopeWith(scope => buildWithScope(self, scope));\n/** @internal */\nexport const buildWithScope = /*#__PURE__*/dual(2, (self, scope) => core.flatMap(makeMemoMap, memoMap => buildWithMemoMap(self, memoMap, scope)));\n/** @internal */\nexport const buildWithMemoMap = /*#__PURE__*/dual(3, (self, memoMap, scope) => core.flatMap(makeBuilder(self, scope), run => effect.provideService(run(memoMap), CurrentMemoMap, memoMap)));\nconst makeBuilder = (self, scope, inMemoMap = false) => {\n  const op = self;\n  switch (op._op_layer) {\n    case \"Locally\":\n      {\n        return core.sync(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope)));\n      }\n    case \"ExtendScope\":\n      {\n        return core.sync(() => memoMap => fiberRuntime.scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case \"Fold\":\n      {\n        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.layer, scope), core.matchCauseEffect({\n          onFailure: cause => memoMap.getOrElseMemoize(op.failureK(cause), scope),\n          onSuccess: value => memoMap.getOrElseMemoize(op.successK(value), scope)\n        })));\n      }\n    case \"Fresh\":\n      {\n        return core.sync(() => _ => pipe(op.layer, buildWithScope(scope)));\n      }\n    case \"FromEffect\":\n      {\n        return inMemoMap ? core.sync(() => _ => op.effect) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));\n      }\n    case \"Provide\":\n      {\n        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), core.flatMap(env => pipe(memoMap.getOrElseMemoize(op.second, scope), core.provideContext(env)))));\n      }\n    case \"Scoped\":\n      {\n        return inMemoMap ? core.sync(() => _ => fiberRuntime.scopeExtend(op.effect, scope)) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));\n      }\n    case \"Suspend\":\n      {\n        return core.sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));\n      }\n    case \"ProvideMerge\":\n      {\n        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), core.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));\n      }\n    case \"ZipWith\":\n      {\n        return core.gen(function* () {\n          const parallelScope = yield* core.scopeFork(scope, ExecutionStrategy.parallel);\n          const firstScope = yield* core.scopeFork(parallelScope, ExecutionStrategy.sequential);\n          const secondScope = yield* core.scopeFork(parallelScope, ExecutionStrategy.sequential);\n          return memoMap => pipe(memoMap.getOrElseMemoize(op.first, firstScope), fiberRuntime.zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {\n            concurrent: true\n          }));\n        });\n      }\n    case \"MergeAll\":\n      {\n        const layers = op.layers;\n        return core.map(core.scopeFork(scope, ExecutionStrategy.parallel), parallelScope => memoMap => {\n          const contexts = new Array(layers.length);\n          return core.map(fiberRuntime.forEachConcurrentDiscard(layers, core.fnUntraced(function* (layer, i) {\n            const scope = yield* core.scopeFork(parallelScope, ExecutionStrategy.sequential);\n            const context = yield* memoMap.getOrElseMemoize(layer, scope);\n            contexts[i] = context;\n          }), false, false), () => Context.mergeAll(...contexts));\n        });\n      }\n  }\n};\n// -----------------------------------------------------------------------------\n// Layer\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, onFailure) => match(self, {\n  onFailure,\n  onSuccess: succeedContext\n}));\n/** @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, onFailure) => matchCause(self, {\n  onFailure,\n  onSuccess: succeedContext\n}));\n/** @internal */\nexport const die = defect => failCause(Cause.die(defect));\n/** @internal */\nexport const dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));\n/** @internal */\nexport const discard = self => map(self, () => Context.empty());\n/** @internal */\nexport const context = () => fromEffectContext(core.context());\n/** @internal */\nexport const extendScope = self => {\n  const extendScope = Object.create(proto);\n  extendScope._op_layer = OpCodes.OP_EXTEND_SCOPE;\n  extendScope.layer = self;\n  return extendScope;\n};\n/** @internal */\nexport const fail = error => failCause(Cause.fail(error));\n/** @internal */\nexport const failSync = evaluate => failCauseSync(() => Cause.fail(evaluate()));\n/** @internal */\nexport const failCause = cause => fromEffectContext(core.failCause(cause));\n/** @internal */\nexport const failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate));\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onFailure: fail,\n  onSuccess: f\n}));\n/** @internal */\nexport const flatten = /*#__PURE__*/dual(2, (self, tag) => flatMap(self, Context.get(tag)));\n/** @internal */\nexport const fresh = self => {\n  const fresh = Object.create(proto);\n  fresh._op_layer = OpCodes.OP_FRESH;\n  fresh.layer = self;\n  return fresh;\n};\n/** @internal */\nexport const fromEffect = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = Context.isTag(a);\n  const tag = tagFirst ? a : b;\n  const effect = tagFirst ? b : a;\n  return fromEffectContext(core.map(effect, service => Context.make(tag, service)));\n});\n/** @internal */\nexport const fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));\n/** @internal */\nexport function fromEffectContext(effect) {\n  const fromEffect = Object.create(proto);\n  fromEffect._op_layer = OpCodes.OP_FROM_EFFECT;\n  fromEffect.effect = effect;\n  return fromEffect;\n}\n/** @internal */\nexport const fiberRefLocally = /*#__PURE__*/dual(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocally(ref, value)));\n/** @internal */\nexport const locallyEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const locally = Object.create(proto);\n  locally._op_layer = \"Locally\";\n  locally.self = self;\n  locally.f = f;\n  return locally;\n});\n/** @internal */\nexport const fiberRefLocallyWith = /*#__PURE__*/dual(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocallyWith(ref, value)));\n/** @internal */\nexport const fiberRefLocallyScoped = (self, value) => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(self, value));\n/** @internal */\nexport const fiberRefLocallyScopedWith = (self, value) => scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(self, value));\n/** @internal */\nexport const fromFunction = (tagA, tagB, f) => fromEffectContext(core.map(tagA, a => Context.make(tagB, f(a))));\n/** @internal */\nexport const launch = self => fiberRuntime.scopedEffect(core.zipRight(fiberRuntime.scopeWith(scope => pipe(self, buildWithScope(scope))), core.never));\n/** @internal */\nexport const mock = function () {\n  if (arguments.length === 1) {\n    return service => mockImpl(arguments[0], service);\n  }\n  return mockImpl(arguments[0], arguments[1]);\n};\nconst mockImpl = (tag, service) => succeed(tag, new Proxy({\n  ...service\n}, {\n  get(target, prop, _receiver) {\n    if (prop in target) {\n      return target[prop];\n    }\n    const prevLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 2;\n    const error = new Error(`${tag.key}: Unimplemented method \"${prop.toString()}\"`);\n    Error.stackTraceLimit = prevLimit;\n    error.name = \"UnimplementedError\";\n    return makeUnimplemented(error);\n  },\n  has: constTrue\n}));\nconst makeUnimplemented = error => {\n  const dead = core.die(error);\n  function unimplemented() {\n    return dead;\n  }\n  // @effect-diagnostics-next-line floatingEffect:off\n  Object.assign(unimplemented, dead);\n  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));\n  return unimplemented;\n};\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, context => succeedContext(f(context))));\n/** @internal */\nexport const mapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, error => failSync(() => f(error))));\n/** @internal */\nexport const matchCause = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  const fold = Object.create(proto);\n  fold._op_layer = OpCodes.OP_FOLD;\n  fold.layer = self;\n  fold.failureK = onFailure;\n  fold.successK = onSuccess;\n  return fold;\n});\n/** @internal */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => matchCause(self, {\n  onFailure: cause => {\n    const failureOrCause = Cause.failureOrCause(cause);\n    switch (failureOrCause._tag) {\n      case \"Left\":\n        {\n          return onFailure(failureOrCause.left);\n        }\n      case \"Right\":\n        {\n          return failCause(failureOrCause.right);\n        }\n    }\n  },\n  onSuccess\n}));\n/** @internal */\nexport const memoize = self => fiberRuntime.scopeWith(scope => core.map(effect.memoize(buildWithScope(self, scope)), fromEffectContext));\n/** @internal */\nexport const merge = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => Context.merge(a, b)));\n/** @internal */\nexport const mergeAll = (...layers) => {\n  const mergeAll = Object.create(proto);\n  mergeAll._op_layer = OpCodes.OP_MERGE_ALL;\n  mergeAll.layers = layers;\n  return mergeAll;\n};\n/** @internal */\nexport const orDie = self => catchAll(self, defect => die(defect));\n/** @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => catchAll(self, that));\n/** @internal */\nexport const passthrough = self => merge(context(), self);\n/** @internal */\nexport const project = /*#__PURE__*/dual(4, (self, tagA, tagB, f) => map(self, context => Context.make(tagB, f(Context.unsafeGet(context, tagA)))));\n/** @internal */\nexport const retry = /*#__PURE__*/dual(2, (self, schedule) => suspend(() => {\n  const stateTag = Context.GenericTag(\"effect/Layer/retry/{ state: unknown }\");\n  return pipe(succeed(stateTag, {\n    state: schedule.initial\n  }), flatMap(env => retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state)));\n}));\nconst retryLoop = (self, schedule, stateTag, state) => {\n  return pipe(self, catchAll(error => pipe(retryUpdate(schedule, stateTag, error, state), flatMap(env => fresh(retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state))))));\n};\nconst retryUpdate = (schedule, stateTag, error, state) => {\n  return fromEffect(stateTag, pipe(Clock.currentTimeMillis, core.flatMap(now => pipe(schedule.step(now, error, state), core.flatMap(([state, _, decision]) => ScheduleDecision.isDone(decision) ? core.fail(error) : pipe(Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now)), core.as({\n    state\n  })))))));\n};\n/** @internal */\nexport const scoped = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = Context.isTag(a);\n  const tag = tagFirst ? a : b;\n  const effect = tagFirst ? b : a;\n  return scopedContext(core.map(effect, service => Context.make(tag, service)));\n});\n/** @internal */\nexport const scopedDiscard = effect => scopedContext(pipe(effect, core.as(Context.empty())));\n/** @internal */\nexport const scopedContext = effect => {\n  const scoped = Object.create(proto);\n  scoped._op_layer = OpCodes.OP_SCOPED;\n  scoped.effect = effect;\n  return scoped;\n};\n/** @internal */\nexport const scope = /*#__PURE__*/scopedContext(/*#__PURE__*/core.map(/*#__PURE__*/fiberRuntime.acquireRelease(/*#__PURE__*/fiberRuntime.scopeMake(), (scope, exit) => scope.close(exit)), scope => Context.make(Scope.Scope, scope)));\n/** @internal */\nexport const service = tag => fromEffect(tag, tag);\n/** @internal */\nexport const succeed = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = Context.isTag(a);\n  const tag = tagFirst ? a : b;\n  const resource = tagFirst ? b : a;\n  return fromEffectContext(core.succeed(Context.make(tag, resource)));\n});\n/** @internal */\nexport const succeedContext = context => {\n  return fromEffectContext(core.succeed(context));\n};\n/** @internal */\nexport const empty = /*#__PURE__*/succeedContext(/*#__PURE__*/Context.empty());\n/** @internal */\nexport const suspend = evaluate => {\n  const suspend = Object.create(proto);\n  suspend._op_layer = OpCodes.OP_SUSPEND;\n  suspend.evaluate = evaluate;\n  return suspend;\n};\n/** @internal */\nexport const sync = /*#__PURE__*/dual(2, (a, b) => {\n  const tagFirst = Context.isTag(a);\n  const tag = tagFirst ? a : b;\n  const evaluate = tagFirst ? b : a;\n  return fromEffectContext(core.sync(() => Context.make(tag, evaluate())));\n});\n/** @internal */\nexport const syncContext = evaluate => {\n  return fromEffectContext(core.sync(evaluate));\n};\n/** @internal */\nexport const tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, context => fromEffectContext(core.as(f(context), context))));\n/** @internal */\nexport const tapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, e => fromEffectContext(core.flatMap(f(e), () => core.fail(e)))));\n/** @internal */\nexport const tapErrorCause = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => fromEffectContext(core.flatMap(f(cause), () => core.failCause(cause)))));\n/** @internal */\nexport const toRuntime = self => pipe(fiberRuntime.scopeWith(scope => buildWithScope(self, scope)), core.flatMap(context => pipe(runtime.runtime(), core.provideContext(context))));\n/** @internal */\nexport const toRuntimeWithMemoMap = /*#__PURE__*/dual(2, (self, memoMap) => core.flatMap(fiberRuntime.scopeWith(scope => buildWithMemoMap(self, memoMap, scope)), context => pipe(runtime.runtime(), core.provideContext(context))));\n/** @internal */\nexport const provide = /*#__PURE__*/dual(2, (self, that) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._op_layer = OpCodes.OP_PROVIDE;\n  provideTo.first = Object.create(proto, {\n    _op_layer: {\n      value: OpCodes.OP_PROVIDE_MERGE,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: Array.isArray(that) ? mergeAll(...that) : that\n    },\n    zipK: {\n      value: (a, b) => pipe(a, Context.merge(b))\n    }\n  });\n  provideTo.second = self;\n  return provideTo;\n}));\n/** @internal */\nexport const provideMerge = /*#__PURE__*/dual(2, (that, self) => {\n  const zipWith = Object.create(proto);\n  zipWith._op_layer = OpCodes.OP_PROVIDE_MERGE;\n  zipWith.first = self;\n  zipWith.second = provide(that, self);\n  zipWith.zipK = (a, b) => {\n    return pipe(a, Context.merge(b));\n  };\n  return zipWith;\n});\n/** @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => suspend(() => {\n  const zipWith = Object.create(proto);\n  zipWith._op_layer = OpCodes.OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = that;\n  zipWith.zipK = f;\n  return zipWith;\n}));\n/** @internal */\nexport const unwrapEffect = self => {\n  const tag = Context.GenericTag(\"effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>\");\n  return flatMap(fromEffect(tag, self), context => Context.get(context, tag));\n};\n/** @internal */\nexport const unwrapScoped = self => {\n  const tag = Context.GenericTag(\"effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>\");\n  return flatMap(scoped(tag, self), context => Context.get(context, tag));\n};\n// -----------------------------------------------------------------------------\n// logging\n// -----------------------------------------------------------------------------\nexport const annotateLogs = /*#__PURE__*/dual(args => isLayer(args[0]), function () {\n  const args = arguments;\n  return fiberRefLocallyWith(args[0], core.currentLogAnnotations, typeof args[1] === \"string\" ? HashMap.set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap.set(acc, key, value), annotations));\n});\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\nexport const annotateSpans = /*#__PURE__*/dual(args => isLayer(args[0]), function () {\n  const args = arguments;\n  return fiberRefLocallyWith(args[0], core.currentTracerSpanAnnotations, typeof args[1] === \"string\" ? HashMap.set(args[1], args[2]) : annotations => Object.entries(args[1]).reduce((acc, [key, value]) => HashMap.set(acc, key, value), annotations));\n});\n/** @internal */\nexport const withSpan = function () {\n  const dataFirst = typeof arguments[0] !== \"string\";\n  const name = dataFirst ? arguments[1] : arguments[0];\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);\n  if (dataFirst) {\n    const self = arguments[0];\n    return unwrapScoped(core.map(options?.onEnd ? core.tap(fiberRuntime.makeSpanScoped(name, options), span => fiberRuntime.addFinalizer(exit => options.onEnd(span, exit))) : fiberRuntime.makeSpanScoped(name, options), span => withParentSpan(self, span)));\n  }\n  return self => unwrapScoped(core.map(options?.onEnd ? core.tap(fiberRuntime.makeSpanScoped(name, options), span => fiberRuntime.addFinalizer(exit => options.onEnd(span, exit))) : fiberRuntime.makeSpanScoped(name, options), span => withParentSpan(self, span)));\n};\n/** @internal */\nexport const withParentSpan = /*#__PURE__*/dual(2, (self, span) => provide(self, succeedContext(Context.make(tracer.spanTag, span))));\n// circular with Effect\nconst provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) => fiberRuntime.scopedWith(scope => core.flatMap(buildWithScope(layer, scope), context => core.provideSomeContext(self, context))));\nconst provideSomeRuntime = /*#__PURE__*/dual(2, (self, rt) => {\n  const patchRefs = FiberRefsPatch.diff(runtime.defaultRuntime.fiberRefs, rt.fiberRefs);\n  const patchFlags = runtimeFlags.diff(runtime.defaultRuntime.runtimeFlags, rt.runtimeFlags);\n  return core.uninterruptibleMask(restore => core.withFiberRuntime(fiber => {\n    const oldContext = fiber.getFiberRef(core.currentContext);\n    const oldRefs = fiber.getFiberRefs();\n    const newRefs = FiberRefsPatch.patch(fiber.id(), oldRefs)(patchRefs);\n    const oldFlags = fiber.currentRuntimeFlags;\n    const newFlags = runtimeFlags.patch(patchFlags)(oldFlags);\n    const rollbackRefs = FiberRefsPatch.diff(newRefs, oldRefs);\n    const rollbackFlags = runtimeFlags.diff(newFlags, oldFlags);\n    fiber.setFiberRefs(newRefs);\n    fiber.currentRuntimeFlags = newFlags;\n    return fiberRuntime.ensuring(core.provideSomeContext(restore(self), Context.merge(oldContext, rt.context)), core.withFiberRuntime(fiber => {\n      fiber.setFiberRefs(FiberRefsPatch.patch(fiber.id(), fiber.getFiberRefs())(rollbackRefs));\n      fiber.currentRuntimeFlags = runtimeFlags.patch(rollbackFlags)(fiber.currentRuntimeFlags);\n      return core.void;\n    }));\n  }));\n});\n/** @internal */\nexport const effect_provide = /*#__PURE__*/dual(2, (self, source) => {\n  if (Array.isArray(source)) {\n    // @ts-expect-error\n    return provideSomeLayer(self, mergeAll(...source));\n  } else if (isLayer(source)) {\n    return provideSomeLayer(self, source);\n  } else if (Context.isContext(source)) {\n    return core.provideSomeContext(self, source);\n  } else if (circularManagedRuntime.TypeId in source) {\n    return core.flatMap(source.runtimeEffect, rt => provideSomeRuntime(self, rt));\n  } else {\n    return provideSomeRuntime(self, source);\n  }\n});\n//# sourceMappingURL=layer.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
