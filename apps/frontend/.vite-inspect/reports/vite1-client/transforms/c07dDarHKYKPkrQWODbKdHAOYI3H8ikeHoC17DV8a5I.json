{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stream.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"../Cause.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Clock from \"../Clock.js\";\nimport * as Context from \"../Context.js\";\nimport * as Deferred from \"../Deferred.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as Effect from \"../Effect.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport * as Exit from \"../Exit.js\";\nimport * as Fiber from \"../Fiber.js\";\nimport * as FiberRef from \"../FiberRef.js\";\nimport { constTrue, dual, identity, pipe } from \"../Function.js\";\nimport * as internalExecutionPlan from \"../internal/executionPlan.js\";\nimport * as Layer from \"../Layer.js\";\nimport * as MergeDecision from \"../MergeDecision.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as PubSub from \"../PubSub.js\";\nimport * as Queue from \"../Queue.js\";\nimport * as RcRef from \"../RcRef.js\";\nimport * as Ref from \"../Ref.js\";\nimport * as Runtime from \"../Runtime.js\";\nimport * as Schedule from \"../Schedule.js\";\nimport * as HaltStrategy from \"../StreamHaltStrategy.js\";\nimport * as TPubSub from \"../TPubSub.js\";\nimport * as TQueue from \"../TQueue.js\";\nimport * as Tuple from \"../Tuple.js\";\nimport * as channel from \"./channel.js\";\nimport * as channelExecutor from \"./channel/channelExecutor.js\";\nimport * as MergeStrategy from \"./channel/mergeStrategy.js\";\nimport * as core from \"./core-stream.js\";\nimport * as doNotation from \"./doNotation.js\";\nimport { RingBuffer } from \"./ringBuffer.js\";\nimport * as InternalSchedule from \"./schedule.js\";\nimport * as sink_ from \"./sink.js\";\nimport * as DebounceState from \"./stream/debounceState.js\";\nimport * as emit from \"./stream/emit.js\";\nimport * as haltStrategy from \"./stream/haltStrategy.js\";\nimport * as Handoff from \"./stream/handoff.js\";\nimport * as HandoffSignal from \"./stream/handoffSignal.js\";\nimport * as pull from \"./stream/pull.js\";\nimport * as SinkEndReason from \"./stream/sinkEndReason.js\";\nimport * as ZipAllState from \"./stream/zipAllState.js\";\nimport * as ZipChunksState from \"./stream/zipChunksState.js\";\nimport * as InternalTake from \"./take.js\";\nimport * as InternalTracer from \"./tracer.js\";\n/** @internal */\nconst StreamSymbolKey = \"effect/Stream\";\n/** @internal */\nexport const StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);\n/** @internal */\nconst streamVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nexport class StreamImpl {\n  channel;\n  [StreamTypeId] = streamVariance;\n  constructor(channel) {\n    this.channel = channel;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nexport const isStream = u => hasProperty(u, StreamTypeId) || Effect.isEffect(u);\n/** @internal */\nexport const DefaultChunkSize = 4096;\n/** @internal */\nexport const accumulate = self => chunks(accumulateChunks(self));\n/** @internal */\nexport const accumulateChunks = self => {\n  const accumulator = s => core.readWith({\n    onInput: input => {\n      const next = Chunk.appendAll(s, input);\n      return core.flatMap(core.write(next), () => accumulator(next));\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(core.pipeTo(toChannel(self), accumulator(Chunk.empty())));\n};\n/** @internal */\nexport const acquireRelease = (acquire, release) => scoped(Effect.acquireRelease(acquire, release));\n/** @internal */\nexport const aggregate = /*#__PURE__*/dual(2, (self, sink) => aggregateWithin(self, sink, Schedule.forever));\n/** @internal */\nexport const aggregateWithin = /*#__PURE__*/dual(3, (self, sink, schedule) => filterMap(aggregateWithinEither(self, sink, schedule), _ => Either.match(_, {\n  onLeft: Option.none,\n  onRight: Option.some\n})));\n/** @internal */\nexport const aggregateWithinEither = /*#__PURE__*/dual(3, (self, sink, schedule) => {\n  const layer = Effect.all([Handoff.make(), Ref.make(SinkEndReason.ScheduleEnd), Ref.make(Chunk.empty()), Schedule.driver(schedule), Ref.make(false), Ref.make(false)]);\n  return fromEffect(layer).pipe(flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {\n    const handoffProducer = core.readWithCause({\n      onInput: input => core.flatMap(core.fromEffect(pipe(handoff, Handoff.offer(HandoffSignal.emit(input)), Effect.when(() => Chunk.isNonEmpty(input)))), () => handoffProducer),\n      onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),\n      onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))\n    });\n    const handoffConsumer = pipe(Ref.getAndSet(sinkLeftovers, Chunk.empty()), Effect.flatMap(leftovers => {\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(Ref.set(consumed, true), Effect.zipRight(Effect.succeed(pipe(core.write(leftovers), core.flatMap(() => handoffConsumer)))));\n      }\n      return pipe(Handoff.take(handoff), Effect.map(signal => {\n        switch (signal._tag) {\n          case HandoffSignal.OP_EMIT:\n            {\n              return pipe(core.fromEffect(Ref.set(consumed, true)), channel.zipRight(core.write(signal.elements)), channel.zipRight(core.fromEffect(Ref.get(endAfterEmit))), core.flatMap(bool => bool ? core.void : handoffConsumer));\n            }\n          case HandoffSignal.OP_HALT:\n            {\n              return core.failCause(signal.cause);\n            }\n          case HandoffSignal.OP_END:\n            {\n              if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {\n                return pipe(Ref.get(consumed), Effect.map(bool => bool ? core.fromEffect(pipe(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd), Effect.zipRight(Ref.set(endAfterEmit, true)))) : pipe(core.fromEffect(pipe(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd), Effect.zipRight(Ref.set(endAfterEmit, true)))), core.flatMap(() => handoffConsumer))), channel.unwrap);\n              }\n              return pipe(Ref.set(sinkEndReason, signal.reason), Effect.zipRight(Ref.set(endAfterEmit, true)), core.fromEffect);\n            }\n        }\n      }));\n    }), channel.unwrap);\n    const timeout = lastB => scheduleDriver.next(lastB);\n    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {\n      const forkSink = pipe(Ref.set(consumed, false), Effect.zipRight(Ref.set(endAfterEmit, false)), Effect.zipRight(pipe(handoffConsumer, channel.pipeToOrFail(sink_.toChannel(sink)), core.collectElements, channel.run, Effect.forkIn(scope))));\n      const handleSide = (leftovers, b, c) => pipe(Ref.set(sinkLeftovers, Chunk.flatten(leftovers)), Effect.zipRight(Effect.map(Ref.get(sinkEndReason), reason => {\n        switch (reason._tag) {\n          case SinkEndReason.OP_SCHEDULE_END:\n            {\n              return pipe(Effect.all([Ref.get(consumed), forkSink, pipe(timeout(Option.some(b)), Effect.forkIn(scope))]), Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {\n                const toWrite = pipe(c, Option.match({\n                  onNone: () => Chunk.of(Either.right(b)),\n                  onSome: c => Chunk.make(Either.right(b), Either.left(c))\n                }));\n                if (wasConsumed) {\n                  return pipe(core.write(toWrite), core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope)));\n                }\n                return scheduledAggregator(sinkFiber, scheduleFiber, scope);\n              }), channel.unwrap);\n            }\n          case SinkEndReason.OP_UPSTREAM_END:\n            {\n              return pipe(Ref.get(consumed), Effect.map(wasConsumed => wasConsumed ? core.write(Chunk.of(Either.right(b))) : core.void), channel.unwrap);\n            }\n        }\n      })), channel.unwrap);\n      return channel.unwrap(Effect.raceWith(Fiber.join(sinkFiber), Fiber.join(scheduleFiber), {\n        onSelfDone: (sinkExit, _) => pipe(Fiber.interrupt(scheduleFiber), Effect.zipRight(pipe(Effect.suspend(() => sinkExit), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))))),\n        onOtherDone: (scheduleExit, _) => Effect.matchCauseEffect(Effect.suspend(() => scheduleExit), {\n          onFailure: cause => Either.match(Cause.failureOrCause(cause), {\n            onLeft: () => pipe(handoff, Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd)), Effect.forkDaemon, Effect.zipRight(pipe(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))))),\n            onRight: cause => pipe(handoff, Handoff.offer(HandoffSignal.halt(cause)), Effect.forkDaemon, Effect.zipRight(pipe(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none())))))\n          }),\n          onSuccess: c => pipe(handoff, Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd)), Effect.forkDaemon, Effect.zipRight(pipe(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c))))))\n        })\n      }));\n    };\n    return unwrapScopedWith(scope => core.pipeTo(toChannel(self), handoffProducer).pipe(channel.run, Effect.forkIn(scope), Effect.zipRight(channel.pipeToOrFail(handoffConsumer, sink_.toChannel(sink)).pipe(core.collectElements, channel.run, Effect.forkIn(scope), Effect.flatMap(sinkFiber => timeout(Option.none()).pipe(Effect.forkIn(scope), Effect.map(scheduleFiber => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))))))));\n  }));\n});\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, value) => map(self, () => value));\nconst queueFromBufferOptions = bufferSize => {\n  if (bufferSize === \"unbounded\") {\n    return Queue.unbounded();\n  } else if (typeof bufferSize === \"number\" || bufferSize === undefined) {\n    return Queue.bounded(bufferSize ?? 16);\n  }\n  switch (bufferSize.strategy) {\n    case \"dropping\":\n      return Queue.dropping(bufferSize.bufferSize ?? 16);\n    case \"sliding\":\n      return Queue.sliding(bufferSize.bufferSize ?? 16);\n    default:\n      return Queue.bounded(bufferSize.bufferSize ?? 16);\n  }\n};\n/** @internal */\nexport const _async = (register, bufferSize) => Effect.acquireRelease(queueFromBufferOptions(bufferSize), queue => Queue.shutdown(queue)).pipe(Effect.flatMap(output => Effect.runtime().pipe(Effect.flatMap(runtime => Effect.sync(() => {\n  const runPromiseExit = Runtime.runPromiseExit(runtime);\n  const canceler = register(emit.make(resume => InternalTake.fromPull(resume).pipe(Effect.flatMap(take => Queue.offer(output, take)), Effect.asVoid, runPromiseExit).then(exit => {\n    if (Exit.isFailure(exit)) {\n      if (!Cause.isInterrupted(exit.cause)) {\n        throw Cause.squash(exit.cause);\n      }\n    }\n  })));\n  return canceler;\n})), Effect.map(value => {\n  const loop = Queue.take(output).pipe(Effect.flatMap(take => InternalTake.done(take)), Effect.match({\n    onFailure: maybeError => core.fromEffect(Queue.shutdown(output)).pipe(channel.zipRight(Option.match(maybeError, {\n      onNone: () => core.void,\n      onSome: error => core.fail(error)\n    }))),\n    onSuccess: chunk => core.write(chunk).pipe(core.flatMap(() => loop))\n  }), channel.unwrap);\n  return fromChannel(loop).pipe(ensuring(value ?? Effect.void));\n}))), unwrapScoped);\n/** @internal */\nexport const asyncEffect = (register, bufferSize) => pipe(Effect.acquireRelease(queueFromBufferOptions(bufferSize), queue => Queue.shutdown(queue)), Effect.flatMap(output => pipe(Effect.runtime(), Effect.flatMap(runtime => pipe(register(emit.make(k => pipe(InternalTake.fromPull(k), Effect.flatMap(take => Queue.offer(output, take)), Effect.asVoid, Runtime.runPromiseExit(runtime)).then(exit => {\n  if (Exit.isFailure(exit)) {\n    if (!Cause.isInterrupted(exit.cause)) {\n      throw Cause.squash(exit.cause);\n    }\n  }\n}))), Effect.map(() => {\n  const loop = pipe(Queue.take(output), Effect.flatMap(InternalTake.done), Effect.match({\n    onFailure: maybeError => pipe(core.fromEffect(Queue.shutdown(output)), channel.zipRight(Option.match(maybeError, {\n      onNone: () => core.void,\n      onSome: core.fail\n    }))),\n    onSuccess: chunk => pipe(core.write(chunk), core.flatMap(() => loop))\n  }), channel.unwrap);\n  return loop;\n}))))), channel.unwrapScoped, fromChannel);\nconst queueFromBufferOptionsPush = options => {\n  if (options?.bufferSize === \"unbounded\" || options?.bufferSize === undefined && options?.strategy === undefined) {\n    return Queue.unbounded();\n  }\n  switch (options?.strategy) {\n    case \"sliding\":\n      return Queue.sliding(options.bufferSize ?? 16);\n    default:\n      return Queue.dropping(options?.bufferSize ?? 16);\n  }\n};\n/** @internal */\nexport const asyncPush = (register, options) => Effect.acquireRelease(queueFromBufferOptionsPush(options), Queue.shutdown).pipe(Effect.tap(queue => FiberRef.getWith(FiberRef.currentScheduler, scheduler => register(emit.makePush(queue, scheduler)))), Effect.map(queue => {\n  const loop = core.flatMap(Queue.take(queue), item => Exit.isExit(item) ? Exit.isSuccess(item) ? core.void : core.failCause(item.cause) : channel.zipRight(core.write(Chunk.unsafeFromArray(item)), loop));\n  return loop;\n}), channel.unwrapScoped, fromChannel);\n/** @internal */\nexport const asyncScoped = (register, bufferSize) => pipe(Effect.acquireRelease(queueFromBufferOptions(bufferSize), queue => Queue.shutdown(queue)), Effect.flatMap(output => pipe(Effect.runtime(), Effect.flatMap(runtime => pipe(register(emit.make(k => pipe(InternalTake.fromPull(k), Effect.flatMap(take => Queue.offer(output, take)), Effect.asVoid, Runtime.runPromiseExit(runtime)).then(exit => {\n  if (Exit.isFailure(exit)) {\n    if (!Cause.isInterrupted(exit.cause)) {\n      throw Cause.squash(exit.cause);\n    }\n  }\n}))), Effect.zipRight(Ref.make(false)), Effect.flatMap(ref => pipe(Ref.get(ref), Effect.map(isDone => isDone ? pull.end() : pipe(Queue.take(output), Effect.flatMap(InternalTake.done), Effect.onError(() => pipe(Ref.set(ref, true), Effect.zipRight(Queue.shutdown(output)))))))))))), scoped, flatMap(repeatEffectChunkOption));\n/** @internal */\nexport const branchAfter = /*#__PURE__*/dual(3, (self, n, f) => suspend(() => {\n  const buffering = acc => core.readWith({\n    onInput: input => {\n      const nextSize = acc.length + input.length;\n      if (nextSize >= n) {\n        const [b1, b2] = pipe(input, Chunk.splitAt(n - acc.length));\n        return running(pipe(acc, Chunk.appendAll(b1)), b2);\n      }\n      return buffering(pipe(acc, Chunk.appendAll(input)));\n    },\n    onFailure: core.fail,\n    onDone: () => running(acc, Chunk.empty())\n  });\n  const running = (prefix, leftover) => core.pipeTo(channel.zipRight(core.write(leftover), channel.identityChannel()), toChannel(f(prefix)));\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(buffering(Chunk.empty()))));\n}));\n/** @internal */\nexport const broadcast = /*#__PURE__*/dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), Effect.map(tuple => tuple.map(queue => flattenTake(fromQueue(queue, {\n  shutdown: true\n}))))));\n/** @internal */\nexport const broadcastDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => Effect.map(toPubSub(self, maximumLag), pubsub => flattenTake(fromPubSub(pubsub))));\nexport const share = /*#__PURE__*/dual(2, (self, options) => Effect.map(RcRef.make({\n  acquire: broadcastDynamic(self, options),\n  idleTimeToLive: options.idleTimeToLive\n}), rcRef => unwrapScoped(RcRef.get(rcRef))));\n/** @internal */\nexport const broadcastedQueues = /*#__PURE__*/dual(3, (self, n, maximumLag) => Effect.flatMap(pubsubFromOptions(maximumLag), pubsub => pipe(Effect.all(Array.from({\n  length: n\n}, () => PubSub.subscribe(pubsub))), Effect.tap(() => Effect.forkScoped(runIntoPubSubScoped(self, pubsub))))));\n/** @internal */\nexport const broadcastedQueuesDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => Effect.map(toPubSub(self, maximumLag), PubSub.subscribe));\n/** @internal */\nexport const buffer = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.capacity === \"unbounded\") {\n    return bufferUnbounded(self);\n  } else if (options.strategy === \"dropping\") {\n    return bufferDropping(self, options.capacity);\n  } else if (options.strategy === \"sliding\") {\n    return bufferSliding(self, options.capacity);\n  }\n  const queue = toQueueOfElements(self, options);\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {\n    const process = pipe(core.fromEffect(Queue.take(queue)), core.flatMap(Exit.match({\n      onFailure: cause => pipe(Cause.flipCauseOption(cause), Option.match({\n        onNone: () => core.void,\n        onSome: core.failCause\n      })),\n      onSuccess: value => core.flatMap(core.write(Chunk.of(value)), () => process)\n    })));\n    return process;\n  })));\n});\n/** @internal */\nexport const bufferChunks = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.strategy === \"dropping\") {\n    return bufferChunksDropping(self, options.capacity);\n  } else if (options.strategy === \"sliding\") {\n    return bufferChunksSliding(self, options.capacity);\n  }\n  const queue = toQueue(self, options);\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {\n    const process = pipe(core.fromEffect(Queue.take(queue)), core.flatMap(InternalTake.match({\n      onEnd: () => core.void,\n      onFailure: core.failCause,\n      onSuccess: value => pipe(core.write(value), core.flatMap(() => process))\n    })));\n    return process;\n  })));\n});\nconst bufferChunksDropping = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(self)));\n});\nconst bufferChunksSliding = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(self)));\n});\nconst bufferDropping = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));\n});\nconst bufferSliding = /*#__PURE__*/dual(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, toChannel(pipe(self, rechunk(1)))));\n});\nconst bufferUnbounded = self => {\n  const queue = toQueue(self, {\n    strategy: \"unbounded\"\n  });\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {\n    const process = pipe(core.fromEffect(Queue.take(queue)), core.flatMap(InternalTake.match({\n      onEnd: () => core.void,\n      onFailure: core.failCause,\n      onSuccess: value => core.flatMap(core.write(value), () => process)\n    })));\n    return process;\n  })));\n};\nconst bufferSignal = (scoped, bufferChannel) => {\n  const producer = (queue, ref) => {\n    const terminate = take => pipe(Ref.get(ref), Effect.tap(Deferred.await), Effect.zipRight(Deferred.make()), Effect.flatMap(deferred => pipe(Queue.offer(queue, [take, deferred]), Effect.zipRight(Ref.set(ref, deferred)), Effect.zipRight(Deferred.await(deferred)))), Effect.asVoid, core.fromEffect);\n    return core.readWithCause({\n      onInput: input => pipe(Deferred.make(), Effect.flatMap(deferred => pipe(Queue.offer(queue, [InternalTake.chunk(input), deferred]), Effect.flatMap(added => pipe(Ref.set(ref, deferred), Effect.when(() => added))))), Effect.asVoid, core.fromEffect, core.flatMap(() => producer(queue, ref))),\n      onFailure: error => terminate(InternalTake.failCause(error)),\n      onDone: () => terminate(InternalTake.end)\n    });\n  };\n  const consumer = queue => {\n    const process = pipe(core.fromEffect(Queue.take(queue)), core.flatMap(([take, deferred]) => channel.zipRight(core.fromEffect(Deferred.succeed(deferred, void 0)), InternalTake.match(take, {\n      onEnd: () => core.void,\n      onFailure: core.failCause,\n      onSuccess: value => pipe(core.write(value), core.flatMap(() => process))\n    }))));\n    return process;\n  };\n  return channel.unwrapScoped(pipe(scoped, Effect.flatMap(queue => pipe(Deferred.make(), Effect.tap(start => Deferred.succeed(start, void 0)), Effect.flatMap(start => pipe(Ref.make(start), Effect.flatMap(ref => pipe(bufferChannel, core.pipeTo(producer(queue, ref)), channel.runScoped, Effect.forkScoped)), Effect.as(consumer(queue))))))));\n};\n/** @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), {\n  onLeft: f,\n  onRight: failCause\n})));\n/** @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), core.catchAllCause(cause => toChannel(f(cause))))));\n/** @internal */\nexport const catchSome = /*#__PURE__*/dual(2, (self, pf) => pipe(self, catchAll(error => pipe(pf(error), Option.getOrElse(() => fail(error))))));\n/** @internal */\nexport const catchSomeCause = /*#__PURE__*/dual(2, (self, pf) => pipe(self, catchAllCause(cause => pipe(pf(cause), Option.getOrElse(() => failCause(cause))))));\n/* @internal */\nexport const catchTag = /*#__PURE__*/dual(3, (self, k, f) => catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return f(e);\n  }\n  return fail(e);\n}));\n/** @internal */\nexport const catchTags = /*#__PURE__*/dual(2, (self, cases) => catchAll(self, e => {\n  const keys = Object.keys(cases);\n  if (\"_tag\" in e && keys.includes(e[\"_tag\"])) {\n    return cases[e[\"_tag\"]](e);\n  }\n  return fail(e);\n}));\n/** @internal */\nexport const changes = self => pipe(self, changesWith((x, y) => Equal.equals(y)(x)));\n/** @internal */\nexport const changesWith = /*#__PURE__*/dual(2, (self, f) => {\n  const writer = last => core.readWithCause({\n    onInput: input => {\n      const [newLast, newChunk] = Chunk.reduce(input, [last, Chunk.empty()], ([option, outputs], output) => {\n        if (Option.isSome(option) && f(option.value, output)) {\n          return [Option.some(output), outputs];\n        }\n        return [Option.some(output), pipe(outputs, Chunk.append(output))];\n      });\n      return core.flatMap(core.write(newChunk), () => writer(newLast));\n    },\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer(Option.none()))));\n});\n/** @internal */\nexport const changesWithEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const writer = last => core.readWithCause({\n    onInput: input => pipe(input, Effect.reduce([last, Chunk.empty()], ([option, outputs], output) => {\n      if (Option.isSome(option)) {\n        return pipe(f(option.value, output), Effect.map(bool => bool ? [Option.some(output), outputs] : [Option.some(output), pipe(outputs, Chunk.append(output))]));\n      }\n      return Effect.succeed([Option.some(output), pipe(outputs, Chunk.append(output))]);\n    }), core.fromEffect, core.flatMap(([newLast, newChunk]) => pipe(core.write(newChunk), core.flatMap(() => writer(newLast))))),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer(Option.none()))));\n});\n/** @internal */\nexport const chunks = self => pipe(self, mapChunks(Chunk.of));\n/** @internal */\nexport const chunksWith = /*#__PURE__*/dual(2, (self, f) => flattenChunks(f(chunks(self))));\nconst unsome = effect => Effect.catchAll(Effect.asSome(effect), o => o._tag === \"None\" ? Effect.succeedNone : Effect.fail(o.value));\n/** @internal */\nexport const combine = /*#__PURE__*/dual(4, (self, that, s, f) => {\n  function producer(handoff, latch) {\n    return core.fromEffect(Handoff.take(latch)).pipe(channel.zipRight(core.readWithCause({\n      onInput: input => core.flatMap(core.fromEffect(Handoff.offer(handoff, Exit.succeed(input))), () => producer(handoff, latch)),\n      onFailure: cause => core.fromEffect(Handoff.offer(handoff, Exit.failCause(pipe(cause, Cause.map(Option.some))))),\n      onDone: () => core.flatMap(core.fromEffect(Handoff.offer(handoff, Exit.fail(Option.none()))), () => producer(handoff, latch))\n    })));\n  }\n  return new StreamImpl(channel.unwrapScopedWith(scope => Effect.all([Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()]).pipe(Effect.tap(([left, _, latchL]) => toChannel(self).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(left, latchL)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([, right, _, rightL]) => toChannel(that).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(right, rightL)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right, latchL, latchR]) => {\n    const pullLeft = Handoff.offer(latchL, void 0).pipe(Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(identity))));\n    const pullRight = Handoff.offer(latchR, void 0).pipe(Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(identity))));\n    return toChannel(unfoldEffect(s, s => Effect.flatMap(f(s, pullLeft, pullRight), unsome)));\n  }))));\n});\n/** @internal */\nexport const combineChunks = /*#__PURE__*/dual(4, (self, that, s, f) => {\n  const producer = (handoff, latch) => channel.zipRight(core.fromEffect(Handoff.take(latch)), core.readWithCause({\n    onInput: input => core.flatMap(core.fromEffect(pipe(handoff, Handoff.offer(InternalTake.chunk(input)))), () => producer(handoff, latch)),\n    onFailure: cause => core.fromEffect(Handoff.offer(handoff, InternalTake.failCause(cause))),\n    onDone: () => core.fromEffect(Handoff.offer(handoff, InternalTake.end))\n  }));\n  return new StreamImpl(channel.unwrapScopedWith(scope => Effect.all([Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()]).pipe(Effect.tap(([left, _, latchL]) => core.pipeTo(toChannel(self), producer(left, latchL)).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([_, right, __, latchR]) => core.pipeTo(toChannel(that), producer(right, latchR)).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right, latchL, latchR]) => {\n    const pullLeft = Handoff.offer(latchL, void 0).pipe(Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(InternalTake.done))));\n    const pullRight = Handoff.offer(latchR, void 0).pipe(Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(InternalTake.done))));\n    return toChannel(unfoldChunkEffect(s, s => Effect.flatMap(f(s, pullLeft, pullRight), unsome)));\n  }))));\n});\n/** @internal */\nexport const concat = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(pipe(toChannel(self), channel.zipRight(toChannel(that)))));\n/** @internal */\nexport const concatAll = streams => suspend(() => pipe(streams, Chunk.reduce(empty, (x, y) => concat(y)(x))));\n/** @internal */\nexport const cross = /*#__PURE__*/dual(2, (left, right) => pipe(left, crossWith(right, (a, a2) => [a, a2])));\n/** @internal */\nexport const crossLeft = /*#__PURE__*/dual(2, (left, right) => pipe(left, crossWith(right, (a, _) => a)));\n/** @internal */\nexport const crossRight = /*#__PURE__*/dual(2, (left, right) => flatMap(left, () => right));\n/** @internal */\nexport const crossWith = /*#__PURE__*/dual(3, (left, right, f) => pipe(left, flatMap(a => pipe(right, map(b => f(a, b))))));\n/** @internal */\nexport const debounce = /*#__PURE__*/dual(2, (self, duration) => unwrapScopedWith(scope => Effect.gen(function* () {\n  const handoff = yield* Handoff.make();\n  function enqueue(last) {\n    return Clock.sleep(duration).pipe(Effect.as(last), Effect.forkIn(scope), Effect.map(fiber => consumer(DebounceState.previous(fiber))));\n  }\n  const producer = core.readWithCause({\n    onInput: input => Option.match(Chunk.last(input), {\n      onNone: () => producer,\n      onSome: elem => core.fromEffect(Handoff.offer(handoff, HandoffSignal.emit(Chunk.of(elem)))).pipe(core.flatMap(() => producer))\n    }),\n    onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),\n    onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))\n  });\n  function consumer(state) {\n    switch (state._tag) {\n      case DebounceState.OP_NOT_STARTED:\n        {\n          return channel.unwrap(Handoff.take(handoff).pipe(Effect.map(signal => {\n            switch (signal._tag) {\n              case HandoffSignal.OP_EMIT:\n                {\n                  return channel.unwrap(enqueue(signal.elements));\n                }\n              case HandoffSignal.OP_HALT:\n                {\n                  return core.failCause(signal.cause);\n                }\n              case HandoffSignal.OP_END:\n                {\n                  return core.void;\n                }\n            }\n          })));\n        }\n      case DebounceState.OP_PREVIOUS:\n        {\n          return channel.unwrap(Handoff.take(handoff).pipe(Effect.forkIn(scope), Effect.flatMap(handoffFiber => Effect.raceWith(Fiber.join(state.fiber), Fiber.join(handoffFiber), {\n            onSelfDone: (leftExit, current) => Exit.match(leftExit, {\n              onFailure: cause => Fiber.interrupt(current).pipe(Effect.as(core.failCause(cause))),\n              onSuccess: chunk => Fiber.interrupt(current).pipe(Effect.zipRight(Effect.succeed(core.write(chunk).pipe(core.flatMap(() => consumer(DebounceState.current(handoffFiber)))))))\n            }),\n            onOtherDone: (rightExit, previous) => Exit.match(rightExit, {\n              onFailure: cause => Fiber.interrupt(previous).pipe(Effect.as(core.failCause(cause))),\n              onSuccess: signal => {\n                switch (signal._tag) {\n                  case HandoffSignal.OP_EMIT:\n                    {\n                      return Fiber.interrupt(previous).pipe(Effect.zipRight(enqueue(signal.elements)));\n                    }\n                  case HandoffSignal.OP_HALT:\n                    {\n                      return Fiber.interrupt(previous).pipe(Effect.as(core.failCause(signal.cause)));\n                    }\n                  case HandoffSignal.OP_END:\n                    {\n                      return Fiber.join(previous).pipe(Effect.map(chunk => core.write(chunk).pipe(channel.zipRight(core.void))));\n                    }\n                }\n              }\n            })\n          }))));\n        }\n      case DebounceState.OP_CURRENT:\n        {\n          return channel.unwrap(Fiber.join(state.fiber).pipe(Effect.map(signal => {\n            switch (signal._tag) {\n              case HandoffSignal.OP_EMIT:\n                {\n                  return channel.unwrap(enqueue(signal.elements));\n                }\n              case HandoffSignal.OP_HALT:\n                {\n                  return core.failCause(signal.cause);\n                }\n              case HandoffSignal.OP_END:\n                {\n                  return core.void;\n                }\n            }\n          })));\n        }\n    }\n  }\n  return scopedWith(scope => core.pipeTo(toChannel(self), producer).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))).pipe(crossRight(new StreamImpl(consumer(DebounceState.notStarted))));\n})));\n/** @internal */\nexport const die = defect => fromEffect(Effect.die(defect));\n/** @internal */\nexport const dieSync = evaluate => fromEffect(Effect.dieSync(evaluate));\n/** @internal */\nexport const dieMessage = message => fromEffect(Effect.dieMessage(message));\n/** @internal */\nexport const distributedWith = /*#__PURE__*/dual(2, (self, options) => pipe(Deferred.make(), Effect.flatMap(deferred => pipe(self, distributedWithDynamic({\n  maximumLag: options.maximumLag,\n  decide: a => Effect.flatMap(Deferred.await(deferred), f => f(a))\n}), Effect.flatMap(next => pipe(Effect.all(Chunk.map(Chunk.range(0, options.size - 1), id => Effect.map(next, ([key, queue]) => [[key, id], queue]))), Effect.map(Chunk.unsafeFromArray), Effect.flatMap(entries => {\n  const [mappings, queues] = Chunk.reduceRight(entries, [new Map(), Chunk.empty()], ([mappings, queues], [mapping, queue]) => [mappings.set(mapping[0], mapping[1]), pipe(queues, Chunk.prepend(queue))]);\n  return pipe(Deferred.succeed(deferred, a => Effect.map(options.decide(a), f => key => f(mappings.get(key)))), Effect.as(Array.from(queues)));\n})))))));\n/** @internal */\nconst distributedWithDynamicId = {\n  ref: 0\n};\nconst newDistributedWithDynamicId = () => {\n  const current = distributedWithDynamicId.ref;\n  distributedWithDynamicId.ref = current + 1;\n  return current;\n};\n/** @internal */\nexport const distributedWithDynamic = /*#__PURE__*/dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => Effect.void));\n/** @internal */\nexport const distributedWithDynamicCallback = /*#__PURE__*/dual(4, (self, maximumLag, decide, done) => pipe(Effect.acquireRelease(Ref.make(new Map()), (ref, _) => pipe(Ref.get(ref), Effect.flatMap(queues => pipe(queues.values(), Effect.forEach(Queue.shutdown))))), Effect.flatMap(queuesRef => Effect.gen(function* () {\n  const offer = a => pipe(decide(a), Effect.flatMap(shouldProcess => pipe(Ref.get(queuesRef), Effect.flatMap(queues => pipe(queues.entries(), Effect.reduce(Chunk.empty(), (acc, [id, queue]) => {\n    if (shouldProcess(id)) {\n      return pipe(Queue.offer(queue, Exit.succeed(a)), Effect.matchCauseEffect({\n        onFailure: cause =>\n        // Ignore all downstream queues that were shut\n        // down and remove them later\n        Cause.isInterrupted(cause) ? Effect.succeed(pipe(acc, Chunk.prepend(id))) : Effect.failCause(cause),\n        onSuccess: () => Effect.succeed(acc)\n      }));\n    }\n    return Effect.succeed(acc);\n  }), Effect.flatMap(ids => {\n    if (Chunk.isNonEmpty(ids)) {\n      return Ref.update(queuesRef, map => {\n        for (const id of ids) {\n          map.delete(id);\n        }\n        return map;\n      });\n    }\n    return Effect.void;\n  }))))), Effect.asVoid);\n  const queuesLock = yield* Effect.makeSemaphore(1);\n  const newQueue = yield* Ref.make(pipe(Queue.bounded(maximumLag), Effect.flatMap(queue => {\n    const id = newDistributedWithDynamicId();\n    return pipe(Ref.update(queuesRef, map => map.set(id, queue)), Effect.as([id, queue]));\n  })));\n  const finalize = endTake =>\n  // Make sure that no queues are currently being added\n  queuesLock.withPermits(1)(pipe(Ref.set(newQueue, pipe(\n  // All newly created queues should end immediately\n  Queue.bounded(1), Effect.tap(queue => Queue.offer(queue, endTake)), Effect.flatMap(queue => {\n    const id = newDistributedWithDynamicId();\n    return pipe(Ref.update(queuesRef, map => map.set(id, queue)), Effect.as(Tuple.make(id, queue)));\n  }))), Effect.zipRight(pipe(Ref.get(queuesRef), Effect.flatMap(map => pipe(Chunk.fromIterable(map.values()), Effect.forEach(queue => pipe(Queue.offer(queue, endTake), Effect.catchSomeCause(cause => Cause.isInterrupted(cause) ? Option.some(Effect.void) : Option.none()))))))), Effect.zipRight(done(endTake)), Effect.asVoid));\n  yield* pipe(self, runForEachScoped(offer), Effect.matchCauseEffect({\n    onFailure: cause => finalize(Exit.failCause(pipe(cause, Cause.map(Option.some)))),\n    onSuccess: () => finalize(Exit.fail(Option.none()))\n  }), Effect.forkScoped);\n  return queuesLock.withPermits(1)(Effect.flatten(Ref.get(newQueue)));\n}))));\n/** @internal */\nexport const drain = self => new StreamImpl(channel.drain(toChannel(self)));\n/** @internal */\nexport const drainFork = /*#__PURE__*/dual(2, (self, that) => fromEffect(Deferred.make()).pipe(flatMap(backgroundDied => scopedWith(scope => toChannel(that).pipe(channel.drain, channelExecutor.runIn(scope), Effect.catchAllCause(cause => Deferred.failCause(backgroundDied, cause)), Effect.forkIn(scope))).pipe(crossRight(interruptWhenDeferred(self, backgroundDied))))));\n/** @internal */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  const loop = r => core.readWith({\n    onInput: input => {\n      const dropped = pipe(input, Chunk.drop(r));\n      const leftover = Math.max(0, r - input.length);\n      const more = Chunk.isEmpty(input) || leftover > 0;\n      if (more) {\n        return loop(leftover);\n      }\n      return pipe(core.write(dropped), channel.zipRight(channel.identityChannel()));\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop(n))));\n});\n/** @internal */\nexport const dropRight = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return identityStream();\n  }\n  return suspend(() => {\n    const queue = new RingBuffer(n);\n    const reader = core.readWith({\n      onInput: input => {\n        const outputs = pipe(input, Chunk.filterMap(elem => {\n          const head = queue.head();\n          queue.put(elem);\n          return head;\n        }));\n        return pipe(core.write(outputs), core.flatMap(() => reader));\n      },\n      onFailure: core.fail,\n      onDone: () => core.void\n    });\n    return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(reader)));\n  });\n});\n/** @internal */\nexport const dropUntil = /*#__PURE__*/dual(2, (self, predicate) => drop(dropWhile(self, a => !predicate(a)), 1));\n/** @internal */\nexport const dropUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => pipe(Effect.dropUntil(input, predicate), Effect.map(Chunk.unsafeFromArray), Effect.map(leftover => {\n      const more = Chunk.isEmpty(leftover);\n      if (more) {\n        return core.suspend(() => loop);\n      }\n      return pipe(core.write(leftover), channel.zipRight(channel.identityChannel()));\n    }), channel.unwrap),\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)));\n});\n/** @internal */\nexport const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => {\n      const output = Chunk.dropWhile(input, predicate);\n      if (Chunk.isEmpty(output)) {\n        return core.suspend(() => loop);\n      }\n      return channel.zipRight(core.write(output), channel.identityChannel());\n    },\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  });\n  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));\n});\n/** @internal */\nexport const dropWhileEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => pipe(Effect.dropWhile(input, predicate), Effect.map(Chunk.unsafeFromArray), Effect.map(leftover => {\n      const more = Chunk.isEmpty(leftover);\n      if (more) {\n        return core.suspend(() => loop);\n      }\n      return channel.zipRight(core.write(leftover), channel.identityChannel());\n    }), channel.unwrap),\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));\n});\n/** @internal */\nexport const either = self => pipe(self, map(Either.right), catchAll(error => make(Either.left(error))));\n/** @internal */\nexport const empty = /*#__PURE__*/new StreamImpl(core.void);\n/** @internal */\nexport const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(pipe(toChannel(self), channel.ensuring(finalizer))));\n/** @internal */\nexport const ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(core.ensuringWith(toChannel(self), finalizer)));\n/** @internal */\nexport const context = () => fromEffect(Effect.context());\n/** @internal */\nexport const contextWith = f => pipe(context(), map(f));\n/** @internal */\nexport const contextWithEffect = f => pipe(context(), mapEffectSequential(f));\n/** @internal */\nexport const contextWithStream = f => pipe(context(), flatMap(f));\n/** @internal */\nexport const execute = effect => drain(fromEffect(effect));\n/** @internal */\nexport const fail = error => fromEffectOption(Effect.fail(Option.some(error)));\n/** @internal */\nexport const failSync = evaluate => fromEffectOption(Effect.failSync(() => Option.some(evaluate())));\n/** @internal */\nexport const failCause = cause => fromEffect(Effect.failCause(cause));\n/** @internal */\nexport const failCauseSync = evaluate => fromEffect(Effect.failCauseSync(evaluate));\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => mapChunks(self, Chunk.filter(predicate)));\n/** @internal */\nexport const filterEffect = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeed\n      });\n    } else {\n      return pipe(f(next.value), Effect.map(bool => bool ? pipe(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator))) : loop(iterator)), channel.unwrap);\n    }\n  };\n  return new StreamImpl(core.suspend(() => pipe(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]())))));\n});\n/** @internal */\nexport const filterMap = /*#__PURE__*/dual(2, (self, pf) => mapChunks(self, Chunk.filterMap(pf)));\n/** @internal */\nexport const filterMapEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeed\n      });\n    } else {\n      return pipe(pf(next.value), Option.match({\n        onNone: () => Effect.sync(() => loop(iterator)),\n        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))\n      }), channel.unwrap);\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))));\n}));\n/** @internal */\nexport const filterMapWhile = /*#__PURE__*/dual(2, (self, pf) => {\n  const loop = core.readWith({\n    onInput: input => {\n      const mapped = Chunk.filterMapWhile(input, pf);\n      if (mapped.length === input.length) {\n        return pipe(core.write(mapped), core.flatMap(() => loop));\n      }\n      return core.write(mapped);\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)));\n});\n/** @internal */\nexport const filterMapWhileEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: input => loop(input[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeed\n      });\n    } else {\n      return channel.unwrap(Option.match(pf(next.value), {\n        onNone: () => Effect.succeed(core.void),\n        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))\n      }));\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop(Chunk.empty()[Symbol.iterator]()))));\n}));\n/** @internal */\nexport const finalizer = finalizer => acquireRelease(Effect.void, () => finalizer);\n/** @internal */\nexport const find = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => Option.match(Chunk.findFirst(input, predicate), {\n      onNone: () => loop,\n      onSome: n => core.write(Chunk.of(n))\n    }),\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)));\n});\n/** @internal */\nexport const findEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => pipe(Effect.findFirst(input, predicate), Effect.map(Option.match({\n      onNone: () => loop,\n      onSome: n => core.write(Chunk.of(n))\n    })), channel.unwrap),\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)));\n});\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(args => isStream(args[0]), (self, f, options) => {\n  const bufferSize = options?.bufferSize ?? 16;\n  if (options?.switch) {\n    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), n => flatMapParSwitchBuffer(self, n, bufferSize, f));\n  }\n  return matchConcurrency(options?.concurrency, () => new StreamImpl(channel.concatMap(toChannel(self), as => pipe(as, Chunk.map(a => toChannel(f(a))), Chunk.reduce(core.void, (left, right) => pipe(left, channel.zipRight(right)))))), _ => new StreamImpl(pipe(toChannel(self), channel.concatMap(channel.writeChunk), channel.mergeMap(out => toChannel(f(out)), options))));\n});\n/** @internal */\nexport const matchConcurrency = (concurrency, sequential, bounded) => {\n  switch (concurrency) {\n    case undefined:\n      return sequential();\n    case \"unbounded\":\n      return bounded(Number.MAX_SAFE_INTEGER);\n    default:\n      return concurrency > 1 ? bounded(concurrency) : sequential();\n  }\n};\nconst flatMapParSwitchBuffer = /*#__PURE__*/dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel(self), channel.concatMap(channel.writeChunk), channel.mergeMap(out => toChannel(f(out)), {\n  concurrency: n,\n  mergeStrategy: MergeStrategy.BufferSliding(),\n  bufferSize\n}))));\n/** @internal */\nexport const flatten = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => flatMap(self, identity, options));\n/** @internal */\nexport const flattenChunks = self => {\n  const flatten = core.readWithCause({\n    onInput: chunks => core.flatMap(channel.writeChunk(chunks), () => flatten),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(flatten)));\n};\n/** @internal */\nexport const flattenEffect = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => options?.unordered ? flatMap(self, a => fromEffect(a), {\n  concurrency: options.concurrency\n}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), n => new StreamImpl(pipe(toChannel(self), channel.concatMap(channel.writeChunk), channel.mapOutEffectPar(identity, n), channel.mapOut(Chunk.of)))));\n/** @internal */\nexport const flattenExitOption = self => {\n  const processChunk = (chunk, cont) => {\n    const [toEmit, rest] = pipe(chunk, Chunk.splitWhere(exit => !Exit.isSuccess(exit)));\n    const next = pipe(Chunk.head(rest), Option.match({\n      onNone: () => cont,\n      onSome: Exit.match({\n        onFailure: cause => Option.match(Cause.flipCauseOption(cause), {\n          onNone: () => core.void,\n          onSome: core.failCause\n        }),\n        onSuccess: () => core.void\n      })\n    }));\n    return pipe(core.write(pipe(toEmit, Chunk.filterMap(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none()))), core.flatMap(() => next));\n  };\n  const process = core.readWithCause({\n    onInput: chunk => processChunk(chunk, process),\n    onFailure: cause => core.failCause(cause),\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(process)));\n};\n/** @internal */\nexport const flattenIterables = self => pipe(self, map(Chunk.fromIterable), flattenChunks);\n/** @internal */\nexport const flattenTake = self => flattenChunks(flattenExitOption(pipe(self, map(take => take.exit))));\n/** @internal */\nexport const forever = self => new StreamImpl(channel.repeated(toChannel(self)));\n/** @internal */\nexport const fromAsyncIterable = (iterable, onError) => pipe(Effect.acquireRelease(Effect.sync(() => iterable[Symbol.asyncIterator]()), iterator => iterator.return ? Effect.promise(async () => iterator.return()) : Effect.void), Effect.map(iterator => repeatEffectOption(pipe(Effect.tryPromise({\n  try: async () => iterator.next(),\n  catch: reason => Option.some(onError(reason))\n}), Effect.flatMap(result => result.done ? Effect.fail(Option.none()) : Effect.succeed(result.value))))), unwrapScoped);\n/** @internal */\nexport const fromChannel = channel => new StreamImpl(channel);\n/** @internal */\nexport const toChannel = stream => {\n  if (\"channel\" in stream) {\n    return stream.channel;\n  } else if (Effect.isEffect(stream)) {\n    return toChannel(fromEffect(stream));\n  } else {\n    throw new TypeError(`Expected a Stream.`);\n  }\n};\n/** @internal */\nexport const fromChunk = chunk => new StreamImpl(Chunk.isEmpty(chunk) ? core.void : core.write(chunk));\n/** @internal */\nexport const fromChunkPubSub = (pubsub, options) => {\n  if (options?.scoped) {\n    const effect = Effect.map(PubSub.subscribe(pubsub), fromChunkQueue);\n    return options.shutdown ? Effect.map(effect, ensuring(PubSub.shutdown(pubsub))) : effect;\n  }\n  const stream = flatMap(scoped(PubSub.subscribe(pubsub)), fromChunkQueue);\n  return options?.shutdown ? ensuring(stream, PubSub.shutdown(pubsub)) : stream;\n};\n/** @internal */\nexport const fromChunkQueue = (queue, options) => pipe(Queue.take(queue), Effect.catchAllCause(cause => pipe(Queue.isShutdown(queue), Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause)))), repeatEffectChunkOption, options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity);\n/** @internal */\nexport const fromChunks = (...chunks) => pipe(fromIterable(chunks), flatMap(fromChunk));\n/** @internal */\nexport const fromEffect = effect => pipe(effect, Effect.mapError(Option.some), fromEffectOption);\n/** @internal */\nexport const fromEffectOption = effect => new StreamImpl(channel.unwrap(Effect.match(effect, {\n  onFailure: Option.match({\n    onNone: () => core.void,\n    onSome: core.fail\n  }),\n  onSuccess: a => core.write(Chunk.of(a))\n})));\n/** @internal */\nexport const fromPubSub = (pubsub, options) => {\n  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;\n  if (options?.scoped) {\n    const effect = Effect.map(PubSub.subscribe(pubsub), queue => fromQueue(queue, {\n      maxChunkSize,\n      shutdown: true\n    }));\n    return options.shutdown ? Effect.map(effect, ensuring(PubSub.shutdown(pubsub))) : effect;\n  }\n  const stream = flatMap(scoped(PubSub.subscribe(pubsub)), queue => fromQueue(queue, {\n    maxChunkSize\n  }));\n  return options?.shutdown ? ensuring(stream, PubSub.shutdown(pubsub)) : stream;\n};\n/** @internal */\nexport const fromTPubSub = pubsub => {\n  return unwrapScoped(Effect.map(TPubSub.subscribeScoped(pubsub), queue => fromTQueue(queue)));\n};\n/** @internal */\nexport const fromIterable = iterable => suspend(() => Chunk.isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));\n/** @internal */\nexport const fromIterableEffect = effect => pipe(effect, Effect.map(fromIterable), unwrap);\n/** @internal */\nexport const fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {\n  return pipe(Effect.sync(() => {\n    let builder = [];\n    const loop = iterator => pipe(Effect.sync(() => {\n      let next = iterator.next();\n      if (maxChunkSize === 1) {\n        if (next.done) {\n          return core.void;\n        }\n        return pipe(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator)));\n      }\n      builder = [];\n      let count = 0;\n      while (next.done === false) {\n        builder.push(next.value);\n        count = count + 1;\n        if (count >= maxChunkSize) {\n          break;\n        }\n        next = iterator.next();\n      }\n      if (count > 0) {\n        return pipe(core.write(Chunk.unsafeFromArray(builder)), core.flatMap(() => loop(iterator)));\n      }\n      return core.void;\n    }), channel.unwrap);\n    return new StreamImpl(loop(iterator));\n  }), unwrap);\n};\n/** @internal */\nexport const fromPull = effect => pipe(effect, Effect.map(repeatEffectChunkOption), unwrapScoped);\n/** @internal */\nexport const fromQueue = (queue, options) => pipe(Queue.takeBetween(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), Effect.catchAllCause(cause => pipe(Queue.isShutdown(queue), Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause)))), repeatEffectChunkOption, options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity);\n/** @internal */\nexport const fromTQueue = queue => pipe(TQueue.take(queue), Effect.map(Chunk.of), Effect.catchAllCause(cause => pipe(TQueue.isShutdown(queue), Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause)))), repeatEffectChunkOption);\n/** @internal */\nexport const fromSchedule = schedule => pipe(Schedule.driver(schedule), Effect.map(driver => repeatEffectOption(driver.next(void 0))), unwrap);\n/** @internal */\nexport const fromReadableStream = (...args) => {\n  const evaluate = args.length === 1 ? args[0].evaluate : args[0];\n  const onError = args.length === 1 ? args[0].onError : args[1];\n  const releaseLockOnEnd = args.length === 1 ? args[0].releaseLockOnEnd === true : false;\n  return unwrapScoped(Effect.map(Effect.acquireRelease(Effect.sync(() => evaluate().getReader()), reader => releaseLockOnEnd ? Effect.sync(() => reader.releaseLock()) : Effect.promise(() => reader.cancel())), reader => repeatEffectOption(Effect.flatMap(Effect.tryPromise({\n    try: () => reader.read(),\n    catch: reason => Option.some(onError(reason))\n  }), ({\n    done,\n    value\n  }) => done ? Effect.fail(Option.none()) : Effect.succeed(value)))));\n};\n/** @internal */\nexport const fromReadableStreamByob = (...args) => {\n  const evaluate = args.length === 1 ? args[0].evaluate : args[0];\n  const onError = args.length === 1 ? args[0].onError : args[1];\n  const allocSize = (args.length === 1 ? args[0].bufferSize : args[2]) ?? 4096;\n  const releaseLockOnEnd = args.length === 1 ? args[0].releaseLockOnEnd === true : false;\n  return unwrapScoped(Effect.map(Effect.acquireRelease(Effect.sync(() => evaluate().getReader({\n    mode: \"byob\"\n  })), reader => releaseLockOnEnd ? Effect.sync(() => reader.releaseLock()) : Effect.promise(() => reader.cancel())), reader => catchAll(forever(readChunkStreamByobReader(reader, onError, allocSize)), error => error === EOF ? empty : fail(error))));\n};\nconst EOF = /*#__PURE__*/Symbol.for(\"effect/Stream/EOF\");\nconst readChunkStreamByobReader = (reader, onError, size) => {\n  const buffer = new ArrayBuffer(size);\n  return paginateEffect(0, offset => Effect.flatMap(Effect.tryPromise({\n    try: () => reader.read(new Uint8Array(buffer, offset, buffer.byteLength - offset)),\n    catch: reason => onError(reason)\n  }), ({\n    done,\n    value\n  }) => {\n    if (done) {\n      return Effect.fail(EOF);\n    }\n    const newOffset = offset + value.byteLength;\n    return Effect.succeed([value, newOffset >= buffer.byteLength ? Option.none() : Option.some(newOffset)]);\n  }));\n};\n/** @internal */\nexport const groupAdjacentBy = /*#__PURE__*/dual(2, (self, f) => {\n  const groupAdjacentByChunk = (state, chunk) => {\n    if (Chunk.isEmpty(chunk)) {\n      return [state, Chunk.empty()];\n    }\n    const builder = [];\n    let from = 0;\n    let until = 0;\n    let key = undefined;\n    let previousChunk = Chunk.empty();\n    switch (state._tag) {\n      case \"Some\":\n        {\n          const tuple = state.value;\n          key = tuple[0];\n          let loop = true;\n          while (loop && until < chunk.length) {\n            const input = Chunk.unsafeGet(chunk, until);\n            const updatedKey = f(input);\n            if (!Equal.equals(key, updatedKey)) {\n              const previousChunk = tuple[1];\n              const additionalChunk = Chunk.unsafeFromArray(Array.from(chunk).slice(from, until));\n              const group = Chunk.appendAll(previousChunk, additionalChunk);\n              builder.push([key, group]);\n              key = updatedKey;\n              from = until;\n              loop = false;\n            }\n            until = until + 1;\n          }\n          if (loop) {\n            previousChunk = tuple[1];\n          }\n          break;\n        }\n      case \"None\":\n        {\n          key = f(Chunk.unsafeGet(chunk, until));\n          until = until + 1;\n          break;\n        }\n    }\n    while (until < chunk.length) {\n      const input = Chunk.unsafeGet(chunk, until);\n      const updatedKey = f(input);\n      if (!Equal.equals(key, updatedKey)) {\n        builder.push([key, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until))]);\n        key = updatedKey;\n        from = until;\n      }\n      until = until + 1;\n    }\n    const nonEmptyChunk = Chunk.appendAll(previousChunk, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until)));\n    const output = Chunk.unsafeFromArray(builder);\n    return [Option.some([key, nonEmptyChunk]), output];\n  };\n  const groupAdjacent = state => core.readWithCause({\n    onInput: input => {\n      const [updatedState, output] = groupAdjacentByChunk(state, input);\n      return Chunk.isEmpty(output) ? groupAdjacent(updatedState) : core.flatMap(core.write(output), () => groupAdjacent(updatedState));\n    },\n    onFailure: cause => Option.match(state, {\n      onNone: () => core.failCause(cause),\n      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.failCause(cause))\n    }),\n    onDone: done => Option.match(state, {\n      onNone: () => core.succeedNow(done),\n      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.succeedNow(done))\n    })\n  });\n  return new StreamImpl(channel.pipeToOrFail(toChannel(self), groupAdjacent(Option.none())));\n});\n/** @internal */\nexport const grouped = /*#__PURE__*/dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));\n/** @internal */\nexport const groupedWithin = /*#__PURE__*/dual(3, (self, chunkSize, duration) => aggregateWithin(self, sink_.collectAllN(chunkSize), Schedule.spaced(duration)));\n/** @internal */\nexport const haltWhen = /*#__PURE__*/dual(2, (self, effect) => {\n  const writer = fiber => pipe(Fiber.poll(fiber), Effect.map(Option.match({\n    onNone: () => core.readWith({\n      onInput: input => core.flatMap(core.write(input), () => writer(fiber)),\n      onFailure: core.fail,\n      onDone: () => core.void\n    }),\n    onSome: Exit.match({\n      onFailure: core.failCause,\n      onSuccess: () => core.void\n    })\n  })), channel.unwrap);\n  return new StreamImpl(channel.unwrapScopedWith(scope => effect.pipe(Effect.forkIn(scope), Effect.map(fiber => toChannel(self).pipe(core.pipeTo(writer(fiber)))))));\n});\n/** @internal */\nexport const haltAfter = /*#__PURE__*/dual(2, (self, duration) => pipe(self, haltWhen(Clock.sleep(duration))));\n/** @internal */\nexport const haltWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => {\n  const writer = pipe(Deferred.poll(deferred), Effect.map(Option.match({\n    onNone: () => core.readWith({\n      onInput: input => pipe(core.write(input), core.flatMap(() => writer)),\n      onFailure: core.fail,\n      onDone: () => core.void\n    }),\n    onSome: effect => channel.unwrap(Effect.match(effect, {\n      onFailure: core.fail,\n      onSuccess: () => core.void\n    }))\n  })), channel.unwrap);\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer)));\n});\n/** @internal */\nexport const identityStream = () => new StreamImpl(channel.identityChannel());\n/** @internal */\nexport const interleave = /*#__PURE__*/dual(2, (self, that) => pipe(self, interleaveWith(that, forever(make(true, false)))));\n/** @internal */\nexport const interleaveWith = /*#__PURE__*/dual(3, (self, that, decider) => {\n  const producer = handoff => core.readWithCause({\n    onInput: value => core.flatMap(core.fromEffect(Handoff.offer(handoff, InternalTake.of(value))), () => producer(handoff)),\n    onFailure: cause => core.fromEffect(Handoff.offer(handoff, InternalTake.failCause(cause))),\n    onDone: () => core.fromEffect(Handoff.offer(handoff, InternalTake.end))\n  });\n  return new StreamImpl(channel.unwrapScopedWith(scope => pipe(Handoff.make(), Effect.zip(Handoff.make()), Effect.tap(([left]) => toChannel(self).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(left)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([_, right]) => toChannel(that).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(right)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right]) => {\n    const process = (leftDone, rightDone) => core.readWithCause({\n      onInput: bool => {\n        if (bool && !leftDone) {\n          return pipe(core.fromEffect(Handoff.take(left)), core.flatMap(InternalTake.match({\n            onEnd: () => rightDone ? core.void : process(true, rightDone),\n            onFailure: core.failCause,\n            onSuccess: chunk => pipe(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))\n          })));\n        }\n        if (!bool && !rightDone) {\n          return pipe(core.fromEffect(Handoff.take(right)), core.flatMap(InternalTake.match({\n            onEnd: () => leftDone ? core.void : process(leftDone, true),\n            onFailure: core.failCause,\n            onSuccess: chunk => pipe(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))\n          })));\n        }\n        return process(leftDone, rightDone);\n      },\n      onFailure: core.failCause,\n      onDone: () => core.void\n    });\n    return pipe(toChannel(decider), channel.concatMap(channel.writeChunk), core.pipeTo(process(false, false)));\n  }))));\n});\n/** @internal */\nexport const intersperse = /*#__PURE__*/dual(2, (self, element) => new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(core.suspend(() => {\n  const writer = isFirst => core.readWithCause({\n    onInput: chunk => {\n      const builder = [];\n      let flagResult = isFirst;\n      for (const output of chunk) {\n        if (flagResult) {\n          flagResult = false;\n          builder.push(output);\n        } else {\n          builder.push(element);\n          builder.push(output);\n        }\n      }\n      return pipe(core.write(Chunk.unsafeFromArray(builder)), core.flatMap(() => writer(flagResult)));\n    },\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  return writer(true);\n})))));\n/** @internal */\nexport const intersperseAffixes = /*#__PURE__*/dual(2, (self, {\n  end,\n  middle,\n  start\n}) => pipe(make(start), concat(pipe(self, intersperse(middle))), concat(make(end))));\n/** @internal */\nexport const interruptAfter = /*#__PURE__*/dual(2, (self, duration) => pipe(self, interruptWhen(Clock.sleep(duration))));\n/** @internal */\nexport const interruptWhen = /*#__PURE__*/dual(2, (self, effect) => new StreamImpl(pipe(toChannel(self), channel.interruptWhen(effect))));\n/** @internal */\nexport const interruptWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => new StreamImpl(pipe(toChannel(self), channel.interruptWhenDeferred(deferred))));\n/** @internal */\nexport const iterate = (value, next) => unfold(value, a => Option.some([a, next(a)]));\n/** @internal */\nexport const make = (...as) => fromIterable(as);\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.mapOut(Chunk.map(f)))));\n/** @internal */\nexport const mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  const accumulator = s => core.readWith({\n    onInput: input => {\n      const [nextS, chunk] = Chunk.mapAccum(input, s, f);\n      return core.flatMap(core.write(chunk), () => accumulator(nextS));\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(accumulator(s))));\n});\n/** @internal */\nexport const mapAccumEffect = /*#__PURE__*/dual(3, (self, s, f) => suspend(() => {\n  const accumulator = s => core.readWith({\n    onInput: input => pipe(Effect.suspend(() => {\n      const outputs = [];\n      const emit = output => Effect.sync(() => {\n        outputs.push(output);\n      });\n      return pipe(input, Effect.reduce(s, (s, a) => pipe(f(s, a), Effect.flatMap(([s, a]) => pipe(emit(a), Effect.as(s))))), Effect.match({\n        onFailure: error => {\n          if (outputs.length !== 0) {\n            return channel.zipRight(core.write(Chunk.unsafeFromArray(outputs)), core.fail(error));\n          }\n          return core.fail(error);\n        },\n        onSuccess: s => core.flatMap(core.write(Chunk.unsafeFromArray(outputs)), () => accumulator(s))\n      }));\n    }), channel.unwrap),\n    onFailure: core.fail,\n    onDone: () => core.void\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(accumulator(s))));\n}));\n/** @internal */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, options) => pipe(self, mapError(options.onFailure), map(options.onSuccess)));\n/** @internal */\nexport const mapChunks = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.mapOut(f))));\n/** @internal */\nexport const mapChunksEffect = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.mapOutEffect(f))));\n/** @internal */\nexport const mapConcat = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapConcatChunk(a => Chunk.fromIterable(f(a)))));\n/** @internal */\nexport const mapConcatChunk = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapChunks(Chunk.flatMap(f))));\n/** @internal */\nexport const mapConcatChunkEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));\n/** @internal */\nexport const mapConcatEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapEffectSequential(a => pipe(f(a), Effect.map(Chunk.fromIterable))), mapConcatChunk(identity)));\n/** @internal */\nexport const mapEffectSequential = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: elem => loop(elem[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeed\n      });\n    } else {\n      const value = next.value;\n      return channel.unwrap(Effect.map(f(value), a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))));\n    }\n  };\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(core.suspend(() => loop(Chunk.empty()[Symbol.iterator]())))));\n});\n/** @internal */\nexport const mapEffectPar = /*#__PURE__*/dual(3, (self, n, f) => new StreamImpl(pipe(toChannel(self), channel.concatMap(channel.writeChunk), channel.mapOutEffectPar(f, n), channel.mapOut(Chunk.of))));\n/** @internal */\nexport const mapError = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.mapError(f))));\n/** @internal */\nexport const mapErrorCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.mapErrorCause(f))));\n/** @internal */\nexport const merge = /*#__PURE__*/dual(args => isStream(args[1]), (self, that, options) => mergeWith(self, that, {\n  onSelf: identity,\n  onOther: identity,\n  haltStrategy: options?.haltStrategy\n}));\n/** @internal */\nexport const mergeAll = /*#__PURE__*/dual(args => Symbol.iterator in args[0], (streams, options) => flatten(fromIterable(streams), options));\n/** @internal */\nexport const mergeWithTag = /*#__PURE__*/dual(2, (streams, options) => {\n  const keys = Object.keys(streams);\n  const values = keys.map(key => streams[key].pipe(map(value => ({\n    _tag: key,\n    value\n  }))));\n  return mergeAll(values, options);\n});\n/** @internal */\nexport const mergeEither = /*#__PURE__*/dual(2, (self, that) => mergeWith(self, that, {\n  onSelf: Either.left,\n  onOther: Either.right\n}));\n/** @internal */\nexport const mergeLeft = /*#__PURE__*/dual(2, (left, right) => pipe(left, merge(drain(right))));\n/** @internal */\nexport const mergeRight = /*#__PURE__*/dual(2, (left, right) => pipe(drain(left), merge(right)));\n/** @internal */\nexport const mergeWith = /*#__PURE__*/dual(3, (self, other, options) => {\n  const strategy = options.haltStrategy ? haltStrategy.fromInput(options.haltStrategy) : HaltStrategy.Both;\n  const handler = terminate => exit => terminate || !Exit.isSuccess(exit) ?\n  // TODO: remove\n  MergeDecision.Done(Effect.suspend(() => exit)) : MergeDecision.Await(exit => Effect.suspend(() => exit));\n  return new StreamImpl(channel.mergeWith(toChannel(map(self, options.onSelf)), {\n    other: toChannel(map(other, options.onOther)),\n    onSelfDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Left\"),\n    onOtherDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Right\")\n  }));\n});\n/** @internal */\nexport const mkString = self => run(self, sink_.mkString);\n/** @internal */\nexport const never = /*#__PURE__*/fromEffect(Effect.never);\n/** @internal */\nexport const onEnd = /*#__PURE__*/dual(2, (self, effect) => concat(self, drain(fromEffect(effect))));\n/** @internal */\nexport const onError = /*#__PURE__*/dual(2, (self, cleanup) => pipe(self, catchAllCause(cause => fromEffect(pipe(cleanup(cause), Effect.zipRight(Effect.failCause(cause)))))));\n/** @internal */\nexport const onDone = /*#__PURE__*/dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel(self), core.ensuringWith(exit => Exit.isSuccess(exit) ? cleanup() : Effect.void))));\n/** @internal */\nexport const onStart = /*#__PURE__*/dual(2, (self, effect) => unwrap(Effect.as(effect, self)));\n/** @internal */\nexport const orDie = self => pipe(self, orDieWith(identity));\n/** @internal */\nexport const orDieWith = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(pipe(toChannel(self), channel.orDieWith(f))));\n/** @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(pipe(toChannel(self), channel.orElse(() => toChannel(that())))));\n/** @internal */\nexport const orElseEither = /*#__PURE__*/dual(2, (self, that) => pipe(self, map(Either.left), orElse(() => pipe(that(), map(Either.right)))));\n/** @internal */\nexport const orElseFail = /*#__PURE__*/dual(2, (self, error) => pipe(self, orElse(() => failSync(error))));\n/** @internal */\nexport const orElseIfEmpty = /*#__PURE__*/dual(2, (self, element) => pipe(self, orElseIfEmptyChunk(() => Chunk.of(element()))));\n/** @internal */\nexport const orElseIfEmptyChunk = /*#__PURE__*/dual(2, (self, chunk) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(core.write(chunk())))));\n/** @internal */\nexport const orElseIfEmptyStream = /*#__PURE__*/dual(2, (self, stream) => {\n  const writer = core.readWith({\n    onInput: input => {\n      if (Chunk.isEmpty(input)) {\n        return core.suspend(() => writer);\n      }\n      return pipe(core.write(input), channel.zipRight(channel.identityChannel()));\n    },\n    onFailure: core.fail,\n    onDone: () => core.suspend(() => toChannel(stream()))\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer)));\n});\n/** @internal */\nexport const orElseSucceed = /*#__PURE__*/dual(2, (self, value) => pipe(self, orElse(() => sync(value))));\n/** @internal */\nexport const paginate = (s, f) => paginateChunk(s, s => {\n  const page = f(s);\n  return [Chunk.of(page[0]), page[1]];\n});\n/** @internal */\nexport const paginateChunk = (s, f) => {\n  const loop = s => {\n    const page = f(s);\n    return Option.match(page[1], {\n      onNone: () => channel.zipRight(core.write(page[0]), core.void),\n      onSome: s => core.flatMap(core.write(page[0]), () => loop(s))\n    });\n  };\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexport const paginateChunkEffect = (s, f) => {\n  const loop = s => channel.unwrap(Effect.map(f(s), ([chunk, option]) => Option.match(option, {\n    onNone: () => channel.zipRight(core.write(chunk), core.void),\n    onSome: s => core.flatMap(core.write(chunk), () => loop(s))\n  })));\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexport const paginateEffect = (s, f) => paginateChunkEffect(s, s => pipe(f(s), Effect.map(([a, s]) => [Chunk.of(a), s])));\n/** @internal */\nexport const peel = /*#__PURE__*/dual(2, (self, sink) => {\n  const OP_EMIT = \"Emit\";\n  const OP_HALT = \"Halt\";\n  const OP_END = \"End\";\n  return pipe(Deferred.make(), Effect.flatMap(deferred => pipe(Handoff.make(), Effect.map(handoff => {\n    const consumer = sink_.foldSink(sink_.collectLeftover(sink), {\n      onFailure: error => sink_.zipRight(sink_.fromEffect(Deferred.fail(deferred, error)), sink_.fail(error)),\n      onSuccess: ([z, leftovers]) => {\n        const loop = core.readWithCause({\n          onInput: elements => core.flatMap(core.fromEffect(Handoff.offer(handoff, {\n            _tag: OP_EMIT,\n            elements\n          })), () => loop),\n          onFailure: cause => channel.zipRight(core.fromEffect(Handoff.offer(handoff, {\n            _tag: OP_HALT,\n            cause\n          })), core.failCause(cause)),\n          onDone: _ => channel.zipRight(core.fromEffect(Handoff.offer(handoff, {\n            _tag: OP_END\n          })), core.void)\n        });\n        return sink_.fromChannel(pipe(core.fromEffect(Deferred.succeed(deferred, z)), channel.zipRight(core.fromEffect(pipe(handoff, Handoff.offer({\n          _tag: OP_EMIT,\n          elements: leftovers\n        })))), channel.zipRight(loop)));\n      }\n    });\n    const producer = pipe(Handoff.take(handoff), Effect.map(signal => {\n      switch (signal._tag) {\n        case OP_EMIT:\n          {\n            return pipe(core.write(signal.elements), core.flatMap(() => producer));\n          }\n        case OP_HALT:\n          {\n            return core.failCause(signal.cause);\n          }\n        case OP_END:\n          {\n            return core.void;\n          }\n      }\n    }), channel.unwrap);\n    return pipe(self, tapErrorCause(cause => Deferred.failCause(deferred, cause)), run(consumer), Effect.forkScoped, Effect.zipRight(Deferred.await(deferred)), Effect.map(z => [z, new StreamImpl(producer)]));\n  }))), Effect.flatten);\n});\n/** @internal */\nexport const partition = /*#__PURE__*/dual(args => typeof args[1] === \"function\", (self, predicate, options) => partitionEither(self, a => Effect.succeed(predicate(a) ? Either.right(a) : Either.left(a)), options));\n/** @internal */\nexport const partitionEither = /*#__PURE__*/dual(args => typeof args[1] === \"function\", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({\n  size: 2,\n  maximumLag: options?.bufferSize ?? 16,\n  decide: Either.match({\n    onLeft: () => Effect.succeed(n => n === 0),\n    onRight: () => Effect.succeed(n => n === 1)\n  })\n}), Effect.flatMap(([queue1, queue2]) => Effect.succeed([filterMap(flattenExitOption(fromQueue(queue1, {\n  shutdown: true\n})), _ => Either.match(_, {\n  onLeft: Option.some,\n  onRight: Option.none\n})), filterMap(flattenExitOption(fromQueue(queue2, {\n  shutdown: true\n})), _ => Either.match(_, {\n  onLeft: Option.none,\n  onRight: Option.some\n}))]))));\n/** @internal */\nexport const pipeThrough = /*#__PURE__*/dual(2, (self, sink) => new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(sink_.toChannel(sink)))));\n/** @internal */\nexport const pipeThroughChannel = /*#__PURE__*/dual(2, (self, channel) => new StreamImpl(core.pipeTo(toChannel(self), channel)));\n/** @internal */\nexport const pipeThroughChannelOrFail = /*#__PURE__*/dual(2, (self, chan) => new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(chan))));\n/** @internal */\nexport const prepend = /*#__PURE__*/dual(2, (self, values) => new StreamImpl(channel.zipRight(core.write(values), toChannel(self))));\n/** @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, context) => new StreamImpl(pipe(toChannel(self), core.provideContext(context))));\n/** @internal */\nexport const provideSomeContext = /*#__PURE__*/dual(2, (self, context) => mapInputContext(self, Context.merge(context)));\n/** @internal */\nexport const provideLayer = /*#__PURE__*/dual(2, (self, layer) => new StreamImpl(channel.unwrapScopedWith(scope => Layer.buildWithScope(layer, scope).pipe(Effect.map(env => pipe(toChannel(self), core.provideContext(env)))))));\n/** @internal */\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, resource) => provideServiceEffect(self, tag, Effect.succeed(resource)));\n/** @internal */\nexport const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));\n/** @internal */\nexport const provideServiceStream = /*#__PURE__*/dual(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => pipe(self, provideContext(Context.add(env, tag, service))))));\n/** @internal */\nexport const mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithStream(env => pipe(self, provideContext(f(env)))));\n/** @internal */\nexport const provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) =>\n// @ts-expect-error\n// @effect-diagnostics-next-line missingEffectContext:off\npipe(self, provideLayer(pipe(Layer.context(), Layer.merge(layer)))));\n/** @internal */\nexport const range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {\n  if (min > max) {\n    return empty;\n  }\n  const go = (min, max, chunkSize) => {\n    const remaining = max - min + 1;\n    if (remaining > chunkSize) {\n      return pipe(core.write(Chunk.range(min, min + chunkSize - 1)), core.flatMap(() => go(min + chunkSize, max, chunkSize)));\n    }\n    return core.write(Chunk.range(min, min + remaining - 1));\n  };\n  return new StreamImpl(go(min, max, chunkSize));\n});\n/** @internal */\nexport const race = /*#__PURE__*/dual(2, (left, right) => raceAll(left, right));\n/** @internal */\nexport const raceAll = (...streams) => Deferred.make().pipe(Effect.map(halt => {\n  let winner = null;\n  return mergeAll(streams.map((stream, index) => stream.pipe(takeWhile(() => {\n    if (winner === null) {\n      winner = index;\n      Deferred.unsafeDone(halt, Exit.void);\n      return true;\n    }\n    return winner === index;\n  }), interruptWhen(Deferred.await(halt).pipe(Effect.flatMap(() => winner === index ? Effect.never : Effect.void))))), {\n    concurrency: streams.length\n  });\n}), unwrap);\n/** @internal */\nexport const rechunk = /*#__PURE__*/dual(2, (self, n) => suspend(() => {\n  const target = Math.max(n, 1);\n  const process = rechunkProcess(new StreamRechunker(target), target);\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(process)));\n}));\n/** @internal */\nconst rechunkProcess = (rechunker, target) => core.readWithCause({\n  onInput: chunk => {\n    if (chunk.length === target && rechunker.isEmpty()) {\n      return core.flatMap(core.write(chunk), () => rechunkProcess(rechunker, target));\n    }\n    if (chunk.length > 0) {\n      const chunks = [];\n      let result = undefined;\n      let index = 0;\n      while (index < chunk.length) {\n        while (index < chunk.length && result === undefined) {\n          result = rechunker.write(pipe(chunk, Chunk.unsafeGet(index)));\n          index = index + 1;\n        }\n        if (result !== undefined) {\n          chunks.push(result);\n          result = undefined;\n        }\n      }\n      return core.flatMap(channel.writeAll(...chunks), () => rechunkProcess(rechunker, target));\n    }\n    return core.suspend(() => rechunkProcess(rechunker, target));\n  },\n  onFailure: cause => channel.zipRight(rechunker.emitIfNotEmpty(), core.failCause(cause)),\n  onDone: () => rechunker.emitIfNotEmpty()\n});\nclass StreamRechunker {\n  n;\n  builder = [];\n  pos = 0;\n  constructor(n) {\n    this.n = n;\n  }\n  isEmpty() {\n    return this.pos === 0;\n  }\n  write(elem) {\n    this.builder.push(elem);\n    this.pos += 1;\n    if (this.pos === this.n) {\n      const result = Chunk.unsafeFromArray(this.builder);\n      this.builder = [];\n      this.pos = 0;\n      return result;\n    }\n    return undefined;\n  }\n  emitIfNotEmpty() {\n    if (this.pos !== 0) {\n      return core.write(Chunk.unsafeFromArray(this.builder));\n    }\n    return core.void;\n  }\n}\n/** @internal */\nexport const refineOrDie = /*#__PURE__*/dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));\n/** @internal */\nexport const refineOrDieWith = /*#__PURE__*/dual(3, (self, pf, f) => new StreamImpl(channel.catchAll(toChannel(self), error => Option.match(pf(error), {\n  onNone: () => core.failCause(Cause.die(f(error))),\n  onSome: core.fail\n}))));\n/** @internal */\nexport const repeat = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatEither(self, schedule), _ => Either.match(_, {\n  onLeft: Option.none,\n  onRight: Option.some\n})));\n/** @internal */\nexport const repeatEffect = effect => repeatEffectOption(pipe(effect, Effect.mapError(Option.some)));\n/** @internal */\nexport const repeatEffectChunk = effect => repeatEffectChunkOption(pipe(effect, Effect.mapError(Option.some)));\n/** @internal */\nexport const repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => pipe(Effect.map(effect, chunk => Option.some([chunk, effect])), Effect.catchAll(Option.match({\n  onNone: () => Effect.succeed(Option.none()),\n  onSome: Effect.fail\n}))));\n/** @internal */\nexport const repeatEffectOption = effect => repeatEffectChunkOption(pipe(effect, Effect.map(Chunk.of)));\n/** @internal */\nexport const repeatEither = /*#__PURE__*/dual(2, (self, schedule) => repeatWith(self, schedule, {\n  onElement: a => Either.right(a),\n  onSchedule: Either.left\n}));\n/** @internal */\nexport const repeatElements = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatElementsWith(self, schedule, {\n  onElement: a => Option.some(a),\n  onSchedule: Option.none\n}), identity));\n/** @internal */\nexport const repeatElementsWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  const driver = pipe(Schedule.driver(schedule), Effect.map(driver => {\n    const feed = input => Option.match(Chunk.head(input), {\n      onNone: () => loop,\n      onSome: a => channel.zipRight(core.write(Chunk.of(options.onElement(a))), step(pipe(input, Chunk.drop(1)), a))\n    });\n    const step = (input, a) => {\n      const advance = pipe(driver.next(a), Effect.as(pipe(core.write(Chunk.of(options.onElement(a))), core.flatMap(() => step(input, a)))));\n      const reset = pipe(driver.last, Effect.orDie, Effect.flatMap(b => pipe(driver.reset, Effect.map(() => pipe(core.write(Chunk.of(options.onSchedule(b))), channel.zipRight(feed(input)))))));\n      return pipe(advance, Effect.orElse(() => reset), channel.unwrap);\n    };\n    const loop = core.readWith({\n      onInput: feed,\n      onFailure: core.fail,\n      onDone: () => core.void\n    });\n    return loop;\n  }), channel.unwrap);\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(driver)));\n});\n/** @internal */\nexport const repeatValue = value => new StreamImpl(channel.repeated(core.write(Chunk.of(value))));\n/** @internal */\nexport const repeatWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  return pipe(Schedule.driver(schedule), Effect.map(driver => {\n    const provideLastIterationInfo = provideServiceEffect(Schedule.CurrentIterationMetadata, Ref.get(driver.iterationMeta));\n    const process = pipe(self, provideLastIterationInfo, map(options.onElement), toChannel);\n    const loop = channel.unwrap(Effect.match(driver.next(void 0), {\n      onFailure: () => core.void,\n      onSuccess: output => core.flatMap(process, () => channel.zipRight(core.write(Chunk.of(options.onSchedule(output))), loop))\n    }));\n    return new StreamImpl(channel.zipRight(process, loop));\n  }), unwrap);\n});\nconst repeatWithSchedule = (value, schedule) => repeatEffectWithSchedule(Effect.succeed(value), schedule);\n/** @internal */\nexport const repeatEffectWithSchedule = (effect, schedule) => flatMap(fromEffect(Effect.zip(effect, Schedule.driver(schedule))), ([a, driver]) => {\n  const provideLastIterationInfo = Effect.provideServiceEffect(Schedule.CurrentIterationMetadata, Ref.get(driver.iterationMeta));\n  return concat(succeed(a), unfoldEffect(a, s => Effect.matchEffect(driver.next(s), {\n    onFailure: Effect.succeed,\n    onSuccess: () => Effect.map(provideLastIterationInfo(effect), nextA => Option.some([nextA, nextA]))\n  })));\n});\n/** @internal */\nexport const retry = /*#__PURE__*/dual(2, (self, policy) => Schedule.driver(policy).pipe(Effect.map(driver => {\n  const provideLastIterationInfo = provideServiceEffect(Schedule.CurrentIterationMetadata, Ref.get(driver.iterationMeta));\n  const loop = toChannel(provideLastIterationInfo(self)).pipe(channel.mapOutEffect(out => Effect.as(driver.reset, out)), channel.catchAll(error => driver.next(error).pipe(Effect.match({\n    onFailure: () => core.fail(error),\n    onSuccess: () => loop\n  }), channel.unwrap)));\n  return loop;\n}), channel.unwrap, fromChannel));\n/** @internal */\nexport const withExecutionPlan = /*#__PURE__*/dual(args => isStream(args[0]), (self, policy, options) => suspend(() => {\n  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;\n  let i = 0;\n  let lastError = Option.none();\n  const loop = suspend(() => {\n    const step = policy.steps[i++];\n    if (!step) {\n      return fail(Option.getOrThrow(lastError));\n    }\n    let nextStream = Context.isContext(step.provide) ? provideSomeContext(self, step.provide) : provideSomeLayer(self, step.provide);\n    let receivedElements = false;\n    if (Option.isSome(lastError)) {\n      const error = lastError.value;\n      let attempted = false;\n      const wrapped = nextStream;\n      // ensure the schedule is applied at least once\n      nextStream = suspend(() => {\n        if (attempted) return wrapped;\n        attempted = true;\n        return fail(error);\n      });\n      nextStream = scheduleDefectRefail(retry(nextStream, internalExecutionPlan.scheduleFromStep(step, false)));\n    } else {\n      const schedule = internalExecutionPlan.scheduleFromStep(step, true);\n      nextStream = schedule ? scheduleDefectRefail(retry(nextStream, schedule)) : nextStream;\n    }\n    return catchAll(preventFallbackOnPartialStream ? mapChunks(nextStream, chunk => {\n      receivedElements = true;\n      return chunk;\n    }) : nextStream, error => {\n      if (preventFallbackOnPartialStream && receivedElements) {\n        return fail(error);\n      }\n      lastError = Option.some(error);\n      return loop;\n    });\n  });\n  return loop;\n}));\nconst scheduleDefectRefail = self => catchAllCause(self, cause => failCause(InternalSchedule.scheduleDefectRefailCause(cause)));\n/** @internal */\nexport const run = /*#__PURE__*/dual(2, (self, sink) => toChannel(self).pipe(channel.pipeToOrFail(sink_.toChannel(sink)), channel.runDrain));\n/** @internal */\nexport const runCollect = self => run(self, sink_.collectAll());\n/** @internal */\nexport const runCount = self => run(self, sink_.count);\n/** @internal */\nexport const runDrain = self => run(self, sink_.drain);\n/** @internal */\nexport const runFold = /*#__PURE__*/dual(3, (self, s, f) => runFoldWhile(self, s, constTrue, f));\n/** @internal */\nexport const runFoldEffect = /*#__PURE__*/dual(3, (self, s, f) => runFoldWhileEffect(self, s, constTrue, f));\n/** @internal */\nexport const runFoldScoped = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));\n/** @internal */\nexport const runFoldScopedEffect = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));\n/** @internal */\nexport const runFoldWhile = /*#__PURE__*/dual(4, (self, s, cont, f) => run(self, sink_.fold(s, cont, f)));\n/** @internal */\nexport const runFoldWhileEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => run(self, sink_.foldEffect(s, cont, f)));\n/** @internal */\nexport const runFoldWhileScoped = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runScoped(sink_.fold(s, cont, f))));\n/** @internal */\nexport const runFoldWhileScopedEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => pipe(self, runScoped(sink_.foldEffect(s, cont, f))));\n/** @internal */\nexport const runForEach = /*#__PURE__*/dual(2, (self, f) => run(self, sink_.forEach(f)));\n/** @internal */\nexport const runForEachChunk = /*#__PURE__*/dual(2, (self, f) => run(self, sink_.forEachChunk(f)));\n/** @internal */\nexport const runForEachChunkScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(sink_.forEachChunk(f))));\n/** @internal */\nexport const runForEachScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(sink_.forEach(f))));\n/** @internal */\nexport const runForEachWhile = /*#__PURE__*/dual(2, (self, f) => run(self, sink_.forEachWhile(f)));\n/** @internal */\nexport const runForEachWhileScoped = /*#__PURE__*/dual(2, (self, f) => pipe(self, runScoped(sink_.forEachWhile(f))));\n/** @internal */\nexport const runHead = self => run(self, sink_.head());\n/** @internal */\nexport const runIntoPubSub = /*#__PURE__*/dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));\n/** @internal */\nexport const runIntoPubSubScoped = /*#__PURE__*/dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));\n/** @internal */\nexport const runIntoQueue = /*#__PURE__*/dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), Effect.scoped));\n/** @internal */\nexport const runIntoQueueElementsScoped = /*#__PURE__*/dual(2, (self, queue) => {\n  const writer = core.readWithCause({\n    onInput: input => core.flatMap(core.fromEffect(Queue.offerAll(queue, Chunk.map(input, Exit.succeed))), () => writer),\n    onFailure: cause => core.fromEffect(Queue.offer(queue, Exit.failCause(Cause.map(cause, Option.some)))),\n    onDone: () => core.fromEffect(Queue.offer(queue, Exit.fail(Option.none())))\n  });\n  return pipe(core.pipeTo(toChannel(self), writer), channel.drain, channel.runScoped, Effect.asVoid);\n});\n/** @internal */\nexport const runIntoQueueScoped = /*#__PURE__*/dual(2, (self, queue) => {\n  const writer = core.readWithCause({\n    onInput: input => core.flatMap(core.write(InternalTake.chunk(input)), () => writer),\n    onFailure: cause => core.write(InternalTake.failCause(cause)),\n    onDone: () => core.write(InternalTake.end)\n  });\n  return pipe(core.pipeTo(toChannel(self), writer), channel.mapOutEffect(take => Queue.offer(queue, take)), channel.drain, channel.runScoped, Effect.asVoid);\n});\n/** @internal */\nexport const runLast = self => run(self, sink_.last());\n/** @internal */\nexport const runScoped = /*#__PURE__*/dual(2, (self, sink) => pipe(toChannel(self), channel.pipeToOrFail(sink_.toChannel(sink)), channel.drain, channel.runScoped));\n/** @internal */\nexport const runSum = self => run(self, sink_.sum);\n/** @internal */\nexport const scan = /*#__PURE__*/dual(3, (self, s, f) => pipe(self, scanEffect(s, (s, a) => Effect.succeed(f(s, a)))));\n/** @internal */\nexport const scanReduce = /*#__PURE__*/dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => Effect.succeed(f(a2, a)))));\n/** @internal */\nexport const scanReduceEffect = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapAccumEffect(Option.none(), (option, a) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Effect.succeed([Option.some(a), a]);\n      }\n    case \"Some\":\n      {\n        return pipe(f(option.value, a), Effect.map(b => [Option.some(b), b]));\n      }\n  }\n})));\n/** @internal */\nexport const schedule = /*#__PURE__*/dual(2, (self, schedule) => filterMap(scheduleWith(self, schedule, {\n  onElement: Option.some,\n  onSchedule: Option.none\n}), identity));\n/** @internal */\nexport const scheduleWith = /*#__PURE__*/dual(3, (self, schedule, options) => {\n  const loop = (driver, iterator) => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: chunk => loop(driver, chunk[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeedNow\n      });\n    }\n    return channel.unwrap(Effect.matchEffect(driver.next(next.value), {\n      onFailure: () => pipe(driver.last, Effect.orDie, Effect.map(b => pipe(core.write(Chunk.make(options.onElement(next.value), options.onSchedule(b))), core.flatMap(() => loop(driver, iterator)))), Effect.zipLeft(driver.reset)),\n      onSuccess: () => Effect.succeed(pipe(core.write(Chunk.of(options.onElement(next.value))), core.flatMap(() => loop(driver, iterator))))\n    }));\n  };\n  return new StreamImpl(pipe(core.fromEffect(Schedule.driver(schedule)), core.flatMap(driver => pipe(toChannel(self), core.pipeTo(loop(driver, Chunk.empty()[Symbol.iterator]()))))));\n});\n/** @internal */\nexport const scanEffect = /*#__PURE__*/dual(3, (self, s, f) => new StreamImpl(pipe(core.write(Chunk.of(s)), core.flatMap(() => toChannel(pipe(self, mapAccumEffect(s, (s, a) => pipe(f(s, a), Effect.map(s => [s, s])))))))));\n/** @internal */\nexport const scoped = effect => new StreamImpl(channel.ensuring(channel.scoped(pipe(effect, Effect.map(Chunk.of))), Effect.void));\n/** @internal */\nexport const scopedWith = f => new StreamImpl(channel.scopedWith(scope => f(scope).pipe(Effect.map(Chunk.of))));\n/** @internal */\nexport const some = self => pipe(self, mapError(Option.some), someOrFail(() => Option.none()));\n/** @internal */\nexport const someOrElse = /*#__PURE__*/dual(2, (self, fallback) => pipe(self, map(Option.getOrElse(fallback))));\n/** @internal */\nexport const someOrFail = /*#__PURE__*/dual(2, (self, error) => mapEffectSequential(self, Option.match({\n  onNone: () => Effect.failSync(error),\n  onSome: Effect.succeed\n})));\n/** @internal */\nexport const sliding = /*#__PURE__*/dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));\n/** @internal */\nexport const slidingSize = /*#__PURE__*/dual(3, (self, chunkSize, stepSize) => {\n  if (chunkSize <= 0 || stepSize <= 0) {\n    return die(new Cause.IllegalArgumentException(\"Invalid bounds - `chunkSize` and `stepSize` must be greater than zero\"));\n  }\n  return new StreamImpl(core.suspend(() => {\n    const queue = new RingBuffer(chunkSize);\n    const emitOnStreamEnd = (queueSize, channelEnd) => {\n      if (queueSize < chunkSize) {\n        const items = queue.toChunk();\n        const result = Chunk.isEmpty(items) ? Chunk.empty() : Chunk.of(items);\n        return pipe(core.write(result), core.flatMap(() => channelEnd));\n      }\n      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;\n      if (lastEmitIndex === queueSize) {\n        return channelEnd;\n      }\n      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);\n      const lastItems = pipe(queue.toChunk(), Chunk.takeRight(leftovers));\n      const result = Chunk.isEmpty(lastItems) ? Chunk.empty() : Chunk.of(lastItems);\n      return pipe(core.write(result), core.flatMap(() => channelEnd));\n    };\n    const reader = queueSize => core.readWithCause({\n      onInput: input => core.flatMap(core.write(Chunk.filterMap(input, (element, index) => {\n        queue.put(element);\n        const currentIndex = queueSize + index + 1;\n        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {\n          return Option.none();\n        }\n        return Option.some(queue.toChunk());\n      })), () => reader(queueSize + input.length)),\n      onFailure: cause => emitOnStreamEnd(queueSize, core.failCause(cause)),\n      onDone: () => emitOnStreamEnd(queueSize, core.void)\n    });\n    return pipe(toChannel(self), core.pipeTo(reader(0)));\n  }));\n});\n/** @internal */\nexport const split = /*#__PURE__*/dual(2, (self, predicate) => {\n  const split = (leftovers, input) => {\n    const [chunk, remaining] = pipe(leftovers, Chunk.appendAll(input), Chunk.splitWhere(predicate));\n    if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {\n      return loop(pipe(chunk, Chunk.appendAll(pipe(remaining, Chunk.drop(1)))));\n    }\n    return pipe(core.write(Chunk.of(chunk)), core.flatMap(() => split(Chunk.empty(), pipe(remaining, Chunk.drop(1)))));\n  };\n  const loop = leftovers => core.readWith({\n    onInput: input => split(leftovers, input),\n    onFailure: core.fail,\n    onDone: () => {\n      if (Chunk.isEmpty(leftovers)) {\n        return core.void;\n      }\n      if (Option.isNone(pipe(leftovers, Chunk.findFirst(predicate)))) {\n        return channel.zipRight(core.write(Chunk.of(leftovers)), core.void);\n      }\n      return channel.zipRight(split(Chunk.empty(), leftovers), core.void);\n    }\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty()))));\n});\n/** @internal */\nexport const splitOnChunk = /*#__PURE__*/dual(2, (self, delimiter) => {\n  const next = (leftover, delimiterIndex) => core.readWithCause({\n    onInput: inputChunk => {\n      let buffer;\n      const [carry, delimiterCursor] = pipe(inputChunk, Chunk.reduce([pipe(leftover, Option.getOrElse(() => Chunk.empty())), delimiterIndex], ([carry, delimiterCursor], a) => {\n        const concatenated = pipe(carry, Chunk.append(a));\n        if (delimiterCursor < delimiter.length && Equal.equals(a, pipe(delimiter, Chunk.unsafeGet(delimiterCursor)))) {\n          if (delimiterCursor + 1 === delimiter.length) {\n            if (buffer === undefined) {\n              buffer = [];\n            }\n            buffer.push(pipe(concatenated, Chunk.take(concatenated.length - delimiter.length)));\n            return [Chunk.empty(), 0];\n          }\n          return [concatenated, delimiterCursor + 1];\n        }\n        return [concatenated, Equal.equals(a, pipe(delimiter, Chunk.unsafeGet(0))) ? 1 : 0];\n      }));\n      const output = buffer === undefined ? Chunk.empty() : Chunk.unsafeFromArray(buffer);\n      return core.flatMap(core.write(output), () => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor));\n    },\n    onFailure: cause => Option.match(leftover, {\n      onNone: () => core.failCause(cause),\n      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.failCause(cause))\n    }),\n    onDone: done => Option.match(leftover, {\n      onNone: () => core.succeed(done),\n      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.succeed(done))\n    })\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(next(Option.none(), 0))));\n});\n/** @internal */\nexport const splitLines = self => pipeThroughChannel(self, channel.splitLines());\n/** @internal */\nexport const succeed = value => fromChunk(Chunk.of(value));\n/** @internal */\nexport const sync = evaluate => suspend(() => fromChunk(Chunk.of(evaluate())));\n/** @internal */\nexport const suspend = stream => new StreamImpl(core.suspend(() => toChannel(stream())));\n/** @internal */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (!Number.isInteger(n)) {\n    return die(new Cause.IllegalArgumentException(`${n} must be an integer`));\n  }\n  const loop = n => core.readWith({\n    onInput: input => {\n      const taken = pipe(input, Chunk.take(Math.min(n, Number.POSITIVE_INFINITY)));\n      const leftover = Math.max(0, n - taken.length);\n      const more = leftover > 0;\n      if (more) {\n        return pipe(core.write(taken), core.flatMap(() => loop(leftover)));\n      }\n      return core.write(taken);\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(0 < n ? loop(n) : core.void)));\n});\n/** @internal */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return empty;\n  }\n  return new StreamImpl(pipe(Effect.succeed(new RingBuffer(n)), Effect.map(queue => {\n    const reader = core.readWith({\n      onInput: input => {\n        for (const element of input) {\n          queue.put(element);\n        }\n        return reader;\n      },\n      onFailure: core.fail,\n      onDone: () => pipe(core.write(queue.toChunk()), channel.zipRight(core.void))\n    });\n    return pipe(toChannel(self), core.pipeTo(reader));\n  }), channel.unwrap));\n});\n/** @internal */\nexport const takeUntil = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => {\n      const taken = pipe(input, Chunk.takeWhile(a => !predicate(a)));\n      const last = pipe(input, Chunk.drop(taken.length), Chunk.take(1));\n      if (Chunk.isEmpty(last)) {\n        return pipe(core.write(taken), core.flatMap(() => loop));\n      }\n      return core.write(pipe(taken, Chunk.appendAll(last)));\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)));\n});\n/** @internal */\nexport const takeUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause({\n        onInput: elem => loop(elem[Symbol.iterator]()),\n        onFailure: core.failCause,\n        onDone: core.succeed\n      });\n    }\n    return pipe(predicate(next.value), Effect.map(bool => bool ? core.write(Chunk.of(next.value)) : pipe(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator)))), channel.unwrap);\n  };\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))));\n});\n/** @internal */\nexport const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const loop = core.readWith({\n    onInput: input => {\n      const taken = pipe(input, Chunk.takeWhile(predicate));\n      const more = taken.length === input.length;\n      if (more) {\n        return pipe(core.write(taken), core.flatMap(() => loop));\n      }\n      return core.write(taken);\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)));\n});\n/** @internal */\nexport const tap = /*#__PURE__*/dual(2, (self, f) => mapEffectSequential(self, a => Effect.as(f(a), a)));\n/** @internal */\nexport const tapBoth = /*#__PURE__*/dual(2, (self, options) => pipe(self, tapError(options.onFailure), tap(options.onSuccess)));\n/** @internal */\nexport const tapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, error => fromEffect(Effect.zipRight(f(error), Effect.fail(error)))));\n/** @internal */\nexport const tapErrorCause = /*#__PURE__*/dual(2, (self, f) => {\n  const loop = core.readWithCause({\n    onInput: chunk => core.flatMap(core.write(chunk), () => loop),\n    onFailure: cause => core.fromEffect(Effect.zipRight(f(cause), Effect.failCause(cause))),\n    onDone: core.succeedNow\n  });\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)));\n});\n/** @internal */\nexport const tapSink = /*#__PURE__*/dual(2, (self, sink) => pipe(fromEffect(Effect.all([Queue.bounded(1), Deferred.make()])), flatMap(([queue, deferred]) => {\n  const right = flattenTake(fromQueue(queue, {\n    maxChunkSize: 1\n  }));\n  const loop = core.readWithCause({\n    onInput: chunk => pipe(core.fromEffect(Queue.offer(queue, InternalTake.chunk(chunk))), core.foldCauseChannel({\n      onFailure: () => core.flatMap(core.write(chunk), () => channel.identityChannel()),\n      onSuccess: () => core.flatMap(core.write(chunk), () => loop)\n    })),\n    onFailure: cause => pipe(core.fromEffect(Queue.offer(queue, InternalTake.failCause(cause))), core.foldCauseChannel({\n      onFailure: () => core.failCause(cause),\n      onSuccess: () => core.failCause(cause)\n    })),\n    onDone: () => pipe(core.fromEffect(Queue.offer(queue, InternalTake.end)), core.foldCauseChannel({\n      onFailure: () => core.void,\n      onSuccess: () => core.void\n    }))\n  });\n  return pipe(new StreamImpl(pipe(core.pipeTo(toChannel(self), loop), channel.ensuring(Effect.zipRight(Effect.forkDaemon(Queue.offer(queue, InternalTake.end)), Deferred.await(deferred))))), merge(execute(pipe(run(right, sink), Effect.ensuring(Effect.zipRight(Queue.shutdown(queue), Deferred.succeed(deferred, void 0)))))));\n})));\n/** @internal */\nexport const throttle = /*#__PURE__*/dual(2, (self, options) => throttleEffect(self, {\n  ...options,\n  cost: chunk => Effect.succeed(options.cost(chunk))\n}));\n/** @internal */\nexport const throttleEffect = /*#__PURE__*/dual(2, (self, options) => {\n  if (options.strategy === \"enforce\") {\n    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);\n  }\n  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);\n});\nconst throttleEnforceEffect = (self, cost, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => core.readWithCause({\n    onInput: input => pipe(cost(input), Effect.zip(Clock.currentTimeMillis), Effect.map(([weight, currentTimeMillis]) => {\n      const elapsed = currentTimeMillis - timestampMillis;\n      const cycles = elapsed / Duration.toMillis(duration);\n      const sum = tokens + cycles * units;\n      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n      const available = sum < 0 ? max : Math.min(sum, max);\n      if (weight <= available) {\n        return pipe(core.write(input), core.flatMap(() => loop(available - weight, currentTimeMillis)));\n      }\n      return loop(tokens, timestampMillis);\n    }), channel.unwrap),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  const throttled = pipe(Clock.currentTimeMillis, Effect.map(currentTimeMillis => loop(units, currentTimeMillis)), channel.unwrap);\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(throttled)));\n};\nconst throttleShapeEffect = (self, costFn, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => core.readWithCause({\n    onInput: input => pipe(costFn(input), Effect.zip(Clock.currentTimeMillis), Effect.map(([weight, currentTimeMillis]) => {\n      const elapsed = currentTimeMillis - timestampMillis;\n      const cycles = elapsed / Duration.toMillis(duration);\n      const sum = tokens + cycles * units;\n      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n      const available = sum < 0 ? max : Math.min(sum, max);\n      const remaining = available - weight;\n      const waitCycles = remaining >= 0 ? 0 : -remaining / units;\n      const delay = Duration.millis(Math.max(0, waitCycles * Duration.toMillis(duration)));\n      if (Duration.greaterThan(delay, Duration.zero)) {\n        return pipe(core.fromEffect(Clock.sleep(delay)), channel.zipRight(core.write(input)), core.flatMap(() => loop(remaining, currentTimeMillis)));\n      }\n      return core.flatMap(core.write(input), () => loop(remaining, currentTimeMillis));\n    }), channel.unwrap),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  });\n  const throttled = pipe(Clock.currentTimeMillis, Effect.map(currentTimeMillis => loop(units, currentTimeMillis)), channel.unwrap);\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(throttled)));\n};\n/** @internal */\nexport const tick = interval => repeatWithSchedule(void 0, Schedule.spaced(interval));\n/** @internal */\nexport const timeout = /*#__PURE__*/dual(2, (self, duration) => pipe(toPull(self), Effect.map(Effect.timeoutFail({\n  onTimeout: () => Option.none(),\n  duration\n})), fromPull));\n/** @internal */\nexport const timeoutFail = /*#__PURE__*/dual(3, (self, error, duration) => pipe(self, timeoutTo(duration, failSync(error))));\n/** @internal */\nexport const timeoutFailCause = /*#__PURE__*/dual(3, (self, cause, duration) => pipe(toPull(self), Effect.map(Effect.timeoutFailCause({\n  onTimeout: () => Cause.map(cause(), Option.some),\n  duration\n})), fromPull));\n/** @internal */\nexport const timeoutTo = /*#__PURE__*/dual(3, (self, duration, that) => {\n  const StreamTimeout = new Cause.RuntimeException(\"Stream Timeout\");\n  return pipe(self, timeoutFailCause(() => Cause.die(StreamTimeout), duration), catchSomeCause(cause => Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === \"Stream Timeout\" ? Option.some(that) : Option.none()));\n});\nconst pubsubFromOptions = options => {\n  if (typeof options === \"number\") {\n    return PubSub.bounded(options);\n  } else if (options.capacity === \"unbounded\") {\n    return PubSub.unbounded({\n      replay: options.replay\n    });\n  }\n  switch (options.strategy) {\n    case \"dropping\":\n      return PubSub.dropping(options);\n    case \"sliding\":\n      return PubSub.sliding(options);\n    default:\n      return PubSub.bounded(options);\n  }\n};\n/** @internal */\nexport const toPubSub = /*#__PURE__*/dual(2, (self, capacity) => pipe(Effect.acquireRelease(pubsubFromOptions(capacity), pubsub => PubSub.shutdown(pubsub)), Effect.tap(pubsub => pipe(self, runIntoPubSubScoped(pubsub), Effect.forkScoped))));\n/** @internal */\nexport const toPull = self => Effect.map(channel.toPull(toChannel(self)), pull => pipe(pull, Effect.mapError(Option.some), Effect.flatMap(Either.match({\n  onLeft: () => Effect.fail(Option.none()),\n  onRight: Effect.succeed\n}))));\n/** @internal */\nexport const toQueue = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => Effect.tap(Effect.acquireRelease(options?.strategy === \"unbounded\" ? Queue.unbounded() : options?.strategy === \"dropping\" ? Queue.dropping(options.capacity ?? 2) : options?.strategy === \"sliding\" ? Queue.sliding(options.capacity ?? 2) : Queue.bounded(options?.capacity ?? 2), queue => Queue.shutdown(queue)), queue => Effect.forkScoped(runIntoQueueScoped(self, queue))));\n/** @internal */\nexport const toQueueOfElements = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => Effect.tap(Effect.acquireRelease(Queue.bounded(options?.capacity ?? 2), queue => Queue.shutdown(queue)), queue => Effect.forkScoped(runIntoQueueElementsScoped(self, queue))));\n/** @internal */\nexport const toReadableStream = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => toReadableStreamRuntime(self, Runtime.defaultRuntime, options));\n/** @internal */\nexport const toReadableStreamEffect = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => Effect.map(Effect.runtime(), runtime => toReadableStreamRuntime(self, runtime, options)));\n/** @internal */\nexport const toReadableStreamRuntime = /*#__PURE__*/dual(args => isStream(args[0]), (self, runtime, options) => {\n  const runFork = Runtime.runFork(runtime);\n  let currentResolve = undefined;\n  let fiber = undefined;\n  const latch = Effect.unsafeMakeLatch(false);\n  return new ReadableStream({\n    start(controller) {\n      fiber = runFork(runForEachChunk(self, chunk => {\n        if (chunk.length === 0) return Effect.void;\n        return latch.whenOpen(Effect.sync(() => {\n          latch.unsafeClose();\n          for (const item of chunk) {\n            controller.enqueue(item);\n          }\n          currentResolve();\n          currentResolve = undefined;\n        }));\n      }));\n      fiber.addObserver(exit => {\n        try {\n          if (exit._tag === \"Failure\") {\n            controller.error(Cause.squash(exit.cause));\n          } else {\n            controller.close();\n          }\n        } catch {\n          // ignore\n        }\n      });\n    },\n    pull() {\n      return new Promise(resolve => {\n        currentResolve = resolve;\n        Effect.runSync(latch.open);\n      });\n    },\n    cancel() {\n      if (!fiber) return;\n      return Effect.runPromise(Effect.asVoid(Fiber.interrupt(fiber)));\n    }\n  }, options?.strategy);\n});\n/** @internal */\nexport const transduce = /*#__PURE__*/dual(2, (self, sink) => {\n  const newChannel = core.suspend(() => {\n    const leftovers = {\n      ref: Chunk.empty()\n    };\n    const upstreamDone = {\n      ref: false\n    };\n    const buffer = core.suspend(() => {\n      const leftover = leftovers.ref;\n      if (Chunk.isEmpty(leftover)) {\n        return core.readWith({\n          onInput: input => pipe(core.write(input), core.flatMap(() => buffer)),\n          onFailure: core.fail,\n          onDone: core.succeedNow\n        });\n      }\n      leftovers.ref = Chunk.empty();\n      return pipe(channel.writeChunk(leftover), core.flatMap(() => buffer));\n    });\n    const concatAndGet = chunk => {\n      const leftover = leftovers.ref;\n      const concatenated = Chunk.appendAll(leftover, Chunk.filter(chunk, chunk => chunk.length !== 0));\n      leftovers.ref = concatenated;\n      return concatenated;\n    };\n    const upstreamMarker = core.readWith({\n      onInput: input => core.flatMap(core.write(input), () => upstreamMarker),\n      onFailure: core.fail,\n      onDone: done => channel.zipRight(core.sync(() => {\n        upstreamDone.ref = true;\n      }), core.succeedNow(done))\n    });\n    const transducer = pipe(sink, sink_.toChannel, core.collectElements, core.flatMap(([leftover, z]) => pipe(core.succeed([upstreamDone.ref, concatAndGet(leftover)]), core.flatMap(([done, newLeftovers]) => {\n      const nextChannel = done && Chunk.isEmpty(newLeftovers) ? core.void : transducer;\n      return pipe(core.write(Chunk.of(z)), core.flatMap(() => nextChannel));\n    }))));\n    return pipe(toChannel(self), core.pipeTo(upstreamMarker), core.pipeTo(buffer), channel.pipeToOrFail(transducer));\n  });\n  return new StreamImpl(newChannel);\n});\n/** @internal */\nexport const toAsyncIterableRuntime = /*#__PURE__*/dual(args => isStream(args[0]), (self, runtime) => {\n  const runFork = Runtime.runFork(runtime);\n  return {\n    [Symbol.asyncIterator]() {\n      let currentResolve = undefined;\n      let currentReject = undefined;\n      let fiber = undefined;\n      const latch = Effect.unsafeMakeLatch(false);\n      let returned = false;\n      return {\n        next() {\n          if (!fiber) {\n            fiber = runFork(runForEach(self, value => latch.whenOpen(Effect.sync(() => {\n              latch.unsafeClose();\n              currentResolve({\n                done: false,\n                value\n              });\n              currentResolve = currentReject = undefined;\n            }))));\n            fiber.addObserver(exit => {\n              if (returned) return;\n              fiber = Effect.runFork(latch.whenOpen(Effect.sync(() => {\n                if (exit._tag === \"Failure\") {\n                  currentReject(Cause.squash(exit.cause));\n                } else {\n                  currentResolve({\n                    done: true,\n                    value: void 0\n                  });\n                }\n                currentResolve = currentReject = undefined;\n              })));\n            });\n          }\n          return new Promise((resolve, reject) => {\n            currentResolve = resolve;\n            currentReject = reject;\n            latch.unsafeOpen();\n          });\n        },\n        return() {\n          returned = true;\n          if (!fiber) return Promise.resolve({\n            done: true,\n            value: void 0\n          });\n          return Effect.runPromise(Effect.as(Fiber.interrupt(fiber), {\n            done: true,\n            value: void 0\n          }));\n        }\n      };\n    }\n  };\n});\n/** @internal */\nexport const toAsyncIterable = self => toAsyncIterableRuntime(self, Runtime.defaultRuntime);\n/** @internal */\nexport const toAsyncIterableEffect = self => Effect.map(Effect.runtime(), runtime => toAsyncIterableRuntime(self, runtime));\n/** @internal */\nexport const unfold = (s, f) => unfoldChunk(s, s => pipe(f(s), Option.map(([a, s]) => [Chunk.of(a), s])));\n/** @internal */\nexport const unfoldChunk = (s, f) => {\n  const loop = s => Option.match(f(s), {\n    onNone: () => core.void,\n    onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))\n  });\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexport const unfoldChunkEffect = (s, f) => suspend(() => {\n  const loop = s => channel.unwrap(Effect.map(f(s), Option.match({\n    onNone: () => core.void,\n    onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))\n  })));\n  return new StreamImpl(loop(s));\n});\n/** @internal */\nexport const unfoldEffect = (s, f) => unfoldChunkEffect(s, s => pipe(f(s), Effect.map(Option.map(([a, s]) => [Chunk.of(a), s]))));\nconst void_ = /*#__PURE__*/succeed(void 0);\nexport { /** @internal */\nvoid_ as void };\n/** @internal */\nexport const unwrap = effect => flatten(fromEffect(effect));\n/** @internal */\nexport const unwrapScoped = effect => flatten(scoped(effect));\n/** @internal */\nexport const unwrapScopedWith = f => flatten(scopedWith(scope => f(scope)));\n/** @internal */\nexport const updateService = /*#__PURE__*/dual(3, (self, tag, f) => pipe(self, mapInputContext(context => pipe(context, Context.add(tag, f(pipe(context, Context.unsafeGet(tag))))))));\n/** @internal */\nexport const when = /*#__PURE__*/dual(2, (self, test) => pipe(self, whenEffect(Effect.sync(test))));\n/** @internal */\nexport const whenCase = (evaluate, pf) => whenCaseEffect(pf)(Effect.sync(evaluate));\n/** @internal */\nexport const whenCaseEffect = /*#__PURE__*/dual(2, (self, pf) => pipe(fromEffect(self), flatMap(a => pipe(pf(a), Option.getOrElse(() => empty)))));\n/** @internal */\nexport const whenEffect = /*#__PURE__*/dual(2, (self, effect) => pipe(fromEffect(effect), flatMap(bool => bool ? self : empty)));\n/** @internal */\nexport const withSpan = function () {\n  const dataFirst = typeof arguments[0] !== \"string\";\n  const name = dataFirst ? arguments[1] : arguments[0];\n  const options = InternalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);\n  if (dataFirst) {\n    const self = arguments[0];\n    return new StreamImpl(channel.withSpan(toChannel(self), name, options));\n  }\n  return self => new StreamImpl(channel.withSpan(toChannel(self), name, options));\n};\n/** @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWith(that, (a, a2) => [a, a2])));\n/** @internal */\nexport const zipFlatten = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWith(that, (a, a2) => [...a, a2])));\n/** @internal */\nexport const zipAll = /*#__PURE__*/dual(2, (self, options) => zipAllWith(self, {\n  other: options.other,\n  onSelf: a => [a, options.defaultOther],\n  onOther: a2 => [options.defaultSelf, a2],\n  onBoth: (a, a2) => [a, a2]\n}));\n/** @internal */\nexport const zipAllLeft = /*#__PURE__*/dual(3, (self, other, defaultSelf) => zipAllWith(self, {\n  other,\n  onSelf: identity,\n  onOther: () => defaultSelf,\n  onBoth: a => a\n}));\n/** @internal */\nexport const zipAllRight = /*#__PURE__*/dual(3, (self, other, defaultRight) => zipAllWith(self, {\n  other,\n  onSelf: () => defaultRight,\n  onOther: identity,\n  onBoth: (_, a2) => a2\n}));\n/** @internal */\nexport const zipAllSortedByKey = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: a => [a, options.defaultOther],\n  onOther: a2 => [options.defaultSelf, a2],\n  onBoth: (a, a2) => [a, a2],\n  order: options.order\n}));\n/** @internal */\nexport const zipAllSortedByKeyLeft = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: identity,\n  onOther: () => options.defaultSelf,\n  onBoth: a => a,\n  order: options.order\n}));\n/** @internal */\nexport const zipAllSortedByKeyRight = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {\n  other: options.other,\n  onSelf: () => options.defaultOther,\n  onOther: identity,\n  onBoth: (_, a2) => a2,\n  order: options.order\n}));\n/** @internal */\nexport const zipAllSortedByKeyWith = /*#__PURE__*/dual(2, (self, options) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipAllState.OP_DRAIN_LEFT:\n        {\n          return pipe(pullLeft, Effect.match({\n            onFailure: Exit.fail,\n            onSuccess: leftChunk => Exit.succeed([Chunk.map(leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])\n          }));\n        }\n      case ZipAllState.OP_DRAIN_RIGHT:\n        {\n          return pipe(pullRight, Effect.match({\n            onFailure: Exit.fail,\n            onSuccess: rightChunk => Exit.succeed([Chunk.map(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), ZipAllState.DrainRight])\n          }));\n        }\n      case ZipAllState.OP_PULL_BOTH:\n        {\n          return pipe(unsome(pullLeft), Effect.zip(unsome(pullRight), {\n            concurrent: true\n          }), Effect.matchEffect({\n            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(leftOption.value)) {\n                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);\n                }\n                return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)));\n              }\n              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n                if (Chunk.isEmpty(leftOption.value)) {\n                  return pull(ZipAllState.DrainLeft, pullLeft, pullRight);\n                }\n                return Effect.succeed(Exit.succeed([pipe(leftOption.value, Chunk.map(([k, a]) => [k, options.onSelf(a)])), ZipAllState.DrainLeft]));\n              }\n              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n                if (Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipAllState.DrainRight, pullLeft, pullRight);\n                }\n                return Effect.succeed(Exit.succeed([pipe(rightOption.value, Chunk.map(([k, a2]) => [k, options.onOther(a2)])), ZipAllState.DrainRight]));\n              }\n              return Effect.succeed(Exit.fail(Option.none()));\n            }\n          }));\n        }\n      case ZipAllState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: Option.match({\n              onNone: () => Effect.succeed(Exit.succeed([pipe(state.rightChunk, Chunk.map(([k, a2]) => [k, options.onOther(a2)])), ZipAllState.DrainRight])),\n              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: leftChunk => Chunk.isEmpty(leftChunk) ? pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk)))\n          });\n        }\n      case ZipAllState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(pullRight, {\n            onFailure: Option.match({\n              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])),\n              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: rightChunk => Chunk.isEmpty(rightChunk) ? pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk)))\n          });\n        }\n    }\n  };\n  const merge = (leftChunk, rightChunk) => {\n    const hasNext = (chunk, index) => index < chunk.length - 1;\n    const builder = [];\n    let state = undefined;\n    let leftIndex = 0;\n    let rightIndex = 0;\n    let leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex));\n    let rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex));\n    let k1 = leftTuple[0];\n    let a = leftTuple[1];\n    let k2 = rightTuple[0];\n    let a2 = rightTuple[1];\n    let loop = true;\n    while (loop) {\n      const compare = options.order(k1, k2);\n      if (compare === 0) {\n        builder.push([k1, options.onBoth(a, a2)]);\n        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {\n          leftIndex = leftIndex + 1;\n          rightIndex = rightIndex + 1;\n          leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex));\n          rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex));\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else if (hasNext(leftChunk, leftIndex)) {\n          state = ZipAllState.PullRight(pipe(leftChunk, Chunk.drop(leftIndex + 1)));\n          loop = false;\n        } else if (hasNext(rightChunk, rightIndex)) {\n          state = ZipAllState.PullLeft(pipe(rightChunk, Chunk.drop(rightIndex + 1)));\n          loop = false;\n        } else {\n          state = ZipAllState.PullBoth;\n          loop = false;\n        }\n      } else if (compare < 0) {\n        builder.push([k1, options.onSelf(a)]);\n        if (hasNext(leftChunk, leftIndex)) {\n          leftIndex = leftIndex + 1;\n          leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex));\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n        } else {\n          const rightBuilder = [];\n          rightBuilder.push(rightTuple);\n          while (hasNext(rightChunk, rightIndex)) {\n            rightIndex = rightIndex + 1;\n            rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex));\n            rightBuilder.push(rightTuple);\n          }\n          state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder));\n          loop = false;\n        }\n      } else {\n        builder.push([k2, options.onOther(a2)]);\n        if (hasNext(rightChunk, rightIndex)) {\n          rightIndex = rightIndex + 1;\n          rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex));\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else {\n          const leftBuilder = [];\n          leftBuilder.push(leftTuple);\n          while (hasNext(leftChunk, leftIndex)) {\n            leftIndex = leftIndex + 1;\n            leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex));\n            leftBuilder.push(leftTuple);\n          }\n          state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder));\n          loop = false;\n        }\n      }\n    }\n    return [Chunk.unsafeFromArray(builder), state];\n  };\n  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);\n});\n/** @internal */\nexport const zipAllWith = /*#__PURE__*/dual(2, (self, options) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipAllState.OP_DRAIN_LEFT:\n        {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: error => Effect.succeed(Exit.fail(error)),\n            onSuccess: leftChunk => Effect.succeed(Exit.succeed([Chunk.map(leftChunk, options.onSelf), ZipAllState.DrainLeft]))\n          });\n        }\n      case ZipAllState.OP_DRAIN_RIGHT:\n        {\n          return Effect.matchEffect(pullRight, {\n            onFailure: error => Effect.succeed(Exit.fail(error)),\n            onSuccess: rightChunk => Effect.succeed(Exit.succeed([Chunk.map(rightChunk, options.onOther), ZipAllState.DrainRight]))\n          });\n        }\n      case ZipAllState.OP_PULL_BOTH:\n        {\n          return pipe(unsome(pullLeft), Effect.zip(unsome(pullRight), {\n            concurrent: true\n          }), Effect.matchEffect({\n            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(leftOption.value)) {\n                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);\n                }\n                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, options.onBoth)));\n              }\n              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n                return Effect.succeed(Exit.succeed([Chunk.map(leftOption.value, options.onSelf), ZipAllState.DrainLeft]));\n              }\n              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n                return Effect.succeed(Exit.succeed([Chunk.map(rightOption.value, options.onOther), ZipAllState.DrainRight]));\n              }\n              return Effect.succeed(Exit.fail(Option.none()));\n            }\n          }));\n        }\n      case ZipAllState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: Option.match({\n              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.rightChunk, options.onOther), ZipAllState.DrainRight])),\n              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: leftChunk => {\n              if (Chunk.isEmpty(leftChunk)) {\n                return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(state.rightChunk)) {\n                return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, options.onBoth)));\n            }\n          });\n        }\n      case ZipAllState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(pullRight, {\n            onFailure: Option.match({\n              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, options.onSelf), ZipAllState.DrainLeft])),\n              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: rightChunk => {\n              if (Chunk.isEmpty(rightChunk)) {\n                return pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(state.leftChunk)) {\n                return pull(ZipAllState.PullLeft(rightChunk), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, options.onBoth)));\n            }\n          });\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk, f) => {\n    const [output, either] = zipChunks(leftChunk, rightChunk, f);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (Chunk.isEmpty(either.left)) {\n            return [output, ZipAllState.PullBoth];\n          }\n          return [output, ZipAllState.PullRight(either.left)];\n        }\n      case \"Right\":\n        {\n          if (Chunk.isEmpty(either.right)) {\n            return [output, ZipAllState.PullBoth];\n          }\n          return [output, ZipAllState.PullLeft(either.right)];\n        }\n    }\n  };\n  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);\n});\n/** @internal */\nexport const zipLatest = /*#__PURE__*/dual(2, (left, right) => pipe(left, zipLatestWith(right, (a, a2) => [a, a2])));\nexport const zipLatestAll = (...streams) => {\n  if (streams.length === 0) {\n    return empty;\n  } else if (streams.length === 1) {\n    return map(streams[0], x => [x]);\n  }\n  const [head, ...tail] = streams;\n  return zipLatestWith(head, zipLatestAll(...tail), (first, second) => [first, ...second]);\n};\n/** @internal */\nexport const zipLatestWith = /*#__PURE__*/dual(3, (left, right, f) => {\n  const pullNonEmpty = pull => pipe(pull, Effect.flatMap(chunk => Chunk.isEmpty(chunk) ? pullNonEmpty(pull) : Effect.succeed(chunk)));\n  return pipe(toPull(left), Effect.map(pullNonEmpty), Effect.zip(pipe(toPull(right), Effect.map(pullNonEmpty))), Effect.flatMap(([left, right]) => pipe(fromEffectOption(Effect.raceWith(left, right, {\n    onSelfDone: (leftDone, rightFiber) => pipe(Effect.suspend(() => leftDone), Effect.zipWith(Fiber.join(rightFiber), (l, r) => [l, r, true])),\n    onOtherDone: (rightDone, leftFiber) => pipe(Effect.suspend(() => rightDone), Effect.zipWith(Fiber.join(leftFiber), (l, r) => [r, l, false]))\n  })), flatMap(([l, r, leftFirst]) => pipe(fromEffect(Ref.make([Chunk.unsafeLast(l), Chunk.unsafeLast(r)])), flatMap(latest => pipe(fromChunk(leftFirst ? pipe(r, Chunk.map(a2 => f(Chunk.unsafeLast(l), a2))) : pipe(l, Chunk.map(a => f(a, Chunk.unsafeLast(r))))), concat(pipe(repeatEffectOption(left), mergeEither(repeatEffectOption(right)), mapEffectSequential(Either.match({\n    onLeft: leftChunk => Ref.modify(latest, ([_, rightLatest]) => [pipe(leftChunk, Chunk.map(a => f(a, rightLatest))), [Chunk.unsafeLast(leftChunk), rightLatest]]),\n    onRight: rightChunk => Ref.modify(latest, ([leftLatest, _]) => [pipe(rightChunk, Chunk.map(a2 => f(leftLatest, a2))), [leftLatest, Chunk.unsafeLast(rightChunk)]])\n  })), flatMap(fromChunk))))))), toPull)), fromPull);\n});\n/** @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (left, right) => pipe(left, zipWithChunks(right, (left, right) => {\n  if (left.length > right.length) {\n    return [pipe(left, Chunk.take(right.length)), Either.left(pipe(left, Chunk.take(right.length)))];\n  }\n  return [left, Either.right(pipe(right, Chunk.drop(left.length)))];\n})));\n/** @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (left, right) => pipe(left, zipWithChunks(right, (left, right) => {\n  if (left.length > right.length) {\n    return [right, Either.left(pipe(left, Chunk.take(right.length)))];\n  }\n  return [pipe(right, Chunk.take(left.length)), Either.right(pipe(right, Chunk.drop(left.length)))];\n})));\n/** @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (left, right, f) => pipe(left, zipWithChunks(right, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));\n/** @internal */\nexport const zipWithChunks = /*#__PURE__*/dual(3, (self, that, f) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipChunksState.OP_PULL_BOTH:\n        {\n          return pipe(unsome(pullLeft), Effect.zip(unsome(pullRight), {\n            concurrent: true\n          }), Effect.matchEffect({\n            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipChunksState.PullBoth, pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(leftOption.value)) {\n                  return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight);\n                }\n                if (Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight);\n                }\n                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)));\n              }\n              return Effect.succeed(Exit.fail(Option.none()));\n            }\n          }));\n        }\n      case ZipChunksState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: error => Effect.succeed(Exit.fail(error)),\n            onSuccess: leftChunk => {\n              if (Chunk.isEmpty(leftChunk)) {\n                return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(state.rightChunk)) {\n                return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)));\n            }\n          });\n        }\n      case ZipChunksState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(pullRight, {\n            onFailure: error => Effect.succeed(Exit.fail(error)),\n            onSuccess: rightChunk => {\n              if (Chunk.isEmpty(rightChunk)) {\n                return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(state.leftChunk)) {\n                return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)));\n            }\n          });\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk) => {\n    const [output, either] = f(leftChunk, rightChunk);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (Chunk.isEmpty(either.left)) {\n            return [output, ZipChunksState.PullBoth];\n          }\n          return [output, ZipChunksState.PullRight(either.left)];\n        }\n      case \"Right\":\n        {\n          if (Chunk.isEmpty(either.right)) {\n            return [output, ZipChunksState.PullBoth];\n          }\n          return [output, ZipChunksState.PullLeft(either.right)];\n        }\n    }\n  };\n  return pipe(self, combineChunks(that, ZipChunksState.PullBoth, pull));\n});\n/** @internal */\nexport const zipWithIndex = self => pipe(self, mapAccum(0, (index, a) => [index + 1, [a, index]]));\n/** @internal */\nexport const zipWithNext = self => {\n  const process = last => core.readWithCause({\n    onInput: input => {\n      const [newLast, chunk] = Chunk.mapAccum(input, last, (prev, curr) => [Option.some(curr), pipe(prev, Option.map(a => [a, curr]))]);\n      const output = Chunk.filterMap(chunk, option => Option.isSome(option) ? Option.some([option.value[0], Option.some(option.value[1])]) : Option.none());\n      return core.flatMap(core.write(output), () => process(newLast));\n    },\n    onFailure: core.failCause,\n    onDone: () => Option.match(last, {\n      onNone: () => core.void,\n      onSome: value => channel.zipRight(core.write(Chunk.of([value, Option.none()])), core.void)\n    })\n  });\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(process(Option.none()))));\n};\n/** @internal */\nexport const zipWithPrevious = self => pipe(self, mapAccum(Option.none(), (prev, curr) => [Option.some(curr), [prev, curr]]));\n/** @internal */\nexport const zipWithPreviousAndNext = self => pipe(zipWithNext(zipWithPrevious(self)), map(([[prev, curr], next]) => [prev, curr, pipe(next, Option.map(tuple => tuple[1]))]));\n/** @internal */\nconst zipChunks = (left, right, f) => {\n  if (left.length > right.length) {\n    return [pipe(left, Chunk.take(right.length), Chunk.zipWith(right, f)), Either.left(pipe(left, Chunk.drop(right.length)))];\n  }\n  return [pipe(left, Chunk.zipWith(pipe(right, Chunk.take(left.length)), f)), Either.right(pipe(right, Chunk.drop(left.length)))];\n};\n// Do notation\n/** @internal */\nexport const Do = /*#__PURE__*/succeed({});\n/** @internal */\nexport const bind = /*#__PURE__*/dual(args => typeof args[0] !== \"string\", (self, tag, f, options) => flatMap(self, k => map(f(k), a => ({\n  ...k,\n  [tag]: a\n})), options));\n/* @internal */\nexport const bindTo = /*#__PURE__*/doNotation.bindTo(map);\n/* @internal */\nexport const let_ = /*#__PURE__*/doNotation.let_(map);\n// Circular with Channel\n/** @internal */\nexport const channelToStream = self => {\n  return new StreamImpl(self);\n};\n// =============================================================================\n// encoding\n// =============================================================================\n/** @internal */\nexport const decodeText = /*#__PURE__*/dual(args => isStream(args[0]), (self, encoding = \"utf-8\") => suspend(() => {\n  const decoder = new TextDecoder(encoding);\n  return map(self, s => decoder.decode(s));\n}));\n/** @internal */\nexport const encodeText = self => suspend(() => {\n  const encoder = new TextEncoder();\n  return map(self, s => encoder.encode(s));\n});\n/** @internal */\nexport const fromEventListener = (target, type, options) => asyncPush(emit => Effect.acquireRelease(Effect.sync(() => target.addEventListener(type, emit.single, options)), () => Effect.sync(() => target.removeEventListener(type, emit.single, options))), {\n  bufferSize: typeof options === \"object\" ? options.bufferSize : undefined\n});\n//# sourceMappingURL=stream.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628651,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628706,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
