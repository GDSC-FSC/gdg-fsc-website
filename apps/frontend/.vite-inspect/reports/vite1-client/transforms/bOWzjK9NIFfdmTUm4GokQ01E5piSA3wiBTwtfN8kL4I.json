{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/logger.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport * as Context from \"../Context.js\";\nimport * as FiberRefs from \"../FiberRefs.js\";\nimport { constVoid, dual } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as Inspectable from \"../Inspectable.js\";\nimport * as List from \"../List.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Cause from \"./cause.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport { consoleTag } from \"./defaultServices/console.js\";\nimport * as fiberId_ from \"./fiberId.js\";\nimport * as logSpan_ from \"./logSpan.js\";\n/** @internal */\nconst LoggerSymbolKey = \"effect/Logger\";\n/** @internal */\nexport const LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);\nconst loggerVariance = {\n  /* c8 ignore next */\n  _Message: _ => _,\n  /* c8 ignore next */\n  _Output: _ => _\n};\n/** @internal */\nexport const makeLogger = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/** @internal */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => self.log({\n  ...options,\n  message: f(options.message)\n})));\n/** @internal */\nexport const mapInputOptions = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => self.log(f(options))));\n/** @internal */\nexport const filterLogLevel = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(options.logLevel) ? Option.some(self.log(options)) : Option.none()));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(self.log(options))));\n/** @internal */\nexport const none = {\n  [LoggerTypeId]: loggerVariance,\n  log: constVoid,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const simple = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log: ({\n    message\n  }) => log(message),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/** @internal */\nexport const succeed = value => {\n  return simple(() => value);\n};\n/** @internal */\nexport const sync = evaluate => {\n  return simple(evaluate);\n};\n/** @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => makeLogger(options => [self.log(options), that.log(options)]));\n/** @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[0]));\n/** @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[1]));\n/**\n * Match strings that do not contain any whitespace characters, double quotes,\n * or equal signs.\n *\n * @internal\n */\nconst textOnly = /^[^\\s\"=]*$/;\n/**\n * Used by both {@link stringLogger} and {@link logfmtLogger} to render a log\n * message.\n *\n * @internal\n */\nconst format = (quoteValue, whitespace) => ({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const formatValue = value => value.match(textOnly) ? value : quoteValue(value);\n  const format = (label, value) => `${logSpan_.formatLabel(label)}=${formatValue(value)}`;\n  const append = (label, value) => \" \" + format(label, value);\n  let out = format(\"timestamp\", date.toISOString());\n  out += append(\"level\", logLevel.label);\n  out += append(\"fiber\", fiberId_.threadName(fiberId));\n  const messages = Arr.ensure(message);\n  for (let i = 0; i < messages.length; i++) {\n    out += append(\"message\", Inspectable.toStringUnknown(messages[i], whitespace));\n  }\n  if (!Cause.isEmptyType(cause)) {\n    out += append(\"cause\", Cause.pretty(cause, {\n      renderErrorCause: true\n    }));\n  }\n  for (const span of spans) {\n    out += \" \" + logSpan_.render(date.getTime())(span);\n  }\n  for (const [label, value] of annotations) {\n    out += append(label, Inspectable.toStringUnknown(value, whitespace));\n  }\n  return out;\n};\n/** @internal */\nconst escapeDoubleQuotes = s => `\"${s.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`;\n/** @internal */\nexport const stringLogger = /*#__PURE__*/makeLogger(/*#__PURE__*/format(escapeDoubleQuotes));\n/** @internal */\nexport const logfmtLogger = /*#__PURE__*/makeLogger(/*#__PURE__*/format(JSON.stringify, 0));\n/** @internal */\nexport const structuredLogger = /*#__PURE__*/makeLogger(({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const now = date.getTime();\n  const annotationsObj = {};\n  const spansObj = {};\n  if (HashMap.size(annotations) > 0) {\n    for (const [k, v] of annotations) {\n      annotationsObj[k] = structuredMessage(v);\n    }\n  }\n  if (List.isCons(spans)) {\n    for (const span of spans) {\n      spansObj[span.label] = now - span.startTime;\n    }\n  }\n  const messageArr = Arr.ensure(message);\n  return {\n    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),\n    logLevel: logLevel.label,\n    timestamp: date.toISOString(),\n    cause: Cause.isEmpty(cause) ? undefined : Cause.pretty(cause, {\n      renderErrorCause: true\n    }),\n    annotations: annotationsObj,\n    spans: spansObj,\n    fiberId: fiberId_.threadName(fiberId)\n  };\n});\n/** @internal */\nexport const structuredMessage = u => {\n  switch (typeof u) {\n    case \"bigint\":\n    case \"function\":\n    case \"symbol\":\n      {\n        return String(u);\n      }\n    default:\n      {\n        return Inspectable.toJSON(u);\n      }\n  }\n};\n/** @internal */\nexport const jsonLogger = /*#__PURE__*/map(structuredLogger, Inspectable.stringifyCircular);\n/** @internal */\nexport const isLogger = u => {\n  return typeof u === \"object\" && u != null && LoggerTypeId in u;\n};\nconst withColor = (text, ...colors) => {\n  let out = \"\";\n  for (let i = 0; i < colors.length; i++) {\n    out += `\\x1b[${colors[i]}m`;\n  }\n  return out + text + \"\\x1b[0m\";\n};\nconst withColorNoop = (text, ..._colors) => text;\nconst colors = {\n  bold: \"1\",\n  red: \"31\",\n  green: \"32\",\n  yellow: \"33\",\n  blue: \"34\",\n  cyan: \"36\",\n  white: \"37\",\n  gray: \"90\",\n  black: \"30\",\n  bgBrightRed: \"101\"\n};\nconst logLevelColors = {\n  None: [],\n  All: [],\n  Trace: [colors.gray],\n  Debug: [colors.blue],\n  Info: [colors.green],\n  Warning: [colors.yellow],\n  Error: [colors.red],\n  Fatal: [colors.bgBrightRed, colors.black]\n};\nconst logLevelStyle = {\n  None: \"\",\n  All: \"\",\n  Trace: \"color:gray\",\n  Debug: \"color:blue\",\n  Info: \"color:green\",\n  Warning: \"color:orange\",\n  Error: \"color:red\",\n  Fatal: \"background-color:red;color:white\"\n};\nconst defaultDateFormat = date => `${date.getHours().toString().padStart(2, \"0\")}:${date.getMinutes().toString().padStart(2, \"0\")}:${date.getSeconds().toString().padStart(2, \"0\")}.${date.getMilliseconds().toString().padStart(3, \"0\")}`;\nconst hasProcessStdout = typeof process === \"object\" && process !== null && typeof process.stdout === \"object\" && process.stdout !== null;\nconst processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;\nconst hasProcessStdoutOrDeno = hasProcessStdout || \"Deno\" in globalThis;\n/** @internal */\nexport const prettyLogger = options => {\n  const mode_ = options?.mode ?? \"auto\";\n  const mode = mode_ === \"auto\" ? hasProcessStdoutOrDeno ? \"tty\" : \"browser\" : mode_;\n  const isBrowser = mode === \"browser\";\n  const showColors = typeof options?.colors === \"boolean\" ? options.colors : processStdoutIsTTY || isBrowser;\n  const formatDate = options?.formatDate ?? defaultDateFormat;\n  return isBrowser ? prettyLoggerBrowser({\n    colors: showColors,\n    formatDate\n  }) : prettyLoggerTty({\n    colors: showColors,\n    formatDate,\n    stderr: options?.stderr === true\n  });\n};\nconst prettyLoggerTty = options => {\n  const color = options.colors ? withColor : withColorNoop;\n  return makeLogger(({\n    annotations,\n    cause,\n    context,\n    date,\n    fiberId,\n    logLevel,\n    message: message_,\n    spans\n  }) => {\n    const services = FiberRefs.getOrDefault(context, defaultServices.currentServices);\n    const console = Context.get(services, consoleTag).unsafe;\n    const log = options.stderr === true ? console.error : console.log;\n    const message = Arr.ensure(message_);\n    let firstLine = color(`[${options.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}` + ` (${fiberId_.threadName(fiberId)})`;\n    if (List.isCons(spans)) {\n      const now = date.getTime();\n      const render = logSpan_.render(now);\n      for (const span of spans) {\n        firstLine += \" \" + render(span);\n      }\n    }\n    firstLine += \":\";\n    let messageIndex = 0;\n    if (message.length > 0) {\n      const firstMaybeString = structuredMessage(message[0]);\n      if (typeof firstMaybeString === \"string\") {\n        firstLine += \" \" + color(firstMaybeString, colors.bold, colors.cyan);\n        messageIndex++;\n      }\n    }\n    log(firstLine);\n    console.group();\n    if (!Cause.isEmpty(cause)) {\n      log(Cause.pretty(cause, {\n        renderErrorCause: true\n      }));\n    }\n    if (messageIndex < message.length) {\n      for (; messageIndex < message.length; messageIndex++) {\n        log(Inspectable.redact(message[messageIndex]));\n      }\n    }\n    if (HashMap.size(annotations) > 0) {\n      for (const [key, value] of annotations) {\n        log(color(`${key}:`, colors.bold, colors.white), Inspectable.redact(value));\n      }\n    }\n    console.groupEnd();\n  });\n};\nconst prettyLoggerBrowser = options => {\n  const color = options.colors ? \"%c\" : \"\";\n  return makeLogger(({\n    annotations,\n    cause,\n    context,\n    date,\n    fiberId,\n    logLevel,\n    message: message_,\n    spans\n  }) => {\n    const services = FiberRefs.getOrDefault(context, defaultServices.currentServices);\n    const console = Context.get(services, consoleTag).unsafe;\n    const message = Arr.ensure(message_);\n    let firstLine = `${color}[${options.formatDate(date)}]`;\n    const firstParams = [];\n    if (options.colors) {\n      firstParams.push(\"color:gray\");\n    }\n    firstLine += ` ${color}${logLevel.label}${color} (${fiberId_.threadName(fiberId)})`;\n    if (options.colors) {\n      firstParams.push(logLevelStyle[logLevel._tag], \"\");\n    }\n    if (List.isCons(spans)) {\n      const now = date.getTime();\n      const render = logSpan_.render(now);\n      for (const span of spans) {\n        firstLine += \" \" + render(span);\n      }\n    }\n    firstLine += \":\";\n    let messageIndex = 0;\n    if (message.length > 0) {\n      const firstMaybeString = structuredMessage(message[0]);\n      if (typeof firstMaybeString === \"string\") {\n        firstLine += ` ${color}${firstMaybeString}`;\n        if (options.colors) {\n          firstParams.push(\"color:deepskyblue\");\n        }\n        messageIndex++;\n      }\n    }\n    console.groupCollapsed(firstLine, ...firstParams);\n    if (!Cause.isEmpty(cause)) {\n      console.error(Cause.pretty(cause, {\n        renderErrorCause: true\n      }));\n    }\n    if (messageIndex < message.length) {\n      for (; messageIndex < message.length; messageIndex++) {\n        console.log(Inspectable.redact(message[messageIndex]));\n      }\n    }\n    if (HashMap.size(annotations) > 0) {\n      for (const [key, value] of annotations) {\n        const redacted = Inspectable.redact(value);\n        if (options.colors) {\n          console.log(`%c${key}:`, \"color:gray\", redacted);\n        } else {\n          console.log(`${key}:`, redacted);\n        }\n      }\n    }\n    console.groupEnd();\n  });\n};\n/** @internal */\nexport const prettyLoggerDefault = /*#__PURE__*/globalValue(\"effect/Logger/prettyLoggerDefault\", () => prettyLogger());\n//# sourceMappingURL=logger.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628703,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
