{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/fiberRuntime.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as RA from \"../Array.js\";\nimport * as Boolean from \"../Boolean.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Context from \"../Context.js\";\nimport * as Effectable from \"../Effectable.js\";\nimport * as ExecutionStrategy from \"../ExecutionStrategy.js\";\nimport * as FiberId from \"../FiberId.js\";\nimport * as FiberRefs from \"../FiberRefs.js\";\nimport * as FiberRefsPatch from \"../FiberRefsPatch.js\";\nimport * as FiberStatus from \"../FiberStatus.js\";\nimport { dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport * as Inspectable from \"../Inspectable.js\";\nimport * as LogLevel from \"../LogLevel.js\";\nimport * as Micro from \"../Micro.js\";\nimport * as MRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Predicate from \"../Predicate.js\";\nimport * as Ref from \"../Ref.js\";\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\";\nimport { currentScheduler } from \"../Scheduler.js\";\nimport { internalCall, yieldWrapGet } from \"../Utils.js\";\nimport * as RequestBlock_ from \"./blockedRequests.js\";\nimport * as internalCause from \"./cause.js\";\nimport * as clock from \"./clock.js\";\nimport { currentRequestMap } from \"./completedRequestMap.js\";\nimport * as concurrency from \"./concurrency.js\";\nimport { configProviderTag } from \"./configProvider.js\";\nimport * as internalEffect from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport { consoleTag } from \"./defaultServices/console.js\";\nimport * as executionStrategy from \"./executionStrategy.js\";\nimport * as internalFiber from \"./fiber.js\";\nimport * as FiberMessage from \"./fiberMessage.js\";\nimport * as fiberRefs from \"./fiberRefs.js\";\nimport * as fiberScope from \"./fiberScope.js\";\nimport * as internalLogger from \"./logger.js\";\nimport * as metric from \"./metric.js\";\nimport * as metricBoundaries from \"./metric/boundaries.js\";\nimport * as metricLabel from \"./metric/label.js\";\nimport * as OpCodes from \"./opCodes/effect.js\";\nimport { randomTag } from \"./random.js\";\nimport { complete } from \"./request.js\";\nimport * as runtimeFlags_ from \"./runtimeFlags.js\";\nimport { OpSupervision } from \"./runtimeFlags.js\";\nimport * as supervisor from \"./supervisor.js\";\nimport * as SupervisorPatch from \"./supervisor/patch.js\";\nimport * as tracer from \"./tracer.js\";\nimport * as version from \"./version.js\";\n/** @internal */\nexport const fiberStarted = /*#__PURE__*/metric.counter(\"effect_fiber_started\", {\n  incremental: true\n});\n/** @internal */\nexport const fiberActive = /*#__PURE__*/metric.counter(\"effect_fiber_active\");\n/** @internal */\nexport const fiberSuccesses = /*#__PURE__*/metric.counter(\"effect_fiber_successes\", {\n  incremental: true\n});\n/** @internal */\nexport const fiberFailures = /*#__PURE__*/metric.counter(\"effect_fiber_failures\", {\n  incremental: true\n});\n/** @internal */\nexport const fiberLifetimes = /*#__PURE__*/metric.tagged(/*#__PURE__*/metric.histogram(\"effect_fiber_lifetimes\", /*#__PURE__*/metricBoundaries.exponential({\n  start: 0.5,\n  factor: 2,\n  count: 35\n})), \"time_unit\", \"milliseconds\");\n/** @internal */\nconst EvaluationSignalContinue = \"Continue\";\n/** @internal */\nconst EvaluationSignalDone = \"Done\";\n/** @internal */\nconst EvaluationSignalYieldNow = \"Yield\";\nconst runtimeFiberVariance = {\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _\n};\nconst absurd = _ => {\n  throw new Error(`BUG: FiberRuntime - ${Inspectable.toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);\n};\nconst YieldedOp = /*#__PURE__*/Symbol.for(\"effect/internal/fiberRuntime/YieldedOp\");\nconst yieldedOpChannel = /*#__PURE__*/globalValue(\"effect/internal/fiberRuntime/yieldedOpChannel\", () => ({\n  currentOp: null\n}));\nconst contOpSuccess = {\n  [OpCodes.OP_ON_SUCCESS]: (_, cont, value) => {\n    return internalCall(() => cont.effect_instruction_i1(value));\n  },\n  [\"OnStep\"]: (_, _cont, value) => {\n    return core.exitSucceed(core.exitSucceed(value));\n  },\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {\n    return internalCall(() => cont.effect_instruction_i2(value));\n  },\n  [OpCodes.OP_REVERT_FLAGS]: (self, cont, value) => {\n    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);\n    if (runtimeFlags_.interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {\n      return core.exitFailCause(self.getInterruptedCause());\n    } else {\n      return core.exitSucceed(value);\n    }\n  },\n  [OpCodes.OP_WHILE]: (self, cont, value) => {\n    internalCall(() => cont.effect_instruction_i2(value));\n    if (internalCall(() => cont.effect_instruction_i0())) {\n      self.pushStack(cont);\n      return internalCall(() => cont.effect_instruction_i1());\n    } else {\n      return core.void;\n    }\n  },\n  [OpCodes.OP_ITERATOR]: (self, cont, value) => {\n    while (true) {\n      const state = internalCall(() => cont.effect_instruction_i0.next(value));\n      if (state.done) {\n        return core.exitSucceed(state.value);\n      }\n      const primitive = yieldWrapGet(state.value);\n      if (!core.exitIsExit(primitive)) {\n        self.pushStack(cont);\n        return primitive;\n      } else if (primitive._tag === \"Failure\") {\n        return primitive;\n      }\n      value = primitive.value;\n    }\n  }\n};\nconst drainQueueWhileRunningTable = {\n  [FiberMessage.OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {\n    self.processNewInterruptSignal(message.cause);\n    return runtimeFlags_.interruptible(runtimeFlags) ? core.exitFailCause(message.cause) : cur;\n  },\n  [FiberMessage.OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {\n    throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\");\n  },\n  [FiberMessage.OP_STATEFUL]: (self, runtimeFlags, cur, message) => {\n    message.onFiber(self, FiberStatus.running(runtimeFlags));\n    return cur;\n  },\n  [FiberMessage.OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {\n    return core.flatMap(core.yieldNow(), () => cur);\n  }\n};\n/**\n * Executes all requests, submitting requests to each data source in parallel.\n */\nconst runBlockedRequests = self => core.forEachSequentialDiscard(RequestBlock_.flatten(self), requestsByRequestResolver => forEachConcurrentDiscard(RequestBlock_.sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential]) => {\n  const map = new Map();\n  const arr = [];\n  for (const block of sequential) {\n    arr.push(Chunk.toReadonlyArray(block));\n    for (const entry of block) {\n      map.set(entry.request, entry);\n    }\n  }\n  const flat = arr.flat();\n  return core.fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach(entry => {\n    entry.listeners.interrupted = true;\n  })), currentRequestMap, map);\n}, false, false));\nconst _version = /*#__PURE__*/version.getCurrentVersion();\n/** @internal */\nexport class FiberRuntime extends Effectable.Class {\n  [internalFiber.FiberTypeId] = internalFiber.fiberVariance;\n  [internalFiber.RuntimeFiberTypeId] = runtimeFiberVariance;\n  _fiberRefs;\n  _fiberId;\n  _queue = /*#__PURE__*/new Array();\n  _children = null;\n  _observers = /*#__PURE__*/new Array();\n  _running = false;\n  _stack = [];\n  _asyncInterruptor = null;\n  _asyncBlockingOn = null;\n  _exitValue = null;\n  _steps = [];\n  _isYielding = false;\n  currentRuntimeFlags;\n  currentOpCount = 0;\n  currentSupervisor;\n  currentScheduler;\n  currentTracer;\n  currentSpan;\n  currentContext;\n  currentDefaultServices;\n  constructor(fiberId, fiberRefs0, runtimeFlags0) {\n    super();\n    this.currentRuntimeFlags = runtimeFlags0;\n    this._fiberId = fiberId;\n    this._fiberRefs = fiberRefs0;\n    if (runtimeFlags_.runtimeMetrics(runtimeFlags0)) {\n      const tags = this.getFiberRef(core.currentMetricLabels);\n      fiberStarted.unsafeUpdate(1, tags);\n      fiberActive.unsafeUpdate(1, tags);\n    }\n    this.refreshRefCache();\n  }\n  commit() {\n    return internalFiber.join(this);\n  }\n  /**\n   * The identity of the fiber.\n   */\n  id() {\n    return this._fiberId;\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */\n  resume(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * The status of the fiber.\n   */\n  get status() {\n    return this.ask((_, status) => status);\n  }\n  /**\n   * Gets the fiber runtime flags.\n   */\n  get runtimeFlags() {\n    return this.ask((state, status) => {\n      if (FiberStatus.isDone(status)) {\n        return state.currentRuntimeFlags;\n      }\n      return status.runtimeFlags;\n    });\n  }\n  /**\n   * Returns the current `FiberScope` for the fiber.\n   */\n  scope() {\n    return fiberScope.unsafeMake(this);\n  }\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  get children() {\n    return this.ask(fiber => Array.from(fiber.getChildren()));\n  }\n  /**\n   * Gets the fiber's set of children.\n   */\n  getChildren() {\n    if (this._children === null) {\n      this._children = new Set();\n    }\n    return this._children;\n  }\n  /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getInterruptedCause() {\n    return this.getFiberRef(core.currentInterruptedCause);\n  }\n  /**\n   * Retrieves the whole set of fiber refs.\n   */\n  fiberRefs() {\n    return this.ask(fiber => fiber.getFiberRefs());\n  }\n  /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */\n  ask(f) {\n    return core.suspend(() => {\n      const deferred = core.deferredUnsafeMake(this._fiberId);\n      this.tell(FiberMessage.stateful((fiber, status) => {\n        core.deferredUnsafeDone(deferred, core.sync(() => f(fiber, status)));\n      }));\n      return core.deferredAwait(deferred);\n    });\n  }\n  /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */\n  tell(message) {\n    this._queue.push(message);\n    if (!this._running) {\n      this._running = true;\n      this.drainQueueLaterOnExecutor();\n    }\n  }\n  get await() {\n    return core.async(resume => {\n      const cb = exit => resume(core.succeed(exit));\n      this.tell(FiberMessage.stateful((fiber, _) => {\n        if (fiber._exitValue !== null) {\n          cb(this._exitValue);\n        } else {\n          fiber.addObserver(cb);\n        }\n      }));\n      return core.sync(() => this.tell(FiberMessage.stateful((fiber, _) => {\n        fiber.removeObserver(cb);\n      })));\n    }, this.id());\n  }\n  get inheritAll() {\n    return core.withFiberRuntime((parentFiber, parentStatus) => {\n      const parentFiberId = parentFiber.id();\n      const parentFiberRefs = parentFiber.getFiberRefs();\n      const parentRuntimeFlags = parentStatus.runtimeFlags;\n      const childFiberRefs = this.getFiberRefs();\n      const updatedFiberRefs = fiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs);\n      parentFiber.setFiberRefs(updatedFiberRefs);\n      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);\n      const patch = pipe(runtimeFlags_.diff(parentRuntimeFlags, updatedRuntimeFlags),\n      // Do not inherit WindDown or Interruption!\n      RuntimeFlagsPatch.exclude(runtimeFlags_.Interruption), RuntimeFlagsPatch.exclude(runtimeFlags_.WindDown));\n      return core.updateRuntimeFlags(patch);\n    });\n  }\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  get poll() {\n    return core.sync(() => Option.fromNullable(this._exitValue));\n  }\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll() {\n    return this._exitValue;\n  }\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  interruptAsFork(fiberId) {\n    return core.sync(() => this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId))));\n  }\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  unsafeInterruptAsFork(fiberId) {\n    this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId)));\n  }\n  /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addObserver(observer) {\n    if (this._exitValue !== null) {\n      observer(this._exitValue);\n    } else {\n      this._observers.push(observer);\n    }\n  }\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeObserver(observer) {\n    this._observers = this._observers.filter(o => o !== observer);\n  }\n  /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRefs() {\n    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);\n    return this._fiberRefs;\n  }\n  /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeDeleteFiberRef(fiberRef) {\n    this._fiberRefs = fiberRefs.delete_(this._fiberRefs, fiberRef);\n  }\n  /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRef(fiberRef) {\n    if (this._fiberRefs.locals.has(fiberRef)) {\n      return this._fiberRefs.locals.get(fiberRef)[0][1];\n    }\n    return fiberRef.initial;\n  }\n  /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRef(fiberRef, value) {\n    this._fiberRefs = fiberRefs.updateAs(this._fiberRefs, {\n      fiberId: this._fiberId,\n      fiberRef,\n      value\n    });\n    this.refreshRefCache();\n  }\n  refreshRefCache() {\n    this.currentDefaultServices = this.getFiberRef(defaultServices.currentServices);\n    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracer.tracerTag.key);\n    this.currentSupervisor = this.getFiberRef(currentSupervisor);\n    this.currentScheduler = this.getFiberRef(currentScheduler);\n    this.currentContext = this.getFiberRef(core.currentContext);\n    this.currentSpan = this.currentContext.unsafeMap.get(tracer.spanTag.key);\n  }\n  /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRefs(fiberRefs) {\n    this._fiberRefs = fiberRefs;\n    this.refreshRefCache();\n  }\n  /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addChild(child) {\n    this.getChildren().add(child);\n  }\n  /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeChild(child) {\n    this.getChildren().delete(child);\n  }\n  /**\n   * Transfers all children of this fiber that are currently running to the\n   * specified fiber scope.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself after it has\n   * evaluated the effects but prior to exiting.\n   */\n  transferChildren(scope) {\n    const children = this._children;\n    // Clear the children of the current fiber\n    this._children = null;\n    if (children !== null && children.size > 0) {\n      for (const child of children) {\n        // If the child is still running, add it to the scope\n        if (child._exitValue === null) {\n          scope.add(this.currentRuntimeFlags, child);\n        }\n      }\n    }\n  }\n  /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueOnCurrentThread() {\n    let recurse = true;\n    while (recurse) {\n      let evaluationSignal = EvaluationSignalContinue;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        while (evaluationSignal === EvaluationSignalContinue) {\n          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);\n        }\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n      }\n      // Maybe someone added something to the queue between us checking, and us\n      // giving up the drain. If so, we need to restart the draining, but only\n      // if we beat everyone else to the restart:\n      if (this._queue.length > 0 && !this._running) {\n        this._running = true;\n        if (evaluationSignal === EvaluationSignalYieldNow) {\n          this.drainQueueLaterOnExecutor();\n          recurse = false;\n        } else {\n          recurse = true;\n        }\n      } else {\n        recurse = false;\n      }\n    }\n  }\n  /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueLaterOnExecutor() {\n    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(core.currentSchedulingPriority));\n  }\n  /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueWhileRunning(runtimeFlags, cur0) {\n    let cur = cur0;\n    while (this._queue.length > 0) {\n      const message = this._queue.splice(0, 1)[0];\n      // @ts-expect-error\n      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);\n    }\n    return cur;\n  }\n  /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  isInterrupted() {\n    return !internalCause.isEmpty(this.getFiberRef(core.currentInterruptedCause));\n  }\n  /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addInterruptedCause(cause) {\n    const oldSC = this.getFiberRef(core.currentInterruptedCause);\n    this.setFiberRef(core.currentInterruptedCause, internalCause.sequential(oldSC, cause));\n  }\n  /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  processNewInterruptSignal(cause) {\n    this.addInterruptedCause(cause);\n    this.sendInterruptSignalToAllChildren();\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  sendInterruptSignalToAllChildren() {\n    if (this._children === null || this._children.size === 0) {\n      return false;\n    }\n    let told = false;\n    for (const child of this._children) {\n      child.tell(FiberMessage.interruptSignal(internalCause.interrupt(this.id())));\n      told = true;\n    }\n    return told;\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  interruptAllChildren() {\n    if (this.sendInterruptSignalToAllChildren()) {\n      const it = this._children.values();\n      this._children = null;\n      let isDone = false;\n      const body = () => {\n        const next = it.next();\n        if (!next.done) {\n          return core.asVoid(next.value.await);\n        } else {\n          return core.sync(() => {\n            isDone = true;\n          });\n        }\n      };\n      return core.whileLoop({\n        while: () => !isDone,\n        body,\n        step: () => {\n          //\n        }\n      });\n    }\n    return null;\n  }\n  reportExitValue(exit) {\n    if (runtimeFlags_.runtimeMetrics(this.currentRuntimeFlags)) {\n      const tags = this.getFiberRef(core.currentMetricLabels);\n      const startTimeMillis = this.id().startTimeMillis;\n      const endTimeMillis = Date.now();\n      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);\n      fiberActive.unsafeUpdate(-1, tags);\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS:\n          {\n            fiberSuccesses.unsafeUpdate(1, tags);\n            break;\n          }\n        case OpCodes.OP_FAILURE:\n          {\n            fiberFailures.unsafeUpdate(1, tags);\n            break;\n          }\n      }\n    }\n    if (exit._tag === \"Failure\") {\n      const level = this.getFiberRef(core.currentUnhandledErrorLogLevel);\n      if (!internalCause.isInterruptedOnly(exit.cause) && level._tag === \"Some\") {\n        this.log(\"Fiber terminated with an unhandled error\", exit.cause, level);\n      }\n    }\n  }\n  setExitValue(exit) {\n    this._exitValue = exit;\n    this.reportExitValue(exit);\n    for (let i = this._observers.length - 1; i >= 0; i--) {\n      this._observers[i](exit);\n    }\n    this._observers = [];\n  }\n  getLoggers() {\n    return this.getFiberRef(currentLoggers);\n  }\n  log(message, cause, overrideLogLevel) {\n    const logLevel = Option.isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(core.currentLogLevel);\n    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);\n    if (LogLevel.greaterThan(minimumLogLevel, logLevel)) {\n      return;\n    }\n    const spans = this.getFiberRef(core.currentLogSpan);\n    const annotations = this.getFiberRef(core.currentLogAnnotations);\n    const loggers = this.getLoggers();\n    const contextMap = this.getFiberRefs();\n    if (HashSet.size(loggers) > 0) {\n      const clockService = Context.get(this.getFiberRef(defaultServices.currentServices), clock.clockTag);\n      const date = new Date(clockService.unsafeCurrentTimeMillis());\n      Inspectable.withRedactableContext(contextMap, () => {\n        for (const logger of loggers) {\n          logger.log({\n            fiberId: this.id(),\n            logLevel,\n            message,\n            cause,\n            context: contextMap,\n            spans,\n            annotations,\n            date\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateMessageWhileSuspended(message) {\n    switch (message._tag) {\n      case FiberMessage.OP_YIELD_NOW:\n        {\n          return EvaluationSignalYieldNow;\n        }\n      case FiberMessage.OP_INTERRUPT_SIGNAL:\n        {\n          this.processNewInterruptSignal(message.cause);\n          if (this._asyncInterruptor !== null) {\n            this._asyncInterruptor(core.exitFailCause(message.cause));\n            this._asyncInterruptor = null;\n          }\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_RESUME:\n        {\n          this._asyncInterruptor = null;\n          this._asyncBlockingOn = null;\n          this.evaluateEffect(message.effect);\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_STATEFUL:\n        {\n          message.onFiber(this, this._exitValue !== null ? FiberStatus.done : FiberStatus.suspended(this.currentRuntimeFlags, this._asyncBlockingOn));\n          return EvaluationSignalContinue;\n        }\n      default:\n        {\n          return absurd(message);\n        }\n    }\n  }\n  /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateEffect(effect0) {\n    this.currentSupervisor.onResume(this);\n    try {\n      let effect = runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? core.exitFailCause(this.getInterruptedCause()) : effect0;\n      while (effect !== null) {\n        const eff = effect;\n        const exit = this.runLoop(eff);\n        if (exit === YieldedOp) {\n          const op = yieldedOpChannel.currentOp;\n          yieldedOpChannel.currentOp = null;\n          if (op._op === OpCodes.OP_YIELD) {\n            if (runtimeFlags_.cooperativeYielding(this.currentRuntimeFlags)) {\n              this.tell(FiberMessage.yieldNow());\n              this.tell(FiberMessage.resume(core.exitVoid));\n              effect = null;\n            } else {\n              effect = core.exitVoid;\n            }\n          } else if (op._op === OpCodes.OP_ASYNC) {\n            // Terminate this evaluation, async resumption will continue evaluation:\n            effect = null;\n          }\n        } else {\n          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, runtimeFlags_.enable(runtimeFlags_.WindDown));\n          const interruption = this.interruptAllChildren();\n          if (interruption !== null) {\n            effect = core.flatMap(interruption, () => exit);\n          } else {\n            if (this._queue.length === 0) {\n              // No more messages to process, so we will allow the fiber to end life:\n              this.setExitValue(exit);\n            } else {\n              // There are messages, possibly added by the final op executed by\n              // the fiber. To be safe, we should execute those now before we\n              // allow the fiber to end life:\n              this.tell(FiberMessage.resume(exit));\n            }\n            effect = null;\n          }\n        }\n      }\n    } finally {\n      this.currentSupervisor.onSuspend(this);\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */\n  start(effect) {\n    if (!this._running) {\n      this._running = true;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        this.evaluateEffect(effect);\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n        // Because we're special casing `start`, we have to be responsible\n        // for spinning up the fiber if there were new messages added to\n        // the queue between the completion of the effect and the transition\n        // to the not running state.\n        if (this._queue.length > 0) {\n          this.drainQueueLaterOnExecutor();\n        }\n      }\n    } else {\n      this.tell(FiberMessage.resume(effect));\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */\n  startFork(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  patchRuntimeFlags(oldRuntimeFlags, patch) {\n    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, patch);\n    globalThis[internalFiber.currentFiberURI] = this;\n    this.currentRuntimeFlags = newRuntimeFlags;\n    return newRuntimeFlags;\n  }\n  /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  initiateAsync(runtimeFlags, asyncRegister) {\n    let alreadyCalled = false;\n    const callback = effect => {\n      if (!alreadyCalled) {\n        alreadyCalled = true;\n        this.tell(FiberMessage.resume(effect));\n      }\n    };\n    if (runtimeFlags_.interruptible(runtimeFlags)) {\n      this._asyncInterruptor = callback;\n    }\n    try {\n      asyncRegister(callback);\n    } catch (e) {\n      callback(core.failCause(internalCause.die(e)));\n    }\n  }\n  pushStack(cont) {\n    this._stack.push(cont);\n    if (cont._op === \"OnStep\") {\n      this._steps.push({\n        refs: this.getFiberRefs(),\n        flags: this.currentRuntimeFlags\n      });\n    }\n  }\n  popStack() {\n    const item = this._stack.pop();\n    if (item) {\n      if (item._op === \"OnStep\") {\n        this._steps.pop();\n      }\n      return item;\n    }\n    return;\n  }\n  getNextSuccessCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._op !== OpCodes.OP_ON_FAILURE) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  getNextFailCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._op !== OpCodes.OP_ON_SUCCESS && frame._op !== OpCodes.OP_WHILE && frame._op !== OpCodes.OP_ITERATOR) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  [OpCodes.OP_TAG](op) {\n    return core.sync(() => Context.unsafeGet(this.currentContext, op));\n  }\n  [\"Left\"](op) {\n    return core.fail(op.left);\n  }\n  [\"None\"](_) {\n    return core.fail(new core.NoSuchElementException());\n  }\n  [\"Right\"](op) {\n    return core.exitSucceed(op.right);\n  }\n  [\"Some\"](op) {\n    return core.exitSucceed(op.value);\n  }\n  [\"Micro\"](op) {\n    return core.unsafeAsync(microResume => {\n      let resume = microResume;\n      const fiber = Micro.runFork(Micro.provideContext(op, this.currentContext));\n      fiber.addObserver(exit => {\n        if (exit._tag === \"Success\") {\n          return resume(core.exitSucceed(exit.value));\n        }\n        switch (exit.cause._tag) {\n          case \"Interrupt\":\n            {\n              return resume(core.exitFailCause(internalCause.interrupt(FiberId.none)));\n            }\n          case \"Fail\":\n            {\n              return resume(core.fail(exit.cause.error));\n            }\n          case \"Die\":\n            {\n              return resume(core.die(exit.cause.defect));\n            }\n        }\n      });\n      return core.unsafeAsync(abortResume => {\n        resume = _ => {\n          abortResume(core.void);\n        };\n        fiber.unsafeInterrupt();\n      });\n    });\n  }\n  [OpCodes.OP_SYNC](op) {\n    const value = internalCall(() => op.effect_instruction_i0());\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, value);\n    } else {\n      yieldedOpChannel.currentOp = core.exitSucceed(value);\n      return YieldedOp;\n    }\n  }\n  [OpCodes.OP_SUCCESS](op) {\n    const oldCur = op;\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);\n    } else {\n      yieldedOpChannel.currentOp = oldCur;\n      return YieldedOp;\n    }\n  }\n  [OpCodes.OP_FAILURE](op) {\n    const cause = op.effect_instruction_i0;\n    const cont = this.getNextFailCont();\n    if (cont !== undefined) {\n      switch (cont._op) {\n        case OpCodes.OP_ON_FAILURE:\n        case OpCodes.OP_ON_SUCCESS_AND_FAILURE:\n          {\n            if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {\n              return internalCall(() => cont.effect_instruction_i1(cause));\n            } else {\n              return core.exitFailCause(internalCause.stripFailures(cause));\n            }\n          }\n        case \"OnStep\":\n          {\n            if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {\n              return core.exitSucceed(core.exitFailCause(cause));\n            } else {\n              return core.exitFailCause(internalCause.stripFailures(cause));\n            }\n          }\n        case OpCodes.OP_REVERT_FLAGS:\n          {\n            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);\n            if (runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {\n              return core.exitFailCause(internalCause.sequential(cause, this.getInterruptedCause()));\n            } else {\n              return core.exitFailCause(cause);\n            }\n          }\n        default:\n          {\n            absurd(cont);\n          }\n      }\n    } else {\n      yieldedOpChannel.currentOp = core.exitFailCause(cause);\n      return YieldedOp;\n    }\n  }\n  [OpCodes.OP_WITH_RUNTIME](op) {\n    return internalCall(() => op.effect_instruction_i0(this, FiberStatus.running(this.currentRuntimeFlags)));\n  }\n  [\"Blocked\"](op) {\n    const refs = this.getFiberRefs();\n    const flags = this.currentRuntimeFlags;\n    if (this._steps.length > 0) {\n      const frames = [];\n      const snap = this._steps[this._steps.length - 1];\n      let frame = this.popStack();\n      while (frame && frame._op !== \"OnStep\") {\n        frames.push(frame);\n        frame = this.popStack();\n      }\n      this.setFiberRefs(snap.refs);\n      this.currentRuntimeFlags = snap.flags;\n      const patchRefs = FiberRefsPatch.diff(snap.refs, refs);\n      const patchFlags = runtimeFlags_.diff(snap.flags, flags);\n      return core.exitSucceed(core.blocked(op.effect_instruction_i0, core.withFiberRuntime(newFiber => {\n        while (frames.length > 0) {\n          newFiber.pushStack(frames.pop());\n        }\n        newFiber.setFiberRefs(FiberRefsPatch.patch(newFiber.id(), newFiber.getFiberRefs())(patchRefs));\n        newFiber.currentRuntimeFlags = runtimeFlags_.patch(patchFlags)(newFiber.currentRuntimeFlags);\n        return op.effect_instruction_i1;\n      })));\n    }\n    return core.uninterruptibleMask(restore => core.flatMap(forkDaemon(core.runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));\n  }\n  [\"RunBlocked\"](op) {\n    return runBlockedRequests(op.effect_instruction_i0);\n  }\n  [OpCodes.OP_UPDATE_RUNTIME_FLAGS](op) {\n    const updateFlags = op.effect_instruction_i0;\n    const oldRuntimeFlags = this.currentRuntimeFlags;\n    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, updateFlags);\n    // One more chance to short circuit: if we're immediately going\n    // to interrupt. Interruption will cause immediate reversion of\n    // the flag, so as long as we \"peek ahead\", there's no need to\n    // set them to begin with.\n    if (runtimeFlags_.interruptible(newRuntimeFlags) && this.isInterrupted()) {\n      return core.exitFailCause(this.getInterruptedCause());\n    } else {\n      // Impossible to short circuit, so record the changes\n      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);\n      if (op.effect_instruction_i1) {\n        // Since we updated the flags, we need to revert them\n        const revertFlags = runtimeFlags_.diff(newRuntimeFlags, oldRuntimeFlags);\n        this.pushStack(new core.RevertFlags(revertFlags, op));\n        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));\n      } else {\n        return core.exitVoid;\n      }\n    }\n  }\n  [OpCodes.OP_ON_SUCCESS](op) {\n    this.pushStack(op);\n    return op.effect_instruction_i0;\n  }\n  [\"OnStep\"](op) {\n    this.pushStack(op);\n    return op.effect_instruction_i0;\n  }\n  [OpCodes.OP_ON_FAILURE](op) {\n    this.pushStack(op);\n    return op.effect_instruction_i0;\n  }\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE](op) {\n    this.pushStack(op);\n    return op.effect_instruction_i0;\n  }\n  [OpCodes.OP_ASYNC](op) {\n    this._asyncBlockingOn = op.effect_instruction_i1;\n    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);\n    yieldedOpChannel.currentOp = op;\n    return YieldedOp;\n  }\n  [OpCodes.OP_YIELD](op) {\n    this._isYielding = false;\n    yieldedOpChannel.currentOp = op;\n    return YieldedOp;\n  }\n  [OpCodes.OP_WHILE](op) {\n    const check = op.effect_instruction_i0;\n    const body = op.effect_instruction_i1;\n    if (check()) {\n      this.pushStack(op);\n      return body();\n    } else {\n      return core.exitVoid;\n    }\n  }\n  [OpCodes.OP_ITERATOR](op) {\n    return contOpSuccess[OpCodes.OP_ITERATOR](this, op, undefined);\n  }\n  [OpCodes.OP_COMMIT](op) {\n    return internalCall(() => op.commit());\n  }\n  /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  runLoop(effect0) {\n    let cur = effect0;\n    this.currentOpCount = 0;\n    while (true) {\n      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {\n        this.currentSupervisor.onEffect(this, cur);\n      }\n      if (this._queue.length > 0) {\n        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);\n      }\n      if (!this._isYielding) {\n        this.currentOpCount += 1;\n        const shouldYield = this.currentScheduler.shouldYield(this);\n        if (shouldYield !== false) {\n          this._isYielding = true;\n          this.currentOpCount = 0;\n          const oldCur = cur;\n          cur = core.flatMap(core.yieldNow({\n            priority: shouldYield\n          }), () => oldCur);\n        }\n      }\n      try {\n        // @ts-expect-error\n        cur = this.currentTracer.context(() => {\n          if (_version !== cur[core.EffectTypeId]._V) {\n            const level = this.getFiberRef(core.currentVersionMismatchErrorLogLevel);\n            if (level._tag === \"Some\") {\n              const effectVersion = cur[core.EffectTypeId]._V;\n              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${version.getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, internalCause.empty, level);\n            }\n          }\n          // @ts-expect-error\n          return this[cur._op](cur);\n        }, this);\n        if (cur === YieldedOp) {\n          const op = yieldedOpChannel.currentOp;\n          if (op._op === OpCodes.OP_YIELD || op._op === OpCodes.OP_ASYNC) {\n            return YieldedOp;\n          }\n          yieldedOpChannel.currentOp = null;\n          return op._op === OpCodes.OP_SUCCESS || op._op === OpCodes.OP_FAILURE ? op : core.exitFailCause(internalCause.die(op));\n        }\n      } catch (e) {\n        if (cur !== YieldedOp && !Predicate.hasProperty(cur, \"_op\") || !(cur._op in this)) {\n          cur = core.dieMessage(`Not a valid effect: ${Inspectable.toStringUnknown(cur)}`);\n        } else if (core.isInterruptedException(e)) {\n          cur = core.exitFailCause(internalCause.sequential(internalCause.die(e), internalCause.interrupt(FiberId.none)));\n        } else {\n          cur = core.die(e);\n        }\n      }\n    }\n  }\n  run = () => {\n    this.drainQueueOnCurrentThread();\n  };\n}\n// circular with Logger\n/** @internal */\nexport const currentMinimumLogLevel = /*#__PURE__*/globalValue(\"effect/FiberRef/currentMinimumLogLevel\", () => core.fiberRefUnsafeMake(LogLevel.fromLiteral(\"Info\")));\n/** @internal */\nexport const loggerWithConsoleLog = self => internalLogger.makeLogger(opts => {\n  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices);\n  Context.get(services, consoleTag).unsafe.log(self.log(opts));\n});\n/** @internal */\nexport const loggerWithLeveledLog = self => internalLogger.makeLogger(opts => {\n  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices);\n  const unsafeLogger = Context.get(services, consoleTag).unsafe;\n  switch (opts.logLevel._tag) {\n    case \"Debug\":\n      return unsafeLogger.debug(self.log(opts));\n    case \"Info\":\n      return unsafeLogger.info(self.log(opts));\n    case \"Trace\":\n      return unsafeLogger.trace(self.log(opts));\n    case \"Warning\":\n      return unsafeLogger.warn(self.log(opts));\n    case \"Error\":\n    case \"Fatal\":\n      return unsafeLogger.error(self.log(opts));\n    default:\n      return unsafeLogger.log(self.log(opts));\n  }\n});\n/** @internal */\nexport const loggerWithConsoleError = self => internalLogger.makeLogger(opts => {\n  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices);\n  Context.get(services, consoleTag).unsafe.error(self.log(opts));\n});\n/** @internal */\nexport const defaultLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/defaultLogger\"), () => loggerWithConsoleLog(internalLogger.stringLogger));\n/** @internal */\nexport const jsonLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/jsonLogger\"), () => loggerWithConsoleLog(internalLogger.jsonLogger));\n/** @internal */\nexport const logFmtLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/logFmtLogger\"), () => loggerWithConsoleLog(internalLogger.logfmtLogger));\n/** @internal */\nexport const prettyLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/prettyLogger\"), () => internalLogger.prettyLoggerDefault);\n/** @internal */\nexport const structuredLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/structuredLogger\"), () => loggerWithConsoleLog(internalLogger.structuredLogger));\n/** @internal */\nexport const tracerLogger = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Logger/tracerLogger\"), () => internalLogger.makeLogger(({\n  annotations,\n  cause,\n  context,\n  fiberId,\n  logLevel,\n  message\n}) => {\n  const span = Context.getOption(fiberRefs.getOrDefault(context, core.currentContext), tracer.spanTag);\n  if (span._tag === \"None\" || span.value._tag === \"ExternalSpan\") {\n    return;\n  }\n  const clockService = Context.unsafeGet(fiberRefs.getOrDefault(context, defaultServices.currentServices), clock.clockTag);\n  const attributes = {};\n  for (const [key, value] of annotations) {\n    attributes[key] = value;\n  }\n  attributes[\"effect.fiberId\"] = FiberId.threadName(fiberId);\n  attributes[\"effect.logLevel\"] = logLevel.label;\n  if (cause !== null && cause._tag !== \"Empty\") {\n    attributes[\"effect.cause\"] = internalCause.pretty(cause, {\n      renderErrorCause: true\n    });\n  }\n  span.value.event(Inspectable.toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);\n}));\n/** @internal */\nexport const loggerWithSpanAnnotations = self => internalLogger.mapInputOptions(self, options => {\n  const span = Option.flatMap(fiberRefs.get(options.context, core.currentContext), Context.getOption(tracer.spanTag));\n  if (span._tag === \"None\") {\n    return options;\n  }\n  return {\n    ...options,\n    annotations: pipe(options.annotations, HashMap.set(\"effect.traceId\", span.value.traceId), HashMap.set(\"effect.spanId\", span.value.spanId), span.value._tag === \"Span\" ? HashMap.set(\"effect.spanName\", span.value.name) : identity)\n  };\n});\n/** @internal */\nexport const currentLoggers = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLoggers\"), () => core.fiberRefUnsafeMakeHashSet(HashSet.make(defaultLogger, tracerLogger)));\n/** @internal */\nexport const batchedLogger = /*#__PURE__*/dual(3, (self, window, f) => core.flatMap(scope, scope => {\n  let buffer = [];\n  const flush = core.suspend(() => {\n    if (buffer.length === 0) {\n      return core.void;\n    }\n    const arr = buffer;\n    buffer = [];\n    return f(arr);\n  });\n  return core.uninterruptibleMask(restore => pipe(internalEffect.sleep(window), core.zipRight(flush), internalEffect.forever, restore, forkDaemon, core.flatMap(fiber => core.scopeAddFinalizer(scope, core.interruptFiber(fiber))), core.zipRight(addFinalizer(() => flush)), core.as(internalLogger.makeLogger(options => {\n    buffer.push(self.log(options));\n  }))));\n}));\nexport const annotateLogsScoped = function () {\n  if (typeof arguments[0] === \"string\") {\n    return fiberRefLocallyScopedWith(core.currentLogAnnotations, HashMap.set(arguments[0], arguments[1]));\n  }\n  const entries = Object.entries(arguments[0]);\n  return fiberRefLocallyScopedWith(core.currentLogAnnotations, HashMap.mutate(annotations => {\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i];\n      HashMap.set(annotations, key, value);\n    }\n    return annotations;\n  }));\n};\n/** @internal */\nexport const whenLogLevel = /*#__PURE__*/dual(2, (effect, level) => {\n  const requiredLogLevel = typeof level === \"string\" ? LogLevel.fromLiteral(level) : level;\n  return core.withFiberRuntime(fiberState => {\n    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);\n    // Imitate the behaviour of `FiberRuntime.log`\n    if (LogLevel.greaterThan(minimumLogLevel, requiredLogLevel)) {\n      return core.succeed(Option.none());\n    }\n    return core.map(effect, Option.some);\n  });\n});\n// circular with Effect\n/* @internal */\nexport const acquireRelease = /*#__PURE__*/dual(args => core.isEffect(args[0]), (acquire, release) => core.uninterruptible(core.tap(acquire, a => addFinalizer(exit => release(a, exit)))));\n/* @internal */\nexport const acquireReleaseInterruptible = /*#__PURE__*/dual(args => core.isEffect(args[0]), (acquire, release) => ensuring(acquire, addFinalizer(exit => release(exit))));\n/* @internal */\nexport const addFinalizer = finalizer => core.withFiberRuntime(runtime => {\n  const acquireRefs = runtime.getFiberRefs();\n  const acquireFlags = runtimeFlags_.disable(runtime.currentRuntimeFlags, runtimeFlags_.Interruption);\n  return core.flatMap(scope, scope => core.scopeAddFinalizerExit(scope, exit => core.withFiberRuntime(runtimeFinalizer => {\n    const preRefs = runtimeFinalizer.getFiberRefs();\n    const preFlags = runtimeFinalizer.currentRuntimeFlags;\n    const patchRefs = FiberRefsPatch.diff(preRefs, acquireRefs);\n    const patchFlags = runtimeFlags_.diff(preFlags, acquireFlags);\n    const inverseRefs = FiberRefsPatch.diff(acquireRefs, preRefs);\n    runtimeFinalizer.setFiberRefs(FiberRefsPatch.patch(patchRefs, runtimeFinalizer.id(), acquireRefs));\n    return ensuring(core.withRuntimeFlags(finalizer(exit), patchFlags), core.sync(() => {\n      runtimeFinalizer.setFiberRefs(FiberRefsPatch.patch(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));\n    }));\n  })));\n});\n/* @internal */\nexport const daemonChildren = self => {\n  const forkScope = core.fiberRefLocally(core.currentForkScopeOverride, Option.some(fiberScope.globalScope));\n  return forkScope(self);\n};\n/** @internal */\nconst _existsParFound = /*#__PURE__*/Symbol.for(\"effect/Effect/existsPar/found\");\n/* @internal */\nexport const exists = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]) && !core.isEffect(args[0]), (elements, predicate, options) => concurrency.matchSimple(options?.concurrency, () => core.suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => core.matchEffect(forEach(elements, (a, i) => core.if_(predicate(a, i), {\n  onTrue: () => core.fail(_existsParFound),\n  onFalse: () => core.void\n}), options), {\n  onFailure: e => e === _existsParFound ? core.succeed(true) : core.fail(e),\n  onSuccess: () => core.succeed(false)\n})));\nconst existsLoop = (iterator, index, f) => {\n  const next = iterator.next();\n  if (next.done) {\n    return core.succeed(false);\n  }\n  return core.flatMap(f(next.value, index), b => b ? core.succeed(b) : existsLoop(iterator, index + 1, f));\n};\n/* @internal */\nexport const filter = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]) && !core.isEffect(args[0]), (elements, predicate, options) => {\n  const predicate_ = options?.negate ? (a, i) => core.map(predicate(a, i), Boolean.not) : predicate;\n  return concurrency.matchSimple(options?.concurrency, () => core.suspend(() => RA.fromIterable(elements).reduceRight((effect, a, i) => core.zipWith(effect, core.suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), core.sync(() => new Array()))), () => core.map(forEach(elements, (a, i) => core.map(predicate_(a, i), b => b ? Option.some(a) : Option.none()), options), RA.getSomes));\n});\n// === all\nconst allResolveInput = input => {\n  if (Array.isArray(input) || Predicate.isIterable(input)) {\n    return [input, Option.none()];\n  }\n  const keys = Object.keys(input);\n  const size = keys.length;\n  return [keys.map(k => input[k]), Option.some(values => {\n    const res = {};\n    for (let i = 0; i < size; i++) {\n      ;\n      res[keys[i]] = values[i];\n    }\n    return res;\n  })];\n};\nconst allValidate = (effects, reconcile, options) => {\n  const eitherEffects = [];\n  for (const effect of effects) {\n    eitherEffects.push(core.either(effect));\n  }\n  return core.flatMap(forEach(eitherEffects, identity, {\n    concurrency: options?.concurrency,\n    batching: options?.batching,\n    concurrentFinalizers: options?.concurrentFinalizers\n  }), eithers => {\n    const none = Option.none();\n    const size = eithers.length;\n    const errors = new Array(size);\n    const successes = new Array(size);\n    let errored = false;\n    for (let i = 0; i < size; i++) {\n      const either = eithers[i];\n      if (either._tag === \"Left\") {\n        errors[i] = Option.some(either.left);\n        errored = true;\n      } else {\n        successes[i] = either.right;\n        errors[i] = none;\n      }\n    }\n    if (errored) {\n      return reconcile._tag === \"Some\" ? core.fail(reconcile.value(errors)) : core.fail(errors);\n    } else if (options?.discard) {\n      return core.void;\n    }\n    return reconcile._tag === \"Some\" ? core.succeed(reconcile.value(successes)) : core.succeed(successes);\n  });\n};\nconst allEither = (effects, reconcile, options) => {\n  const eitherEffects = [];\n  for (const effect of effects) {\n    eitherEffects.push(core.either(effect));\n  }\n  if (options?.discard) {\n    return forEach(eitherEffects, identity, {\n      concurrency: options?.concurrency,\n      batching: options?.batching,\n      discard: true,\n      concurrentFinalizers: options?.concurrentFinalizers\n    });\n  }\n  return core.map(forEach(eitherEffects, identity, {\n    concurrency: options?.concurrency,\n    batching: options?.batching,\n    concurrentFinalizers: options?.concurrentFinalizers\n  }), eithers => reconcile._tag === \"Some\" ? reconcile.value(eithers) : eithers);\n};\n/* @internal */\nexport const all = (arg, options) => {\n  const [effects, reconcile] = allResolveInput(arg);\n  if (options?.mode === \"validate\") {\n    return allValidate(effects, reconcile, options);\n  } else if (options?.mode === \"either\") {\n    return allEither(effects, reconcile, options);\n  }\n  return options?.discard !== true && reconcile._tag === \"Some\" ? core.map(forEach(effects, identity, options), reconcile.value) : forEach(effects, identity, options);\n};\n/* @internal */\nexport const allWith = options => arg => all(arg, options);\n/* @internal */\nexport const allSuccesses = (elements, options) => core.map(all(RA.fromIterable(elements).map(core.exit), options), RA.filterMap(exit => core.exitIsSuccess(exit) ? Option.some(exit.effect_instruction_i0) : Option.none()));\n/* @internal */\nexport const replicate = /*#__PURE__*/dual(2, (self, n) => Array.from({\n  length: n\n}, () => self));\n/* @internal */\nexport const replicateEffect = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, n, options) => all(replicate(self, n), options));\n/* @internal */\nexport const forEach = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]), (self, f, options) => core.withFiberRuntime(r => {\n  const isRequestBatchingEnabled = options?.batching === true || options?.batching === \"inherit\" && r.getFiberRef(core.currentRequestBatching);\n  if (options?.discard) {\n    return concurrency.match(options.concurrency, () => finalizersMaskInternal(ExecutionStrategy.sequential, options?.concurrentFinalizers)(restore => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : core.forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(ExecutionStrategy.parallel, options?.concurrentFinalizers)(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), n => finalizersMaskInternal(ExecutionStrategy.parallelN(n), options?.concurrentFinalizers)(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));\n  }\n  return concurrency.match(options?.concurrency, () => finalizersMaskInternal(ExecutionStrategy.sequential, options?.concurrentFinalizers)(restore => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : core.forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(ExecutionStrategy.parallel, options?.concurrentFinalizers)(restore => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), n => finalizersMaskInternal(ExecutionStrategy.parallelN(n), options?.concurrentFinalizers)(restore => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));\n}));\n/* @internal */\nexport const forEachParUnbounded = (self, f, batching) => core.suspend(() => {\n  const as = RA.fromIterable(self);\n  const array = new Array(as.length);\n  const fn = (a, i) => core.flatMap(f(a, i), b => core.sync(() => array[i] = b));\n  return core.zipRight(forEachConcurrentDiscard(as, fn, batching, false), core.succeed(array));\n});\n/** @internal */\nexport const forEachConcurrentDiscard = (self, f, batching, processAll, n) => core.uninterruptibleMask(restore => core.transplant(graft => core.withFiberRuntime(parent => {\n  let todos = Array.from(self).reverse();\n  let target = todos.length;\n  if (target === 0) {\n    return core.void;\n  }\n  let counter = 0;\n  let interrupted = false;\n  const fibersCount = n ? Math.min(todos.length, n) : todos.length;\n  const fibers = new Set();\n  const results = new Array();\n  const interruptAll = () => fibers.forEach(fiber => {\n    fiber.currentScheduler.scheduleTask(() => {\n      fiber.unsafeInterruptAsFork(parent.id());\n    }, 0);\n  });\n  const startOrder = new Array();\n  const joinOrder = new Array();\n  const residual = new Array();\n  const collectExits = () => {\n    const exits = results.filter(({\n      exit\n    }) => exit._tag === \"Failure\").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({\n      exit\n    }) => exit);\n    if (exits.length === 0) {\n      exits.push(core.exitVoid);\n    }\n    return exits;\n  };\n  const runFiber = (eff, interruptImmediately = false) => {\n    const runnable = core.uninterruptible(graft(eff));\n    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, fiberScope.globalScope);\n    parent.currentScheduler.scheduleTask(() => {\n      if (interruptImmediately) {\n        fiber.unsafeInterruptAsFork(parent.id());\n      }\n      fiber.resume(runnable);\n    }, 0);\n    return fiber;\n  };\n  const onInterruptSignal = () => {\n    if (!processAll) {\n      target -= todos.length;\n      todos = [];\n    }\n    interrupted = true;\n    interruptAll();\n  };\n  const stepOrExit = batching ? core.step : core.exit;\n  const processingFiber = runFiber(core.async(resume => {\n    const pushResult = (res, index) => {\n      if (res._op === \"Blocked\") {\n        residual.push(res);\n      } else {\n        results.push({\n          index,\n          exit: res\n        });\n        if (res._op === \"Failure\" && !interrupted) {\n          onInterruptSignal();\n        }\n      }\n    };\n    const next = () => {\n      if (todos.length > 0) {\n        const a = todos.pop();\n        let index = counter++;\n        const returnNextElement = () => {\n          const a = todos.pop();\n          index = counter++;\n          return core.flatMap(core.yieldNow(), () => core.flatMap(stepOrExit(restore(f(a, index))), onRes));\n        };\n        const onRes = res => {\n          if (todos.length > 0) {\n            pushResult(res, index);\n            if (todos.length > 0) {\n              return returnNextElement();\n            }\n          }\n          return core.succeed(res);\n        };\n        const todo = core.flatMap(stepOrExit(restore(f(a, index))), onRes);\n        const fiber = runFiber(todo);\n        startOrder.push(fiber);\n        fibers.add(fiber);\n        if (interrupted) {\n          fiber.currentScheduler.scheduleTask(() => {\n            fiber.unsafeInterruptAsFork(parent.id());\n          }, 0);\n        }\n        fiber.addObserver(wrapped => {\n          let exit;\n          if (wrapped._op === \"Failure\") {\n            exit = wrapped;\n          } else {\n            exit = wrapped.effect_instruction_i0;\n          }\n          joinOrder.push(fiber);\n          fibers.delete(fiber);\n          pushResult(exit, index);\n          if (results.length === target) {\n            resume(core.succeed(Option.getOrElse(core.exitCollectAll(collectExits(), {\n              parallel: true\n            }), () => core.exitVoid)));\n          } else if (residual.length + results.length === target) {\n            const exits = collectExits();\n            const requests = residual.map(blocked => blocked.effect_instruction_i0).reduce(RequestBlock_.par);\n            resume(core.succeed(core.blocked(requests, forEachConcurrentDiscard([Option.getOrElse(core.exitCollectAll(exits, {\n              parallel: true\n            }), () => core.exitVoid), ...residual.map(blocked => blocked.effect_instruction_i1)], i => i, batching, true, n))));\n          } else {\n            next();\n          }\n        });\n      }\n    };\n    for (let i = 0; i < fibersCount; i++) {\n      next();\n    }\n  }));\n  return core.asVoid(core.onExit(core.flatten(restore(internalFiber.join(processingFiber))), core.exitMatch({\n    onFailure: cause => {\n      onInterruptSignal();\n      const target = residual.length + 1;\n      const concurrency = Math.min(typeof n === \"number\" ? n : residual.length, residual.length);\n      const toPop = Array.from(residual);\n      return core.async(cb => {\n        const exits = [];\n        let count = 0;\n        let index = 0;\n        const check = (index, hitNext) => exit => {\n          exits[index] = exit;\n          count++;\n          if (count === target) {\n            cb(core.exitSucceed(core.exitFailCause(cause)));\n          }\n          if (toPop.length > 0 && hitNext) {\n            next();\n          }\n        };\n        const next = () => {\n          runFiber(toPop.pop(), true).addObserver(check(index, true));\n          index++;\n        };\n        processingFiber.addObserver(check(index, false));\n        index++;\n        for (let i = 0; i < concurrency; i++) {\n          next();\n        }\n      });\n    },\n    onSuccess: () => core.forEachSequential(joinOrder, f => f.inheritAll)\n  })));\n})));\n/* @internal */\nexport const forEachParN = (self, n, f, batching) => core.suspend(() => {\n  const as = RA.fromIterable(self);\n  const array = new Array(as.length);\n  const fn = (a, i) => core.map(f(a, i), b => array[i] = b);\n  return core.zipRight(forEachConcurrentDiscard(as, fn, batching, false, n), core.succeed(array));\n});\n/* @internal */\nexport const fork = self => core.withFiberRuntime((state, status) => core.succeed(unsafeFork(self, state, status.runtimeFlags)));\n/* @internal */\nexport const forkDaemon = self => forkWithScopeOverride(self, fiberScope.globalScope);\n/* @internal */\nexport const forkWithErrorHandler = /*#__PURE__*/dual(2, (self, handler) => fork(core.onError(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      return handler(either.left);\n    case \"Right\":\n      return core.failCause(either.right);\n  }\n})));\n/** @internal */\nexport const unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);\n  childFiber.resume(effect);\n  return childFiber;\n};\n/** @internal */\nexport const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);\n  return childFiber;\n};\n/** @internal */\nexport const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childId = FiberId.unsafeMake();\n  const parentFiberRefs = parentFiber.getFiberRefs();\n  const childFiberRefs = fiberRefs.forkAs(parentFiberRefs, childId);\n  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);\n  const childContext = fiberRefs.getOrDefault(childFiberRefs, core.currentContext);\n  const supervisor = childFiber.currentSupervisor;\n  supervisor.onStart(childContext, effect, Option.some(parentFiber), childFiber);\n  childFiber.addObserver(exit => supervisor.onEnd(exit, childFiber));\n  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(core.currentForkScopeOverride), Option.getOrElse(() => parentFiber.scope()));\n  parentScope.add(parentRuntimeFlags, childFiber);\n  return childFiber;\n};\n/* @internal */\nconst forkWithScopeOverride = (self, scopeOverride) => core.withFiberRuntime((parentFiber, parentStatus) => core.succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));\n/* @internal */\nexport const mergeAll = /*#__PURE__*/dual(args => Predicate.isFunction(args[2]), (elements, zero, f, options) => concurrency.matchSimple(options?.concurrency, () => RA.fromIterable(elements).reduce((acc, a, i) => core.zipWith(acc, a, (acc, a) => f(acc, a, i)), core.succeed(zero)), () => core.flatMap(Ref.make(zero), acc => core.flatMap(forEach(elements, (effect, i) => core.flatMap(effect, a => Ref.update(acc, b => f(b, a, i))), options), () => Ref.get(acc)))));\n/* @internal */\nexport const partition = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]), (elements, f, options) => pipe(forEach(elements, (a, i) => core.either(f(a, i)), options), core.map(chunk => core.partitionMap(chunk, identity))));\n/* @internal */\nexport const validateAll = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]), (elements, f, options) => core.flatMap(partition(elements, f, {\n  concurrency: options?.concurrency,\n  batching: options?.batching,\n  concurrentFinalizers: options?.concurrentFinalizers\n}), ([es, bs]) => RA.isNonEmptyArray(es) ? core.fail(es) : options?.discard ? core.void : core.succeed(bs)));\n/* @internal */\nexport const raceAll = all => core.withFiberRuntime((state, status) => core.async(resume => {\n  const fibers = new Set();\n  let winner;\n  let failures = internalCause.empty;\n  const interruptAll = () => {\n    for (const fiber of fibers) {\n      fiber.unsafeInterruptAsFork(state.id());\n    }\n  };\n  let latch = false;\n  let empty = true;\n  for (const self of all) {\n    empty = false;\n    const fiber = unsafeFork(core.interruptible(self), state, status.runtimeFlags);\n    fibers.add(fiber);\n    fiber.addObserver(exit => {\n      fibers.delete(fiber);\n      if (!winner) {\n        if (exit._tag === \"Success\") {\n          latch = true;\n          winner = fiber;\n          failures = internalCause.empty;\n          interruptAll();\n        } else {\n          failures = internalCause.parallel(exit.cause, failures);\n        }\n      }\n      if (latch && fibers.size === 0) {\n        resume(winner ? core.zipRight(internalFiber.inheritAll(winner), winner.unsafePoll()) : core.failCause(failures));\n      }\n    });\n    if (winner) break;\n  }\n  if (empty) {\n    return resume(core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`)));\n  }\n  latch = true;\n  return internalFiber.interruptAllAs(fibers, state.id());\n}));\n/* @internal */\nexport const reduceEffect = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]) && !core.isEffect(args[0]), (elements, zero, f, options) => concurrency.matchSimple(options?.concurrency, () => RA.fromIterable(elements).reduce((acc, a, i) => core.zipWith(acc, a, (acc, a) => f(acc, a, i)), zero), () => core.suspend(() => pipe(mergeAll([zero, ...elements], Option.none(), (acc, elem, i) => {\n  switch (acc._tag) {\n    case \"None\":\n      {\n        return Option.some(elem);\n      }\n    case \"Some\":\n      {\n        return Option.some(f(acc.value, elem, i));\n      }\n  }\n}, options), core.map(option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        throw new Error(\"BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues\");\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n})))));\n/* @internal */\nexport const parallelFinalizers = self => core.contextWithEffect(context => Option.match(Context.getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    switch (scope.strategy._tag) {\n      case \"Parallel\":\n        return self;\n      case \"Sequential\":\n      case \"ParallelN\":\n        return core.flatMap(core.scopeFork(scope, ExecutionStrategy.parallel), inner => scopeExtend(self, inner));\n    }\n  }\n}));\n/* @internal */\nexport const parallelNFinalizers = parallelism => self => core.contextWithEffect(context => Option.match(Context.getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    if (scope.strategy._tag === \"ParallelN\" && scope.strategy.parallelism === parallelism) {\n      return self;\n    }\n    return core.flatMap(core.scopeFork(scope, ExecutionStrategy.parallelN(parallelism)), inner => scopeExtend(self, inner));\n  }\n}));\n/* @internal */\nexport const finalizersMask = strategy => self => finalizersMaskInternal(strategy, true)(self);\n/* @internal */\nexport const finalizersMaskInternal = (strategy, concurrentFinalizers) => self => core.contextWithEffect(context => Option.match(Context.getOption(context, scopeTag), {\n  onNone: () => self(identity),\n  onSome: scope => {\n    if (concurrentFinalizers === true) {\n      const patch = strategy._tag === \"Parallel\" ? parallelFinalizers : strategy._tag === \"Sequential\" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);\n      switch (scope.strategy._tag) {\n        case \"Parallel\":\n          return patch(self(parallelFinalizers));\n        case \"Sequential\":\n          return patch(self(sequentialFinalizers));\n        case \"ParallelN\":\n          return patch(self(parallelNFinalizers(scope.strategy.parallelism)));\n      }\n    } else {\n      return self(identity);\n    }\n  }\n}));\n/* @internal */\nexport const scopeWith = f => core.flatMap(scopeTag, f);\n/** @internal */\nexport const scopedWith = f => core.flatMap(scopeMake(), scope => core.onExit(f(scope), exit => scope.close(exit)));\n/* @internal */\nexport const scopedEffect = effect => core.flatMap(scopeMake(), scope => scopeUse(effect, scope));\n/* @internal */\nexport const sequentialFinalizers = self => core.contextWithEffect(context => Option.match(Context.getOption(context, scopeTag), {\n  onNone: () => self,\n  onSome: scope => {\n    switch (scope.strategy._tag) {\n      case \"Sequential\":\n        return self;\n      case \"Parallel\":\n      case \"ParallelN\":\n        return core.flatMap(core.scopeFork(scope, ExecutionStrategy.sequential), inner => scopeExtend(self, inner));\n    }\n  }\n}));\n/* @internal */\nexport const tagMetricsScoped = (key, value) => labelMetricsScoped([metricLabel.make(key, value)]);\n/* @internal */\nexport const labelMetricsScoped = labels => fiberRefLocallyScopedWith(core.currentMetricLabels, old => RA.union(old, labels));\n/* @internal */\nexport const using = /*#__PURE__*/dual(2, (self, use) => scopedWith(scope => core.flatMap(scopeExtend(self, scope), use)));\n/** @internal */\nexport const validate = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));\n/** @internal */\nexport const validateWith = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, f, options) => core.flatten(zipWithOptions(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(ea, eb, {\n  onSuccess: f,\n  onFailure: (ca, cb) => options?.concurrent ? internalCause.parallel(ca, cb) : internalCause.sequential(ca, cb)\n}), options)));\n/* @internal */\nexport const validateAllPar = /*#__PURE__*/dual(2, (elements, f) => core.flatMap(partition(elements, f), ([es, bs]) => es.length === 0 ? core.succeed(bs) : core.fail(es)));\n/* @internal */\nexport const validateAllParDiscard = /*#__PURE__*/dual(2, (elements, f) => core.flatMap(partition(elements, f), ([es, _]) => es.length === 0 ? core.void : core.fail(es)));\n/* @internal */\nexport const validateFirst = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]), (elements, f, options) => core.flip(forEach(elements, (a, i) => core.flip(f(a, i)), options)));\n/* @internal */\nexport const withClockScoped = c => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(clock.clockTag, c));\n/* @internal */\nexport const withRandomScoped = value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(randomTag, value));\n/* @internal */\nexport const withConfigProviderScoped = provider => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(configProviderTag, provider));\n/* @internal */\nexport const withEarlyRelease = self => scopeWith(parent => core.flatMap(core.scopeFork(parent, executionStrategy.sequential), child => pipe(self, scopeExtend(child), core.map(value => [core.fiberIdWith(fiberId => core.scopeClose(child, core.exitInterrupt(fiberId))), value]))));\n/** @internal */\nexport const zipOptions = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));\n/** @internal */\nexport const zipLeftOptions = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, options) => {\n  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {\n    return core.zipLeft(self, that);\n  }\n  return zipWithOptions(self, that, (a, _) => a, options);\n});\n/** @internal */\nexport const zipRightOptions = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, options) => {\n  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {\n    return core.zipRight(self, that);\n  }\n  return zipWithOptions(self, that, (_, b) => b, options);\n});\n/** @internal */\nexport const zipWithOptions = /*#__PURE__*/dual(args => core.isEffect(args[1]), (self, that, f, options) => core.map(all([self, that], {\n  concurrency: options?.concurrent ? 2 : 1,\n  batching: options?.batching,\n  concurrentFinalizers: options?.concurrentFinalizers\n}), ([a, a2]) => f(a, a2)));\n/* @internal */\nexport const withRuntimeFlagsScoped = update => {\n  if (update === RuntimeFlagsPatch.empty) {\n    return core.void;\n  }\n  return pipe(core.runtimeFlags, core.flatMap(runtimeFlags => {\n    const updatedRuntimeFlags = runtimeFlags_.patch(runtimeFlags, update);\n    const revertRuntimeFlags = runtimeFlags_.diff(updatedRuntimeFlags, runtimeFlags);\n    return pipe(core.updateRuntimeFlags(update), core.zipRight(addFinalizer(() => core.updateRuntimeFlags(revertRuntimeFlags))), core.asVoid);\n  }), core.uninterruptible);\n};\n// circular with Scope\n/** @internal */\nexport const scopeTag = /*#__PURE__*/Context.GenericTag(\"effect/Scope\");\n/* @internal */\nexport const scope = scopeTag;\nconst scopeUnsafeAddFinalizer = (scope, fin) => {\n  if (scope.state._tag === \"Open\") {\n    scope.state.finalizers.set({}, fin);\n  }\n};\nconst ScopeImplProto = {\n  [core.ScopeTypeId]: core.ScopeTypeId,\n  [core.CloseableScopeTypeId]: core.CloseableScopeTypeId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  fork(strategy) {\n    return core.sync(() => {\n      const newScope = scopeUnsafeMake(strategy);\n      if (this.state._tag === \"Closed\") {\n        newScope.state = this.state;\n        return newScope;\n      }\n      const key = {};\n      const fin = exit => newScope.close(exit);\n      this.state.finalizers.set(key, fin);\n      scopeUnsafeAddFinalizer(newScope, _ => core.sync(() => {\n        if (this.state._tag === \"Open\") {\n          this.state.finalizers.delete(key);\n        }\n      }));\n      return newScope;\n    });\n  },\n  close(exit) {\n    return core.suspend(() => {\n      if (this.state._tag === \"Closed\") {\n        return core.void;\n      }\n      const finalizers = Array.from(this.state.finalizers.values()).reverse();\n      this.state = {\n        _tag: \"Closed\",\n        exit\n      };\n      if (finalizers.length === 0) {\n        return core.void;\n      }\n      return executionStrategy.isSequential(this.strategy) ? pipe(core.forEachSequential(finalizers, fin => core.exit(fin(exit))), core.flatMap(results => pipe(core.exitCollectAll(results), Option.map(core.exitAsVoid), Option.getOrElse(() => core.exitVoid)))) : executionStrategy.isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, fin => core.exit(fin(exit)), false), core.flatMap(results => pipe(core.exitCollectAll(results, {\n        parallel: true\n      }), Option.map(core.exitAsVoid), Option.getOrElse(() => core.exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, fin => core.exit(fin(exit)), false), core.flatMap(results => pipe(core.exitCollectAll(results, {\n        parallel: true\n      }), Option.map(core.exitAsVoid), Option.getOrElse(() => core.exitVoid))));\n    });\n  },\n  addFinalizer(fin) {\n    return core.suspend(() => {\n      if (this.state._tag === \"Closed\") {\n        return fin(this.state.exit);\n      }\n      this.state.finalizers.set({}, fin);\n      return core.void;\n    });\n  }\n};\nconst scopeUnsafeMake = (strategy = executionStrategy.sequential) => {\n  const scope = Object.create(ScopeImplProto);\n  scope.strategy = strategy;\n  scope.state = {\n    _tag: \"Open\",\n    finalizers: new Map()\n  };\n  return scope;\n};\n/* @internal */\nexport const scopeMake = (strategy = executionStrategy.sequential) => core.sync(() => scopeUnsafeMake(strategy));\n/* @internal */\nexport const scopeExtend = /*#__PURE__*/dual(2, (effect, scope) => core.mapInputContext(effect,\n// @ts-expect-error\nContext.merge(Context.make(scopeTag, scope))));\n/* @internal */\nexport const scopeUse = /*#__PURE__*/dual(2, (effect, scope) => pipe(effect, scopeExtend(scope), core.onExit(exit => scope.close(exit))));\n// circular with Supervisor\n/** @internal */\nexport const fiberRefUnsafeMakeSupervisor = initial => core.fiberRefUnsafeMakePatch(initial, {\n  differ: SupervisorPatch.differ,\n  fork: SupervisorPatch.empty\n});\n// circular with FiberRef\n/* @internal */\nexport const fiberRefLocallyScoped = /*#__PURE__*/dual(2, (self, value) => core.asVoid(acquireRelease(core.flatMap(core.fiberRefGet(self), oldValue => core.as(core.fiberRefSet(self, value), oldValue)), oldValue => core.fiberRefSet(self, oldValue))));\n/* @internal */\nexport const fiberRefLocallyScopedWith = /*#__PURE__*/dual(2, (self, f) => core.fiberRefGetWith(self, a => fiberRefLocallyScoped(self, f(a))));\n/* @internal */\nexport const fiberRefMake = (initial, options) => fiberRefMakeWith(() => core.fiberRefUnsafeMake(initial, options));\n/* @internal */\nexport const fiberRefMakeWith = ref => acquireRelease(core.tap(core.sync(ref), ref => core.fiberRefUpdate(ref, identity)), fiberRef => core.fiberRefDelete(fiberRef));\n/* @internal */\nexport const fiberRefMakeContext = initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeContext(initial));\n/* @internal */\nexport const fiberRefMakeRuntimeFlags = initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeRuntimeFlags(initial));\n/** @internal */\nexport const currentRuntimeFlags = /*#__PURE__*/core.fiberRefUnsafeMakeRuntimeFlags(runtimeFlags_.none);\n/** @internal */\nexport const currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(supervisor.none);\n// circular with Fiber\n/* @internal */\nexport const fiberAwaitAll = fibers => forEach(fibers, internalFiber._await);\n/** @internal */\nexport const fiberAll = fibers => {\n  const _fiberAll = {\n    ...Effectable.CommitPrototype,\n    commit() {\n      return internalFiber.join(this);\n    },\n    [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n    id: () => RA.fromIterable(fibers).reduce((id, fiber) => FiberId.combine(id, fiber.id()), FiberId.none),\n    await: core.exit(forEachParUnbounded(fibers, fiber => core.flatten(fiber.await), false)),\n    children: core.map(forEachParUnbounded(fibers, fiber => fiber.children, false), RA.flatten),\n    inheritAll: core.forEachSequentialDiscard(fibers, fiber => fiber.inheritAll),\n    poll: core.map(core.forEachSequential(fibers, fiber => fiber.poll), RA.reduceRight(Option.some(core.exitSucceed(new Array())), (optionB, optionA) => {\n      switch (optionA._tag) {\n        case \"None\":\n          {\n            return Option.none();\n          }\n        case \"Some\":\n          {\n            switch (optionB._tag) {\n              case \"None\":\n                {\n                  return Option.none();\n                }\n              case \"Some\":\n                {\n                  return Option.some(core.exitZipWith(optionA.value, optionB.value, {\n                    onSuccess: (a, chunk) => [a, ...chunk],\n                    onFailure: internalCause.parallel\n                  }));\n                }\n            }\n          }\n      }\n    })),\n    interruptAsFork: fiberId => core.forEachSequentialDiscard(fibers, fiber => fiber.interruptAsFork(fiberId))\n  };\n  return _fiberAll;\n};\n/* @internal */\nexport const fiberInterruptFork = self => core.asVoid(forkDaemon(core.interruptFiber(self)));\n/* @internal */\nexport const fiberJoinAll = fibers => internalFiber.join(fiberAll(fibers));\n/* @internal */\nexport const fiberScoped = self => acquireRelease(core.succeed(self), core.interruptFiber);\n//\n// circular race\n//\n/** @internal */\nexport const raceWith = /*#__PURE__*/dual(3, (self, other, options) => raceFibersWith(self, other, {\n  onSelfWin: (winner, loser) => core.flatMap(winner.await, exit => {\n    switch (exit._tag) {\n      case OpCodes.OP_SUCCESS:\n        {\n          return core.flatMap(winner.inheritAll, () => options.onSelfDone(exit, loser));\n        }\n      case OpCodes.OP_FAILURE:\n        {\n          return options.onSelfDone(exit, loser);\n        }\n    }\n  }),\n  onOtherWin: (winner, loser) => core.flatMap(winner.await, exit => {\n    switch (exit._tag) {\n      case OpCodes.OP_SUCCESS:\n        {\n          return core.flatMap(winner.inheritAll, () => options.onOtherDone(exit, loser));\n        }\n      case OpCodes.OP_FAILURE:\n        {\n          return options.onOtherDone(exit, loser);\n        }\n    }\n  })\n}));\n/** @internal */\nexport const disconnect = self => core.uninterruptibleMask(restore => core.fiberIdWith(fiberId => core.flatMap(forkDaemon(restore(self)), fiber => pipe(restore(internalFiber.join(fiber)), core.onInterrupt(() => pipe(fiber, internalFiber.interruptAsFork(fiberId)))))));\n/** @internal */\nexport const race = /*#__PURE__*/dual(2, (self, that) => core.fiberIdWith(parentFiberId => raceWith(self, that, {\n  onSelfDone: (exit, right) => core.exitMatchEffect(exit, {\n    onFailure: cause => pipe(internalFiber.join(right), internalEffect.mapErrorCause(cause2 => internalCause.parallel(cause, cause2))),\n    onSuccess: value => pipe(right, core.interruptAsFiber(parentFiberId), core.as(value))\n  }),\n  onOtherDone: (exit, left) => core.exitMatchEffect(exit, {\n    onFailure: cause => pipe(internalFiber.join(left), internalEffect.mapErrorCause(cause2 => internalCause.parallel(cause2, cause))),\n    onSuccess: value => pipe(left, core.interruptAsFiber(parentFiberId), core.as(value))\n  })\n})));\n/** @internal */\nexport const raceFibersWith = /*#__PURE__*/dual(3, (self, other, options) => core.withFiberRuntime((parentFiber, parentStatus) => {\n  const parentRuntimeFlags = parentStatus.runtimeFlags;\n  const raceIndicator = MRef.make(true);\n  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);\n  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);\n  return core.async(cb => {\n    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));\n    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));\n    leftFiber.startFork(self);\n    rightFiber.startFork(other);\n  }, FiberId.combine(leftFiber.id(), rightFiber.id()));\n}));\nconst completeRace = (winner, loser, cont, ab, cb) => {\n  if (MRef.compareAndSet(true, false)(ab)) {\n    cb(cont(winner, loser));\n  }\n};\n/** @internal */\nexport const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => core.uninterruptibleMask(restore => core.matchCauseEffect(restore(self), {\n  onFailure: cause1 => core.matchCauseEffect(finalizer, {\n    onFailure: cause2 => core.failCause(internalCause.sequential(cause1, cause2)),\n    onSuccess: () => core.failCause(cause1)\n  }),\n  onSuccess: a => core.as(finalizer, a)\n})));\n/** @internal */\nexport const invokeWithInterrupt = (self, entries, onInterrupt) => core.fiberIdWith(id => core.flatMap(core.flatMap(forkDaemon(core.interruptible(self)), processing => core.async(cb => {\n  const counts = entries.map(_ => _.listeners.count);\n  const checkDone = () => {\n    if (counts.every(count => count === 0)) {\n      if (entries.every(_ => {\n        if (_.result.state.current._tag === \"Pending\") {\n          return true;\n        } else if (_.result.state.current._tag === \"Done\" && core.exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === \"Failure\" && internalCause.isInterrupted(_.result.state.current.effect.cause)) {\n          return true;\n        } else {\n          return false;\n        }\n      })) {\n        cleanup.forEach(f => f());\n        onInterrupt?.();\n        cb(core.interruptFiber(processing));\n      }\n    }\n  };\n  processing.addObserver(exit => {\n    cleanup.forEach(f => f());\n    cb(exit);\n  });\n  const cleanup = entries.map((r, i) => {\n    const observer = count => {\n      counts[i] = count;\n      checkDone();\n    };\n    r.listeners.addObserver(observer);\n    return () => r.listeners.removeObserver(observer);\n  });\n  checkDone();\n  return core.sync(() => {\n    cleanup.forEach(f => f());\n  });\n})), () => core.suspend(() => {\n  const residual = entries.flatMap(entry => {\n    if (!entry.state.completed) {\n      return [entry];\n    }\n    return [];\n  });\n  return core.forEachSequentialDiscard(residual, entry => complete(entry.request, core.exitInterrupt(id)));\n})));\n/** @internal */\nexport const interruptWhenPossible = /*#__PURE__*/dual(2, (self, all) => core.fiberRefGetWith(currentRequestMap, map => core.suspend(() => {\n  const entries = RA.fromIterable(all).flatMap(_ => map.has(_) ? [map.get(_)] : []);\n  return invokeWithInterrupt(self, entries);\n})));\n// circular Tracer\n/** @internal */\nexport const makeSpanScoped = (name, options) => {\n  options = tracer.addSpanStackTrace(options);\n  return core.uninterruptible(core.withFiberRuntime(fiber => {\n    const scope = Context.unsafeGet(fiber.getFiberRef(core.currentContext), scopeTag);\n    const span = internalEffect.unsafeMakeSpan(fiber, name, options);\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled);\n    const clock_ = Context.get(fiber.getFiberRef(defaultServices.currentServices), clock.clockTag);\n    return core.as(core.scopeAddFinalizerExit(scope, exit => internalEffect.endSpan(span, exit, clock_, timingEnabled)), span);\n  }));\n};\n/* @internal */\nexport const withTracerScoped = value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(tracer.tracerTag, value));\n/** @internal */\nexport const withSpanScoped = function () {\n  const dataFirst = typeof arguments[0] !== \"string\";\n  const name = dataFirst ? arguments[1] : arguments[0];\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);\n  if (dataFirst) {\n    const self = arguments[0];\n    return core.flatMap(makeSpanScoped(name, tracer.addSpanStackTrace(options)), span => internalEffect.provideService(self, tracer.spanTag, span));\n  }\n  return self => core.flatMap(makeSpanScoped(name, tracer.addSpanStackTrace(options)), span => internalEffect.provideService(self, tracer.spanTag, span));\n};\n//# sourceMappingURL=fiberRuntime.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628706,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
