{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stm/tPubSub.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as RA from \"../../Array.js\";\nimport * as Effect from \"../../Effect.js\";\nimport { dual, identity, pipe } from \"../../Function.js\";\nimport * as HashSet from \"../../HashSet.js\";\nimport * as Option from \"../../Option.js\";\nimport * as core from \"./core.js\";\nimport * as OpCodes from \"./opCodes/strategy.js\";\nimport * as stm from \"./stm.js\";\nimport * as tQueue from \"./tQueue.js\";\nimport * as tRef from \"./tRef.js\";\n/** @internal */\nconst TPubSubSymbolKey = \"effect/TPubSub\";\n/** @internal */\nexport const TPubSubTypeId = /*#__PURE__*/Symbol.for(TPubSubSymbolKey);\nconst AbsentValue = /*#__PURE__*/Symbol.for(\"effect/TPubSub/AbsentValue\");\n/** @internal */\nexport const makeNode = (head, subscribers, tail) => ({\n  head,\n  subscribers,\n  tail\n});\n/** @internal */\nclass TPubSubImpl {\n  pubsubSize;\n  publisherHead;\n  publisherTail;\n  requestedCapacity;\n  strategy;\n  subscriberCount;\n  subscribers;\n  [TPubSubTypeId] = {\n    _A: _ => _\n  };\n  [tQueue.TEnqueueTypeId] = tQueue.tEnqueueVariance;\n  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {\n    this.pubsubSize = pubsubSize;\n    this.publisherHead = publisherHead;\n    this.publisherTail = publisherTail;\n    this.requestedCapacity = requestedCapacity;\n    this.strategy = strategy;\n    this.subscriberCount = subscriberCount;\n    this.subscribers = subscribers;\n  }\n  isShutdown = /*#__PURE__*/core.effect(journal => {\n    const currentPublisherTail = tRef.unsafeGet(this.publisherTail, journal);\n    return currentPublisherTail === undefined;\n  });\n  awaitShutdown = /*#__PURE__*/core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.void : core.retry);\n  capacity() {\n    return this.requestedCapacity;\n  }\n  size = /*#__PURE__*/core.withSTMRuntime(runtime => {\n    const currentPublisherTail = tRef.unsafeGet(this.publisherTail, runtime.journal);\n    if (currentPublisherTail === undefined) {\n      return core.interruptAs(runtime.fiberId);\n    }\n    return core.succeed(tRef.unsafeGet(this.pubsubSize, runtime.journal));\n  });\n  isEmpty = /*#__PURE__*/core.map(this.size, size => size === 0);\n  isFull = /*#__PURE__*/core.map(this.size, size => size === this.capacity());\n  offer(value) {\n    return core.withSTMRuntime(runtime => {\n      const currentPublisherTail = tRef.unsafeGet(this.publisherTail, runtime.journal);\n      if (currentPublisherTail === undefined) {\n        return core.interruptAs(runtime.fiberId);\n      }\n      const currentSubscriberCount = tRef.unsafeGet(this.subscriberCount, runtime.journal);\n      if (currentSubscriberCount === 0) {\n        return core.succeed(true);\n      }\n      const currentPubSubSize = tRef.unsafeGet(this.pubsubSize, runtime.journal);\n      if (currentPubSubSize < this.requestedCapacity) {\n        const updatedPublisherTail = new tRef.TRefImpl(void 0);\n        const updatedNode = makeNode(value, currentSubscriberCount, updatedPublisherTail);\n        tRef.unsafeSet(currentPublisherTail, updatedNode, runtime.journal);\n        tRef.unsafeSet(this.publisherTail, updatedPublisherTail, runtime.journal);\n        tRef.unsafeSet(this.pubsubSize, currentPubSubSize + 1, runtime.journal);\n        return core.succeed(true);\n      }\n      switch (this.strategy._tag) {\n        case OpCodes.OP_BACKPRESSURE_STRATEGY:\n          {\n            return core.retry;\n          }\n        case OpCodes.OP_DROPPING_STRATEGY:\n          {\n            return core.succeed(false);\n          }\n        case OpCodes.OP_SLIDING_STRATEGY:\n          {\n            if (this.requestedCapacity > 0) {\n              let currentPublisherHead = tRef.unsafeGet(this.publisherHead, runtime.journal);\n              let loop = true;\n              while (loop) {\n                const node = tRef.unsafeGet(currentPublisherHead, runtime.journal);\n                if (node === undefined) {\n                  return core.retry;\n                }\n                const head = node.head;\n                const tail = node.tail;\n                if (head !== AbsentValue) {\n                  const updatedNode = makeNode(AbsentValue, node.subscribers, node.tail);\n                  tRef.unsafeSet(currentPublisherHead, updatedNode, runtime.journal);\n                  tRef.unsafeSet(this.publisherHead, tail, runtime.journal);\n                  loop = false;\n                } else {\n                  currentPublisherHead = tail;\n                }\n              }\n            }\n            const updatedPublisherTail = new tRef.TRefImpl(void 0);\n            const updatedNode = makeNode(value, currentSubscriberCount, updatedPublisherTail);\n            tRef.unsafeSet(currentPublisherTail, updatedNode, runtime.journal);\n            tRef.unsafeSet(this.publisherTail, updatedPublisherTail, runtime.journal);\n            return core.succeed(true);\n          }\n      }\n    });\n  }\n  offerAll(iterable) {\n    return core.map(stm.forEach(iterable, a => this.offer(a)), RA.every(identity));\n  }\n  shutdown = /*#__PURE__*/core.effect(journal => {\n    const currentPublisherTail = tRef.unsafeGet(this.publisherTail, journal);\n    if (currentPublisherTail !== undefined) {\n      tRef.unsafeSet(this.publisherTail, void 0, journal);\n      const currentSubscribers = tRef.unsafeGet(this.subscribers, journal);\n      HashSet.forEach(currentSubscribers, subscriber => {\n        tRef.unsafeSet(subscriber, void 0, journal);\n      });\n      tRef.unsafeSet(this.subscribers, HashSet.empty(), journal);\n    }\n  });\n}\n/** @internal */\nclass TPubSubSubscriptionImpl {\n  pubsubSize;\n  publisherHead;\n  requestedCapacity;\n  subscriberHead;\n  subscriberCount;\n  subscribers;\n  [TPubSubTypeId] = TPubSubTypeId;\n  [tQueue.TDequeueTypeId] = tQueue.tDequeueVariance;\n  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {\n    this.pubsubSize = pubsubSize;\n    this.publisherHead = publisherHead;\n    this.requestedCapacity = requestedCapacity;\n    this.subscriberHead = subscriberHead;\n    this.subscriberCount = subscriberCount;\n    this.subscribers = subscribers;\n  }\n  isShutdown = /*#__PURE__*/core.effect(journal => {\n    const currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);\n    return currentSubscriberHead === undefined;\n  });\n  awaitShutdown = /*#__PURE__*/core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.void : core.retry);\n  capacity() {\n    return this.requestedCapacity;\n  }\n  size = /*#__PURE__*/core.withSTMRuntime(runtime => {\n    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);\n    if (currentSubscriberHead === undefined) {\n      return core.interruptAs(runtime.fiberId);\n    }\n    let loop = true;\n    let size = 0;\n    while (loop) {\n      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);\n      if (node === undefined) {\n        loop = false;\n      } else {\n        const head = node.head;\n        const tail = node.tail;\n        if (head !== AbsentValue) {\n          size = size + 1;\n          if (size >= Number.MAX_SAFE_INTEGER) {\n            loop = false;\n          }\n        }\n        currentSubscriberHead = tail;\n      }\n    }\n    return core.succeed(size);\n  });\n  isEmpty = /*#__PURE__*/core.map(this.size, size => size === 0);\n  isFull = /*#__PURE__*/core.map(this.size, size => size === this.capacity());\n  peek = /*#__PURE__*/core.withSTMRuntime(runtime => {\n    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);\n    if (currentSubscriberHead === undefined) {\n      return core.interruptAs(runtime.fiberId);\n    }\n    let value = AbsentValue;\n    let loop = true;\n    while (loop) {\n      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);\n      if (node === undefined) {\n        return core.retry;\n      }\n      const head = node.head;\n      const tail = node.tail;\n      if (head !== AbsentValue) {\n        value = head;\n        loop = false;\n      } else {\n        currentSubscriberHead = tail;\n      }\n    }\n    return core.succeed(value);\n  });\n  peekOption = /*#__PURE__*/core.withSTMRuntime(runtime => {\n    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);\n    if (currentSubscriberHead === undefined) {\n      return core.interruptAs(runtime.fiberId);\n    }\n    let value = Option.none();\n    let loop = true;\n    while (loop) {\n      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);\n      if (node === undefined) {\n        value = Option.none();\n        loop = false;\n      } else {\n        const head = node.head;\n        const tail = node.tail;\n        if (head !== AbsentValue) {\n          value = Option.some(head);\n          loop = false;\n        } else {\n          currentSubscriberHead = tail;\n        }\n      }\n    }\n    return core.succeed(value);\n  });\n  shutdown = /*#__PURE__*/core.effect(journal => {\n    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);\n    if (currentSubscriberHead !== undefined) {\n      tRef.unsafeSet(this.subscriberHead, void 0, journal);\n      let loop = true;\n      while (loop) {\n        const node = tRef.unsafeGet(currentSubscriberHead, journal);\n        if (node === undefined) {\n          loop = false;\n        } else {\n          const head = node.head;\n          const tail = node.tail;\n          if (head !== AbsentValue) {\n            const subscribers = node.subscribers;\n            if (subscribers === 1) {\n              const size = tRef.unsafeGet(this.pubsubSize, journal);\n              const updatedNode = makeNode(AbsentValue, 0, tail);\n              tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);\n              tRef.unsafeSet(this.publisherHead, tail, journal);\n              tRef.unsafeSet(this.pubsubSize, size - 1, journal);\n            } else {\n              const updatedNode = makeNode(head, subscribers - 1, tail);\n              tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);\n            }\n          }\n          currentSubscriberHead = tail;\n        }\n      }\n      const currentSubscriberCount = tRef.unsafeGet(this.subscriberCount, journal);\n      tRef.unsafeSet(this.subscriberCount, currentSubscriberCount - 1, journal);\n      tRef.unsafeSet(this.subscribers, HashSet.remove(tRef.unsafeGet(this.subscribers, journal), this.subscriberHead), journal);\n    }\n  });\n  take = /*#__PURE__*/core.withSTMRuntime(runtime => {\n    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);\n    if (currentSubscriberHead === undefined) {\n      return core.interruptAs(runtime.fiberId);\n    }\n    let value = AbsentValue;\n    let loop = true;\n    while (loop) {\n      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);\n      if (node === undefined) {\n        return core.retry;\n      }\n      const head = node.head;\n      const tail = node.tail;\n      if (head !== AbsentValue) {\n        const subscribers = node.subscribers;\n        if (subscribers === 1) {\n          const size = tRef.unsafeGet(this.pubsubSize, runtime.journal);\n          const updatedNode = makeNode(AbsentValue, 0, tail);\n          tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);\n          tRef.unsafeSet(this.publisherHead, tail, runtime.journal);\n          tRef.unsafeSet(this.pubsubSize, size - 1, runtime.journal);\n        } else {\n          const updatedNode = makeNode(head, subscribers - 1, tail);\n          tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);\n        }\n        tRef.unsafeSet(this.subscriberHead, tail, runtime.journal);\n        value = head;\n        loop = false;\n      } else {\n        currentSubscriberHead = tail;\n      }\n    }\n    return core.succeed(value);\n  });\n  takeAll = /*#__PURE__*/this.takeUpTo(Number.POSITIVE_INFINITY);\n  takeUpTo(max) {\n    return core.withSTMRuntime(runtime => {\n      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);\n      if (currentSubscriberHead === undefined) {\n        return core.interruptAs(runtime.fiberId);\n      }\n      const builder = [];\n      let n = 0;\n      while (n !== max) {\n        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);\n        if (node === undefined) {\n          n = max;\n        } else {\n          const head = node.head;\n          const tail = node.tail;\n          if (head !== AbsentValue) {\n            const subscribers = node.subscribers;\n            if (subscribers === 1) {\n              const size = tRef.unsafeGet(this.pubsubSize, runtime.journal);\n              const updatedNode = makeNode(AbsentValue, 0, tail);\n              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);\n              tRef.unsafeSet(this.publisherHead, tail, runtime.journal);\n              tRef.unsafeSet(this.pubsubSize, size - 1, runtime.journal);\n            } else {\n              const updatedNode = makeNode(head, subscribers - 1, tail);\n              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);\n            }\n            builder.push(head);\n            n = n + 1;\n          }\n          currentSubscriberHead = tail;\n        }\n      }\n      tRef.unsafeSet(this.subscriberHead, currentSubscriberHead, runtime.journal);\n      return core.succeed(builder);\n    });\n  }\n}\n/** @internal */\nconst makeTPubSub = (requestedCapacity, strategy) => pipe(stm.all([tRef.make(void 0), tRef.make(0)]), core.flatMap(([empty, pubsubSize]) => pipe(stm.all([tRef.make(empty), tRef.make(empty), tRef.make(0), tRef.make(HashSet.empty())]), core.map(([publisherHead, publisherTail, subscriberCount, subscribers]) => new TPubSubImpl(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)))));\nconst makeSubscription = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(tRef.get(publisherTail), core.flatMap(currentPublisherTail => pipe(stm.all([tRef.make(currentPublisherTail), tRef.get(subscriberCount), tRef.get(subscribers)]), stm.tap(([_, currentSubscriberCount]) => pipe(subscriberCount, tRef.set(currentSubscriberCount + 1))), stm.tap(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, tRef.set(pipe(currentSubscribers, HashSet.add(subscriberHead))))), core.map(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));\n/** @internal */\nexport const awaitShutdown = self => self.awaitShutdown;\n/** @internal */\nexport const bounded = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.BackPressure);\n/** @internal */\nexport const capacity = self => self.capacity();\n/** @internal */\nexport const dropping = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.Dropping);\n/** @internal */\nexport const isEmpty = self => self.isEmpty;\n/** @internal */\nexport const isFull = self => self.isFull;\n/** @internal */\nexport const isShutdown = self => self.isShutdown;\n/** @internal */\nexport const publish = /*#__PURE__*/dual(2, (self, value) => self.offer(value));\n/** @internal */\nexport const publishAll = /*#__PURE__*/dual(2, (self, iterable) => self.offerAll(iterable));\n/** @internal */\nexport const size = self => self.size;\n/** @internal */\nexport const shutdown = self => self.shutdown;\n/** @internal */\nexport const sliding = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.Sliding);\n/** @internal */\nexport const subscribe = self => makeSubscription(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);\n/** @internal */\nexport const subscribeScoped = self => Effect.acquireRelease(subscribe(self), dequeue => tQueue.shutdown(dequeue));\n/** @internal */\nexport const unbounded = () => makeTPubSub(Number.MAX_SAFE_INTEGER, tQueue.Dropping);\n//# sourceMappingURL=tPubSub.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
