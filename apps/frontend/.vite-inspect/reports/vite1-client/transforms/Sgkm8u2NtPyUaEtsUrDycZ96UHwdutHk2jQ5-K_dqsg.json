{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/HashSet.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * # HashSet\n *\n * An immutable `HashSet` provides a collection of unique values with efficient\n * lookup, insertion and removal. Once created, a `HashSet` cannot be modified;\n * any operation that would alter the set instead returns a new `HashSet` with\n * the changes. This immutability offers benefits like predictable state\n * management and easier reasoning about your code.\n *\n * ## What Problem Does It Solve?\n *\n * `HashSet` solves the problem of maintaining an unsorted collection where each\n * value appears exactly once, with fast operations for checking membership and\n * adding/removing values.\n *\n * ## When to Use\n *\n * Use `HashSet` when you need:\n *\n * - A collection with no duplicate values\n * - Efficient membership testing (**`O(1)`** average complexity)\n * - Set operations like union, intersection, and difference\n * - An immutable data structure that preserves functional programming patterns\n *\n * ## Advanced Features\n *\n * HashSet provides operations for:\n *\n * - Transforming sets with map and flatMap\n * - Filtering elements with filter\n * - Combining sets with union, intersection and difference\n * - Performance optimizations via mutable operations in controlled contexts\n *\n * ## Performance Characteristics\n *\n * - **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time\n *   complexity\n * - **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time\n *   complexity\n * - **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average\n *   time complexity\n * - **Set** operations ({@link module:HashSet.union},\n *   {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the\n *   smaller set\n * - **Iteration**: **`O(n)`** where n is the size of the set\n *\n * The HashSet data structure implements the following traits:\n *\n * - {@link Iterable}: allows iterating over the values in the set\n * - {@link Equal}: allows comparing two sets for value-based equality\n * - {@link Pipeable}: allows chaining operations with the pipe operator\n * - {@link Inspectable}: allows inspecting the contents of the set\n *\n * ## Operations Reference\n *\n * | Category     | Operation                           | Description                                 | Complexity |\n * | ------------ | ----------------------------------- | ------------------------------------------- | ---------- |\n * | constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |\n * | constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |\n * | constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |\n * |              |                                     |                                             |            |\n * | elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |\n * | elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |\n * | elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |\n * | elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |\n * |              |                                     |                                             |            |\n * | getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |\n * | getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |\n * | getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |\n * |              |                                     |                                             |            |\n * | mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |\n * | mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |\n * | mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |\n * |              |                                     |                                             |            |\n * | operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |\n * | operations   | {@link module:HashSet.intersection} | Computes set intersection (A ∩ B)           | O(n)       |\n * | operations   | {@link module:HashSet.union}        | Computes set union (A ∪ B)                  | O(n)       |\n * |              |                                     |                                             |            |\n * | mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |\n * |              |                                     |                                             |            |\n * | sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |\n * |              |                                     |                                             |            |\n * | traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |\n * |              |                                     |                                             |            |\n * | folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |\n * |              |                                     |                                             |            |\n * | filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |\n * |              |                                     |                                             |            |\n * | partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |\n *\n * ## Notes\n *\n * ### Composability with the Effect Ecosystem:\n *\n * This `HashSet` is designed to work seamlessly within the Effect ecosystem. It\n * implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and\n * {@link Inspectable} traits from Effect. This ensures compatibility with other\n * Effect data structures and functionalities. For example, you can easily use\n * Effect's `pipe` method to chain operations on the `HashSet`.\n *\n * **Equality of Elements with Effect's {@link Equal `Equal`} Trait:**\n *\n * This `HashSet` relies on Effect's {@link Equal} trait to determine the\n * uniqueness of elements within the set. The way equality is checked depends on\n * the type of the elements:\n *\n * - **Primitive Values:** For primitive JavaScript values like strings, numbers,\n *   booleans, `null`, and `undefined`, equality is determined by their value\n *   (similar to the `===` operator).\n * - **Objects and Custom Types:** For objects and other custom types, equality is\n *   determined by whether those types implement the {@link Equal} interface\n *   themselves. If an element type implements `Equal`, the `HashSet` will\n *   delegate to that implementation to perform the equality check. This allows\n *   you to define custom logic for determining when two instances of your\n *   objects should be considered equal based on their properties, rather than\n *   just their object identity.\n *\n * ```ts\n * import { Equal, Hash, HashSet } from \"effect\"\n *\n * class Person implements Equal.Equal {\n *   constructor(\n *     readonly id: number, // Unique identifier\n *     readonly name: string,\n *     readonly age: number\n *   ) {}\n *\n *   // Define equality based on id, name, and age\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Person) {\n *       return (\n *         Equal.equals(this.id, that.id) &&\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.age, that.age)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the unique id\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.id)\n *   }\n * }\n *\n * // Creating a HashSet with objects that implement the Equal interface\n * const set = HashSet.empty().pipe(\n *   HashSet.add(new Person(1, \"Alice\", 30)),\n *   HashSet.add(new Person(1, \"Alice\", 30))\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set))\n * // Output: 1\n * ```\n *\n * **Simplifying Equality and Hashing with `Data` and `Schema`:**\n *\n * Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful\n * ways to automatically handle the implementation of both the {@link Equal} and\n * {@link Hash} traits for your custom data structures.\n *\n * - **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,\n *   `Data.array`, or `Data.case` to define your data types, Effect\n *   automatically generates the necessary implementations for value-based\n *   equality and consistent hashing. This significantly reduces boilerplate and\n *   ensures correctness.\n *\n * ```ts\n * import { HashSet, Data, Equal } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Data.* implements the `Equal` traits for us\n * const person1 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2))\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * - **`Schema` Module:** When defining data schemas using the {@link Schema}\n *   module, you can use `Schema.Data` to automatically include the `Equal` and\n *   `Hash` traits in the decoded objects. This is particularly important when\n *   working with `HashSet`. **For decoded objects to be correctly recognized as\n *   equal within a `HashSet`, ensure that the schema for those objects is\n *   defined using `Schema.Data`.**\n *\n * ```ts\n * import { Equal, HashSet, Schema } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Schema.Data implements the `Equal` traits for us\n * const PersonSchema = Schema.Data(\n *   Schema.Struct({\n *     id: Schema.Number,\n *     name: Schema.String,\n *     age: Schema.Number\n *   })\n * )\n *\n * const Person = Schema.decode(PersonSchema)\n *\n * const person1 = Person({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Person({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2)) // Output: true\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * ### Interoperability with the JavaScript Runtime:\n *\n * To interoperate with the regular JavaScript runtime, Effect's `HashSet`\n * provides methods to access its elements in formats readily usable by\n * JavaScript APIs: {@link values `HashSet.values`},\n * {@link toValues `HashSet.toValues`}\n *\n * ```ts\n * import { HashSet } from \"effect\"\n *\n * const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)\n *\n * // Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>\n * const iterable: IterableIterator<number> = HashSet.values(hashSet)\n *\n * console.log(...iterable) // Logs:  1 2 3\n *\n * // Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>\n * const array: Array<number> = HashSet.toValues(hashSet)\n *\n * console.log(array) // Logs: [ 1, 2, 3 ]\n * ```\n *\n * Be mindful of performance implications (both time and space complexity) when\n * frequently converting between Effect's immutable HashSet and mutable\n * JavaScript data structures, especially for large collections.\n *\n * @module HashSet\n * @since 2.0.0\n */\nimport * as HS from \"./internal/hashSet.js\";\nconst TypeId = HS.HashSetTypeId;\n/**\n * @memberof HashSet\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashSet = HS.isHashSet;\n/**\n * Creates an empty `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // Provide a type argument to create a HashSet of a specific type\n *     HashSet.empty<number>(),\n *     HashSet.add(1),\n *     HashSet.add(1), // Notice the duplicate\n *     HashSet.add(2),\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}\n */\nexport const empty = HS.empty;\n/**\n * Creates a new `HashSet` from an iterable collection of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the iterable\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * // Creating a HashSet from an Array\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2, 3, 4, 5]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Set\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     new Set([\"apple\", \"banana\", \"orange\", \"apple\"]), // Set<string> is an Iterable<string>\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [\"apple\", \"banana\", \"orange\"]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Generator\n * import { HashSet } from \"effect\"\n *\n * // Generator functions return iterables\n * function* fibonacci(n: number): Generator<number, void, unknown> {\n *   let [a, b] = [0, 1]\n *   for (let i = 0; i < n; i++) {\n *     yield a\n *     ;[a, b] = [b, a + b]\n *   }\n * }\n *\n * // Create a HashSet from the first 10 Fibonacci numbers\n * const fibonacciSet = HashSet.fromIterable(fibonacci(10))\n *\n * console.log(HashSet.toValues(fibonacciSet))\n * // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n * ```\n *\n * @example\n *\n * ```ts\n * //  Creating a HashSet from another HashSet\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n *     HashSet.make(1, 2, 3, 4),\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Output: [1, 2, 3, 4]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from other Effect's data structures like Chunk\n * import { Chunk, HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     Chunk.make(1, 2, 3, 4), // Iterable<number>\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Outputs: [1, 2, 3, 4]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}\n */\nexport const fromIterable = HS.fromIterable;\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { Equal, Hash, HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * class Character implements Equal.Equal {\n *   readonly name: string\n *   readonly trait: string\n *\n *   constructor(name: string, trait: string) {\n *     this.name = name\n *     this.trait = trait\n *   }\n *\n *   // Define equality based on name, and trait\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Character) {\n *       return (\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.trait, that.trait)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the sum of the character's name and trait\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.name + this.trait)\n *   }\n *\n *   static readonly of = (name: string, trait: string): Character => {\n *     return new Character(name, trait)\n *   }\n * }\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     // Is the same as adding each character to an empty set\n *     pipe(\n *       HashSet.empty(),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")), // Alice tried to attend twice!\n *       HashSet.add(Character.of(\"White Rabbit\", \"Always late\")),\n *       HashSet.add(Character.of(\"Mad Hatter\", \"Tea enthusiast\"))\n *     )\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal\"\n * )\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     HashSet.fromIterable([\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ])\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.fromIterable` should be equal\"\n * )\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}\n */\nexport const make = HS.make;\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n *\n * // or with `data-first` API\n * HashSet.has(HashSet.make(0, 1, 2), 3) // false\n * ```\n *\n * @returns A `boolean` signaling the presence of the value in the HashSet\n * @see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const has = HS.has;\n/**\n * Check if a predicate holds true for some `HashSet` element.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.some((n) => n > 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.some((n) => n > 0)) // true\n *\n * // or with `data-first` API\n * HashSet.some(set, (n) => n > 0) // true\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const some = HS.some;\n/**\n * Check if a predicate holds true for every `HashSet` element.\n *\n * Time complexity is **`O(n)`** as it needs to traverse the whole HashSet\n * collection\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const numberOrString = HashSet.make(1, \"1\", \"one\", \"uno\")\n *\n * // with `data-last`, a.k.a. `pipeable` API and `Refinement`\n * pipe(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   HashSet.every(Predicate.isString)\n * ) // HashSet.HashSet<string>\n *\n * // or piped with the pipe function and  `Refinement`\n * numberOrString // HashSet.HashSet<number | string>\n *   .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API and `Refinement`\n * HashSet.every(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   Predicate.isString\n * ) // HashSet.HashSet<string>\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe } from \"effect\"\n *\n * const set = HashSet.make(1, 2, 3)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.every((n) => n >= 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.every((n) => n >= 0)) // true\n *\n * // or with `data-first` API\n * HashSet.every(set, (n) => n >= 0) // true\n * ```\n *\n * @returns A boolean once it has evaluated that whole collection fulfill the\n *   Predicate function\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}\n */\nexport const every = HS.every;\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * Time complexity analysis is of **`O(n)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set1 = HashSet.make(0, 1)\n * const set2 = HashSet.make(1, 2)\n * const set3 = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(set1, HashSet.isSubset(set2)) // false\n * pipe(set1, HashSet.isSubset(set3)) // true\n *\n * // or piped with the pipe function\n * set1.pipe(HashSet.isSubset(set2)) // false\n * set1.pipe(HashSet.isSubset(set3)) // true\n *\n * // or with `data-first` API\n * HashSet.isSubset(set1, set2) // false\n * HashSet.isSubset(set1, set3) // true)\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}\n */\nexport const isSubset = HS.isSubset;\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * const numberIterable = pipe(\n *   HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n *   HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n * )\n *\n * for (const number of numberIterable) {\n *   console.log(number) // it will logs: 0, 1, 2\n * }\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}\n */\nexport const values = HS.values;\n/**\n * Returns an `Array` of the values within the `HashSet`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 3.13.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import { deepStrictEqual } from \"node:assert/strict\"\n *\n * deepStrictEqual(\n *   pipe(\n *     HashSet.make(0, 1, 1, 2), // HashSet<number>\n *     HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n *   ),\n *   Array.of(0, 1, 2)\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.size}\n */\nexport const toValues = self => Array.from(values(self));\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n *\n * assert.deepStrictEqual(\n *   pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n *   4\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}\n */\nexport const size = HS.size;\n/**\n * Creates a new mutable version of the `HashSet`\n *\n * When a `HashSet` is mutable, operations like {@link add} and {@link remove}\n * modify the data structure in place instead of creating a new one, which is\n * more efficient when performing multiple operations.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * const UPPER_BOUND = 10_000\n *\n * const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n *\n * // Create a mutable version of the immutableSet\n * const mutableSet = HashSet.beginMutation(immutableSet)\n *\n * for (let i = 1; i < UPPER_BOUND; i++) {\n *   // Operations now modify the set in place instead of creating new instances\n *   // This is more efficient when making multiple changes\n *   const pointerToMutableSet = HashSet.add(mutableSet, i)\n *\n *   // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n *   assert(Object.is(mutableSet, pointerToMutableSet))\n *   assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n *   assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n * }\n *\n * const next = UPPER_BOUND + 1\n * // When done, mark the set as immutable again\n * HashSet.endMutation(mutableSet).pipe(\n *   HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n * )\n * assert.equal(HashSet.has(mutableSet, next), false)\n *\n * console.log(HashSet.toValues(immutableSet)) // [0]\n * console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const beginMutation = HS.beginMutation;\n/**\n * Makes the `HashSet` immutable again.\n *\n * After calling `endMutation`, operations like {@link add} and {@link remove}\n * will create new instances of the `HashSet` instead of modifying the existing\n * one.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Create a mutable set\n * const mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n *\n * // Add some elements to the mutable set\n * HashSet.add(mutableSet, 1)\n * HashSet.add(mutableSet, 2)\n *\n * // Before endMutation, operations modify the set in place\n * const sameSet = HashSet.add(mutableSet, 3)\n * assert(Object.is(mutableSet, sameSet)) // true - same object reference\n * assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n *\n * // Make the set immutable again\n * const immutableSet = HashSet.endMutation(mutableSet)\n *\n * // endMutation returns the same set instance, now made immutable\n * assert(Object.is(mutableSet, immutableSet)) // true - same object reference\n *\n * // After endMutation, operations create new instances\n * const newSet = HashSet.add(immutableSet, 4)\n * assert(!Object.is(immutableSet, newSet)) // false - different object references\n *\n * // The original set remains unchanged\n * assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n *\n * // The new set contains the added element\n * assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.mutate}\n */\nexport const endMutation = HS.endMutation;\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * You can consider it a functional abstraction on top of the lower-level\n * mutation primitives of {@link module:HashSet.beginMutation} `->` `mutable\n * context` `->` {@link HashSet.endMutation}.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(\n *   HashSet.make(1, 2, 3),\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or with data-first API\n * HashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n *   HashSet.add(set, 4)\n *   HashSet.remove(set, 1)\n * })\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation}\n */\nexport const mutate = HS.mutate;\n/**\n * Adds a value to the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @remarks\n * Remember that a `HashSet` is a collection of unique values, so adding a value\n * that already exists in the `HashSet` will not add a duplicate.\n *\n * Remember that HashSet is an immutable data structure, so the `add` function,\n * like all other functions that modify the HashSet, will return a new HashSet\n * with the added value.\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n *\n * // or piped with the pipe function\n * HashSet.empty().pipe(HashSet.add(0))\n *\n * // or with data-first API\n * HashSet.add(HashSet.empty(), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const add = HS.add;\n/**\n * Removes a value from the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n *\n * // or with `data-first` API\n * HashSet.remove(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const remove = HS.remove;\n/**\n * Computes the set difference `(A - B)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same; meaning we cannot compute a difference between a `HashSet\n * of bananas` and a `HashSet of elephants` as they are not the same type and\n * won't implement the Equal trait in the same way.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.intersection} {@link module:HashSet.union}\n */\nexport const difference = HS.difference;\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`. Computes set intersection (A ∩ B)\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the smaller\n * set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or with data-first API\n * HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.union}\n */\nexport const intersection = HS.intersection;\n/**\n * Computes the set union `( self ∪ that )` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.intersection}\n */\nexport const union = HS.union;\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n *\n * // or with `data-first` API\n * HashSet.toggle(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @returns A new `HashSet` where the toggled value is being either added or\n *   removed based on the initial `HashSet` state.\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const toggle = HS.toggle;\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category mapping\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.map(String) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.map(String))\n *\n * // or with `data-first` API\n * HashSet.map(HashSet.make(0, 1, 2), String)\n * ```\n */\nexport const map = HS.map;\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category sequencing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2) // HashSet.HashSet<number>\n *   .pipe(\n *     HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n *   )\n *\n * // or with `data-first` API\n * HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))\n * ```\n */\nexport const flatMap = HS.flatMap;\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category traversing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or with `data-first` API\n * HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2\n * ```\n */\nexport const forEach = HS.forEach;\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category folding\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const sum = (a: number, b: number): number => a + b\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n *\n * // or with `data-first` API\n * HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)\n * ```\n */\nexport const reduce = HS.reduce;\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category filtering\n * @example\n *\n * ```ts\n * // Syntax with  Predicate\n * import { HashSet, type Predicate, pipe } from \"effect\"\n *\n * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(-2, -1, 0, 1, 2),\n *   HashSet.filter(filterPositiveNumbers)\n * )\n *\n * // or with the pipe method\n * HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n *\n * // or with `data-first` API\n * HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)\n * ```\n *\n * @example\n *\n * ```ts\n * /// Syntax with Refinement\n * import { HashSet, pipe } from \"effect\"\n *\n * const stringRefinement = (value: unknown): value is string =>\n *   typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // // HashSet.HashSet<number | string>\n *   HashSet.filter(stringRefinement)\n * ) // HashSet.HashSet<string>\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\") // HashSet.HashSet<number | string>\n *   .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API\n * HashSet.filter(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // HashSet.HashSet<number | string>\n *   stringRefinement\n * ) // HashSet.HashSet<string>\n * ```\n */\nexport const filter = HS.filter;\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * Time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category partitioning\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2, 3, 4, 5),\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2, 3, 4, 5).pipe(\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const stringRefinement: Predicate.Refinement<string | number, string> = (\n *   value\n * ) => typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\").pipe(\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   stringRefinement\n * )\n * ```\n */\nexport const partition = HS.partition;\n//# sourceMappingURL=HashSet.js.map",
      "start": 1768772628413,
      "end": 1768772628413
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628413,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
