{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/STM.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Cause from \"./Cause.js\";\nimport * as Chunk from \"./Chunk.js\";\nimport * as core from \"./internal/stm/core.js\";\nimport * as stm from \"./internal/stm/stm.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const STMTypeId = core.STMTypeId;\n/**\n * Returns `true` if the provided value is an `STM`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isSTM = core.isSTM;\n/**\n * Treats the specified `acquire` transaction as the acquisition of a\n * resource. The `acquire` transaction will be executed interruptibly. If it\n * is a success and is committed the specified `release` workflow will be\n * executed uninterruptibly as soon as the `use` workflow completes execution.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const acquireUseRelease = stm.acquireUseRelease;\n/**\n * Runs all the provided transactional effects in sequence respecting the\n * structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record /\n * struct.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const all = stm.all;\n/**\n * Maps the success value of this effect to the specified constant value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const as = stm.as;\n/**\n * Maps the success value of this effect to an optional value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asSome = stm.asSome;\n/**\n * Maps the error value of this effect to an optional value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asSomeError = stm.asSomeError;\n/**\n * This function maps the success value of an `STM` to `void`. If the original\n * `STM` succeeds, the returned `STM` will also succeed. If the original `STM`\n * fails, the returned `STM` will fail with the same error.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asVoid = stm.asVoid;\n/**\n * Creates an `STM` value from a partial (but pure) function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const attempt = stm.attempt;\n/**\n * Recovers from all errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchAll = core.catchAll;\n/**\n * Recovers from some or all of the error cases.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchSome = stm.catchSome;\n/**\n * Recovers from the specified tagged error.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchTag = stm.catchTag;\n/**\n * Recovers from multiple tagged errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchTags = stm.catchTags;\n/**\n * Checks the condition, and if it's true, returns unit, otherwise, retries.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const check = stm.check;\n/**\n * Simultaneously filters and maps the value produced by this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const collect = stm.collect;\n/**\n * Simultaneously filters and maps the value produced by this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const collectSTM = stm.collectSTM;\n/**\n * Commits this transaction atomically.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const commit = core.commit;\n/**\n * Commits this transaction atomically, regardless of whether the transaction\n * is a success or a failure.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const commitEither = stm.commitEither;\n/**\n * Similar to Either.cond, evaluate the predicate, return the given A as\n * success if predicate returns true, and the given E as error otherwise\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cond = stm.cond;\n/**\n * Retrieves the environment inside an stm.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const context = core.context;\n/**\n * Accesses the environment of the transaction to perform a transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWith = core.contextWith;\n/**\n * Accesses the environment of the transaction to perform a transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWithSTM = core.contextWithSTM;\n/**\n * Transforms the environment being provided to this effect with the specified\n * function.\n *\n * @since 2.0.0\n * @category context\n */\nexport const mapInputContext = core.mapInputContext;\n/**\n * Fails the transactional effect with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const die = core.die;\n/**\n * Kills the fiber running the effect with a `Cause.RuntimeException` that\n * contains the specified message.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieMessage = core.dieMessage;\n/**\n * Fails the transactional effect with the specified lazily evaluated defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieSync = core.dieSync;\n/**\n * Converts the failure channel into an `Either`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const either = stm.either;\n/**\n * Executes the specified finalization transaction whether or not this effect\n * succeeds. Note that as with all STM transactions, if the full transaction\n * fails, everything will be rolled back.\n *\n * @since 2.0.0\n * @category finalization\n */\nexport const ensuring = core.ensuring;\n/**\n * Returns an effect that ignores errors and runs repeatedly until it\n * eventually succeeds.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const eventually = stm.eventually;\n/**\n * Determines whether all elements of the `Iterable<A>` satisfy the effectual\n * predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const every = stm.every;\n/**\n * Determines whether any element of the `Iterable[A]` satisfies the effectual\n * predicate `f`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const exists = stm.exists;\n/**\n * Fails the transactional effect with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail = core.fail;\n/**\n * Fails the transactional effect with the specified lazily evaluated error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failSync = core.failSync;\n/**\n * Returns the fiber id of the fiber committing the transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fiberId = stm.fiberId;\n/**\n * Filters the collection using the specified effectual predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const filter = stm.filter;\n/**\n * Filters the collection using the specified effectual predicate, removing\n * all elements that satisfy the predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const filterNot = stm.filterNot;\n/**\n * Dies with specified defect if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrDie = stm.filterOrDie;\n/**\n * Dies with a `Cause.RuntimeException` having the specified  message if the\n * predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrDieMessage = stm.filterOrDieMessage;\n/**\n * Supplies `orElse` if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrElse = stm.filterOrElse;\n/**\n * Fails with the specified error if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrFail = stm.filterOrFail;\n/**\n * Feeds the value produced by this effect to the specified function, and then\n * runs the returned effect as well to produce its results.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = core.flatMap;\n/**\n * Flattens out a nested `STM` effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten = stm.flatten;\n/**\n * Flips the success and failure channels of this transactional effect. This\n * allows you to use all methods on the error channel, possibly before\n * flipping back.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const flip = stm.flip;\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const flipWith = stm.flipWith;\n/**\n * Folds over the `STM` effect, handling both failure and success, but not\n * retry.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match = stm.match;\n/**\n * Effectfully folds over the `STM` effect, handling both failure and success.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const matchSTM = core.matchSTM;\n/**\n * Applies the function `f` to each element of the `Iterable<A>` and returns\n * a transactional effect that produces a new `Chunk<A2>`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach = stm.forEach;\n/**\n * Lifts an `Either` into a `STM`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEither = stm.fromEither;\n/**\n * Lifts an `Option` into a `STM`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromOption = stm.fromOption;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gen = stm.gen;\n/**\n * Returns a successful effect with the head of the list if the list is\n * non-empty or fails with the error `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = stm.head;\nconst if_ = stm.if_;\nexport {\n/**\n * Runs `onTrue` if the result of `b` is `true` and `onFalse` otherwise.\n *\n * @since 2.0.0\n * @category mutations\n */\nif_ as if };\n/**\n * Returns a new effect that ignores the success or failure of this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const ignore = stm.ignore;\n/**\n * Interrupts the fiber running the effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interrupt = core.interrupt;\n/**\n * Interrupts the fiber running the effect with the specified `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interruptAs = core.interruptAs;\n/**\n * Returns whether this transactional effect is a failure.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFailure = stm.isFailure;\n/**\n * Returns whether this transactional effect is a success.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isSuccess = stm.isSuccess;\n/**\n * Iterates with the specified transactional function. The moral equivalent\n * of:\n *\n * ```ts skip-type-checking\n * const s = initial\n *\n * while (cont(s)) {\n *   s = body(s)\n * }\n *\n * return s\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const iterate = stm.iterate;\n/**\n * Loops with the specified transactional function, collecting the results\n * into a list. The moral equivalent of:\n *\n * ```ts skip-type-checking\n * const as = []\n * let s  = initial\n *\n * while (cont(s)) {\n *   as.push(body(s))\n *   s  = inc(s)\n * }\n *\n * return as\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const loop = stm.loop;\n/**\n * Maps the value produced by the effect.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = core.map;\n/**\n * Maps the value produced by the effect with the specified function that may\n * throw exceptions but is otherwise pure, translating any thrown exceptions\n * into typed failed effects.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapAttempt = stm.mapAttempt;\n/**\n * Returns an `STM` effect whose failure and success channels have been mapped\n * by the specified pair of functions, `f` and `g`.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapBoth = stm.mapBoth;\n/**\n * Maps from one error type to another.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapError = stm.mapError;\n/**\n * Returns a new effect where the error channel has been merged into the\n * success channel to their common combined type.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const merge = stm.merge;\n/**\n * Merges an `Iterable<STM>` to a single `STM`, working sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const mergeAll = stm.mergeAll;\n/**\n * Returns a new effect where boolean value of this effect is negated.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const negate = stm.negate;\n/**\n * Requires the option produced by this value to be `None`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const none = stm.none;\n/**\n * Converts the failure channel into an `Option`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const option = stm.option;\n/**\n * Translates `STM` effect failure into death of the fiber, making all\n * failures unchecked and not a part of the type of the effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orDie = stm.orDie;\n/**\n * Keeps none of the errors, and terminates the fiber running the `STM` effect\n * with them, using the specified function to convert the `E` into a defect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orDieWith = stm.orDieWith;\n/**\n * Tries this effect first, and if it fails or retries, tries the other\n * effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElse = stm.orElse;\n/**\n * Returns a transactional effect that will produce the value of this effect\n * in left side, unless it fails or retries, in which case, it will produce\n * the value of the specified effect in right side.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseEither = stm.orElseEither;\n/**\n * Tries this effect first, and if it fails or retries, fails with the\n * specified error.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseFail = stm.orElseFail;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails with the `None` value, in which case it will produce the value of the\n * specified effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseOptional = stm.orElseOptional;\n/**\n * Tries this effect first, and if it fails or retries, succeeds with the\n * specified value.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseSucceed = stm.orElseSucceed;\n/**\n * Tries this effect first, and if it enters retry, then it tries the other\n * effect. This is an equivalent of Haskell's orElse.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orTry = core.orTry;\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in a tupled fashion.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const partition = stm.partition;\n/**\n * Provides the transaction its required environment, which eliminates its\n * dependency on `R`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideContext = stm.provideContext;\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideSomeContext = stm.provideSomeContext;\n/**\n * Provides the effect with the single service it requires. If the transactional\n * effect requires more than one service use `provideEnvironment` instead.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideService = stm.provideService;\n/**\n * Provides the effect with the single service it requires. If the transactional\n * effect requires more than one service use `provideEnvironment` instead.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideServiceSTM = stm.provideServiceSTM;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from left to right.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduce = stm.reduce;\n/**\n * Reduces an `Iterable<STM>` to a single `STM`, working sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduceAll = stm.reduceAll;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from right to left.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduceRight = stm.reduceRight;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const refineOrDie = stm.refineOrDie;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using the\n * specified function to convert the `E` into a `Throwable`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const refineOrDieWith = stm.refineOrDieWith;\n/**\n * Fail with the returned value if the `PartialFunction` matches, otherwise\n * continue with our held value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const reject = stm.reject;\n/**\n * Continue with the returned computation if the specified partial function\n * matches, translating the successful match into a failure, otherwise continue\n * with our held value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const rejectSTM = stm.rejectSTM;\n/**\n * Repeats this `STM` effect until its result satisfies the specified\n * predicate.\n *\n * **WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\n * consume a thread until it completes (it cannot yield). This is because STM\n * describes a single atomic transaction which must either complete, retry or\n * fail a transaction before yielding back to the Effect runtime.\n *   - Use `retryUntil` instead if you don't need to maintain transaction\n *     state for repeats.\n *   - Ensure repeating the STM effect will eventually satisfy the predicate.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const repeatUntil = stm.repeatUntil;\n/**\n * Repeats this `STM` effect while its result satisfies the specified\n * predicate.\n *\n * **WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\n * consume a thread until it completes (it cannot yield). This is because STM\n * describes a single atomic transaction which must either complete, retry or\n * fail a transaction before yielding back to the Effect runtime.\n *   - Use `retryWhile` instead if you don't need to maintain transaction\n *     state for repeats.\n *   - Ensure repeating the STM effect will eventually not satisfy the\n *     predicate.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const repeatWhile = stm.repeatWhile;\n/**\n * Replicates the given effect n times. If 0 or negative numbers are given, an\n * empty `Chunk` will be returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicate = stm.replicate;\n/**\n * Performs this transaction the specified number of times and collects the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicateSTM = stm.replicateSTM;\n/**\n * Performs this transaction the specified number of times, discarding the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicateSTMDiscard = stm.replicateSTMDiscard;\n/**\n * Abort and retry the whole transaction when any of the underlying\n * transactional variables have changed.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const retry = core.retry;\n/**\n * Filters the value produced by this effect, retrying the transaction until\n * the predicate returns `true` for the value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retryUntil = stm.retryUntil;\n/**\n * Filters the value produced by this effect, retrying the transaction while\n * the predicate returns `true` for the value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retryWhile = stm.retryWhile;\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const some = stm.some;\n/**\n * Returns an `STM` effect that succeeds with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed = core.succeed;\n/**\n * Returns an effect with the empty value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeedNone = stm.succeedNone;\n/**\n * Returns an effect with the optional value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeedSome = stm.succeedSome;\n/**\n * Summarizes a `STM` effect by computing a provided value before and after\n * execution, and then combining the values to produce a summary, together\n * with the result of execution.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const summarized = stm.summarized;\n/**\n * Suspends creation of the specified transaction lazily.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const suspend = stm.suspend;\n/**\n * Returns an `STM` effect that succeeds with the specified lazily evaluated\n * value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync = core.sync;\n/**\n * \"Peeks\" at the success of transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tap = stm.tap;\n/**\n * \"Peeks\" at both sides of an transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tapBoth = stm.tapBoth;\n/**\n * \"Peeks\" at the error of the transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tapError = stm.tapError;\nconst try_ = stm.try_;\nexport {\n/**\n * Imports a synchronous side-effect into a pure value, translating any thrown\n * exceptions into typed failed effects.\n *\n * @since 2.0.0\n * @category constructors\n */\ntry_ as try };\n/**\n * The moral equivalent of `if (!p) exp`\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const unless = stm.unless;\n/**\n * The moral equivalent of `if (!p) exp` when `p` has side-effects\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const unlessSTM = stm.unlessSTM;\n/**\n * Converts an option on errors into an option on values.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const unsome = stm.unsome;\nconst void_ = stm.void;\nexport {\n/**\n * Returns an `STM` effect that succeeds with `void`.\n *\n * @since 2.0.0\n * @category constructors\n */\nvoid_ as void };\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors in error\n * channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use `STM.partition`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const validateAll = stm.validateAll;\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const validateFirst = stm.validateFirst;\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const when = stm.when;\n/**\n * The moral equivalent of `if (p) exp` when `p` has side-effects.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const whenSTM = stm.whenSTM;\n/**\n * Sequentially zips this value with the specified one.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip = core.zip;\n/**\n * Sequentially zips this value with the specified one, discarding the second\n * element of the tuple.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft = core.zipLeft;\n/**\n * Sequentially zips this value with the specified one, discarding the first\n * element of the tuple.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight = core.zipRight;\n/**\n * Sequentially zips this value with the specified one, combining the values\n * using the specified combiner function.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith = core.zipWith;\n/**\n * This function takes an iterable of `STM` values and returns a new\n * `STM` value that represents the first `STM` value in the iterable\n * that succeeds. If all of the `Effect` values in the iterable fail, then\n * the resulting `STM` value will fail as well.\n *\n * This function is sequential, meaning that the `STM` values in the\n * iterable will be executed in sequence, and the first one that succeeds\n * will determine the outcome of the resulting `STM` value.\n *\n * Returns a new `STM` value that represents the first successful\n * `STM` value in the iterable, or a failed `STM` value if all of the\n * `STM` values in the iterable fail.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const firstSuccessOf = effects => suspend(() => {\n  const list = Chunk.fromIterable(effects);\n  if (!Chunk.isNonEmpty(list)) {\n    return dieSync(() => new Cause.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  return Chunk.reduce(Chunk.tailNonEmpty(list), Chunk.headNonEmpty(list), (left, right) => orElse(left, () => right));\n});\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const Do = /*#__PURE__*/succeed({});\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bind = stm.bind;\nconst let_ = stm.let_;\nexport {\n/**\n * @category do notation\n * @since 2.0.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo = stm.bindTo;\n//# sourceMappingURL=STM.js.map",
      "start": 1768772628413,
      "end": 1768772628413
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628413,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628419,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628478,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
