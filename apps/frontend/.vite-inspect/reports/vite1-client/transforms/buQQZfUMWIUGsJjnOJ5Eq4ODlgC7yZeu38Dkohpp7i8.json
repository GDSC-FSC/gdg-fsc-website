{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/HttpApp.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as Cause from \"effect/Cause\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as Exit from \"effect/Exit\";\nimport * as Fiber from \"effect/Fiber\";\nimport * as GlobalValue from \"effect/GlobalValue\";\nimport * as Layer from \"effect/Layer\";\nimport * as Option from \"effect/Option\";\nimport * as Runtime from \"effect/Runtime\";\nimport * as Scope from \"effect/Scope\";\nimport * as Stream from \"effect/Stream\";\nimport { unify } from \"effect/Unify\";\nimport * as HttpBody from \"./HttpBody.js\";\nimport * as ServerError from \"./HttpServerError.js\";\nimport * as ServerRequest from \"./HttpServerRequest.js\";\nimport * as ServerResponse from \"./HttpServerResponse.js\";\nimport * as internal from \"./internal/httpApp.js\";\nimport * as internalMiddleware from \"./internal/httpMiddleware.js\";\nconst handledSymbol = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApp/handled\");\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toHandled = (self, handleResponse, middleware) => {\n  const responded = Effect.withFiberRuntime(fiber => Effect.flatMap(self, response => {\n    const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest);\n    const handler = fiber.getFiberRef(currentPreResponseHandlers);\n    if (handler._tag === \"None\") {\n      ;\n      request[handledSymbol] = true;\n      return Effect.as(handleResponse(request, response), response);\n    }\n    return Effect.tap(handler.value(request, response), response => {\n      ;\n      request[handledSymbol] = true;\n      return handleResponse(request, response);\n    });\n  }));\n  const withErrorHandling = Effect.catchAllCause(responded, cause => Effect.withFiberRuntime(fiber => Effect.flatMap(ServerError.causeResponse(cause), ([response, cause]) => {\n    const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest);\n    const handler = fiber.getFiberRef(currentPreResponseHandlers);\n    if (handler._tag === \"None\") {\n      ;\n      request[handledSymbol] = true;\n      return Effect.zipRight(handleResponse(request, response), Cause.isEmptyType(cause) ? Effect.succeed(response) : Effect.failCause(cause));\n    }\n    return Effect.zipRight(Effect.tap(handler.value(request, response), response => {\n      ;\n      request[handledSymbol] = true;\n      return handleResponse(request, response);\n    }), Cause.isEmptyType(cause) ? Effect.succeed(response) : Effect.failCause(cause));\n  })));\n  const withMiddleware = unify(middleware === undefined ? internalMiddleware.tracer(withErrorHandling) : Effect.matchCauseEffect(internalMiddleware.tracer(middleware(withErrorHandling)), {\n    onFailure: cause => Effect.withFiberRuntime(fiber => {\n      const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest);\n      if (handledSymbol in request) {\n        return Effect.void;\n      }\n      return Effect.matchCauseEffect(ServerError.causeResponse(cause), {\n        onFailure: _cause => handleResponse(request, ServerResponse.empty({\n          status: 500\n        })),\n        onSuccess: ([response]) => handleResponse(request, response)\n      });\n    }),\n    onSuccess: response => Effect.withFiberRuntime(fiber => {\n      const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest);\n      return handledSymbol in request ? Effect.void : handleResponse(request, response);\n    })\n  }));\n  return Effect.uninterruptible(scoped(withMiddleware));\n};\n/**\n * If you want to finalize the http request scope elsewhere, you can use this\n * function to eject from the default scope closure.\n *\n * @since 1.0.0\n * @category Scope\n */\nexport const ejectDefaultScopeClose = scope => {\n  ejectedScopes.add(scope);\n};\n/**\n * @since 1.0.0\n * @category Scope\n */\nexport const unsafeEjectStreamScope = response => {\n  if (response.body._tag !== \"Stream\") {\n    return response;\n  }\n  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());\n  const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);\n  ejectDefaultScopeClose(scope);\n  return ServerResponse.setBody(response, HttpBody.stream(Stream.ensuring(response.body.stream, Scope.close(scope, Exit.void)), response.body.contentType, response.body.contentLength));\n};\nconst ejectedScopes = /*#__PURE__*/GlobalValue.globalValue(\"@effect/platform/HttpApp/ejectedScopes\", () => new WeakSet());\nconst scoped = effect => Effect.flatMap(Scope.make(), scope => Effect.onExit(Scope.extend(effect, scope), exit => {\n  if (ejectedScopes.has(scope)) {\n    return Effect.void;\n  }\n  return Scope.close(scope, exit);\n}));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentPreResponseHandlers = internal.currentPreResponseHandlers;\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const appendPreResponseHandler = internal.appendPreResponseHandler;\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withPreResponseHandler = internal.withPreResponseHandler;\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandlerRuntime = runtime => {\n  const httpRuntime = Runtime.make(runtime);\n  const run = Runtime.runFork(httpRuntime);\n  return (self, middleware) => {\n    const resolveSymbol = Symbol.for(\"@effect/platform/HttpApp/resolve\");\n    const httpApp = toHandled(self, (request, response) => {\n      response = unsafeEjectStreamScope(response);\n      request[resolveSymbol](ServerResponse.toWeb(response, {\n        withoutBody: request.method === \"HEAD\",\n        runtime\n      }));\n      return Effect.void;\n    }, middleware);\n    return (request, context) => new Promise(resolve => {\n      const contextMap = new Map(runtime.context.unsafeMap);\n      if (Context.isContext(context)) {\n        for (const [key, value] of context.unsafeMap) {\n          contextMap.set(key, value);\n        }\n      }\n      const httpServerRequest = ServerRequest.fromWeb(request);\n      contextMap.set(ServerRequest.HttpServerRequest.key, httpServerRequest);\n      httpServerRequest[resolveSymbol] = resolve;\n      httpRuntime.context = Context.unsafeMake(contextMap);\n      const fiber = run(httpApp);\n      request.signal?.addEventListener(\"abort\", () => {\n        fiber.unsafeInterruptAsFork(ServerError.clientAbortFiberId);\n      }, {\n        once: true\n      });\n    });\n  };\n};\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandler = /*#__PURE__*/toWebHandlerRuntime(Runtime.defaultRuntime);\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandlerLayerWith = (layer, options) => {\n  const scope = Effect.runSync(Scope.make());\n  const dispose = () => Effect.runPromise(Scope.close(scope, Exit.void));\n  let handlerCache;\n  let handlerPromise;\n  function handler(request, context) {\n    if (handlerCache) {\n      return handlerCache(request, context);\n    }\n    handlerPromise ??= Effect.gen(function* () {\n      const runtime = yield* options.memoMap ? Layer.toRuntimeWithMemoMap(layer, options.memoMap) : Layer.toRuntime(layer);\n      return handlerCache = toWebHandlerRuntime(runtime)(yield* options.toHandler(runtime), options.middleware);\n    }).pipe(Scope.extend(scope), Effect.runPromise);\n    return handlerPromise.then(f => f(request, context));\n  }\n  return {\n    dispose,\n    handler\n  };\n};\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandlerLayer = (self, layer, options) => toWebHandlerLayerWith(layer, {\n  ...options,\n  toHandler: () => Effect.succeed(self)\n});\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const fromWebHandler = handler => Effect.async((resume, signal) => {\n  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());\n  const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest);\n  const requestResult = ServerRequest.toWebEither(request, {\n    signal,\n    runtime: Runtime.make({\n      context: fiber.currentContext,\n      fiberRefs: fiber.getFiberRefs(),\n      runtimeFlags: Runtime.defaultRuntimeFlags\n    })\n  });\n  if (requestResult._tag === \"Left\") {\n    return resume(Effect.fail(requestResult.left));\n  }\n  handler(requestResult.right).then(response => resume(Effect.succeed(ServerResponse.fromWeb(response))), cause => resume(Effect.fail(new ServerError.RequestError({\n    cause,\n    request,\n    reason: \"Transport\",\n    description: \"HttpApp.fromWebHandler: Error in handler\"\n  }))));\n});\n//# sourceMappingURL=HttpApp.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
