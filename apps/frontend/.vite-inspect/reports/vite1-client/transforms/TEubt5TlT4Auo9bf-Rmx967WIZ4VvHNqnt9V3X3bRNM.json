{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/FiberMap.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"./Cause.js\";\nimport * as Deferred from \"./Deferred.js\";\nimport * as Effect from \"./Effect.js\";\nimport * as Exit from \"./Exit.js\";\nimport * as Fiber from \"./Fiber.js\";\nimport * as FiberId from \"./FiberId.js\";\nimport { constFalse, constVoid, dual } from \"./Function.js\";\nimport * as HashSet from \"./HashSet.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as Iterable from \"./Iterable.js\";\nimport * as MutableHashMap from \"./MutableHashMap.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport * as Predicate from \"./Predicate.js\";\nimport * as Runtime from \"./Runtime.js\";\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/FiberMap\");\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberMap = u => Predicate.hasProperty(u, TypeId);\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    if (this.state._tag === \"Closed\") {\n      return Iterable.empty();\n    }\n    return this.state.backing[Symbol.iterator]();\n  },\n  toString() {\n    return Inspectable.format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"FiberMap\",\n      state: this.state\n    };\n  },\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst unsafeMake = (backing, deferred) => {\n  const self = Object.create(Proto);\n  self.state = {\n    _tag: \"Open\",\n    backing\n  };\n  self.deferred = deferred;\n  return self;\n};\n/**\n * A FiberMap can be used to store a collection of fibers, indexed by some key.\n * When the associated Scope is closed, all fibers in the map will be interrupted.\n *\n * You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will\n * be automatically removed from the FiberMap when they complete.\n *\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *\n *   // run some effects and add the fibers to the map\n *   yield* FiberMap.run(map, \"fiber a\", Effect.never)\n *   yield* FiberMap.run(map, \"fiber b\", Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(MutableHashMap.empty(), deferred)), map => Effect.withFiberRuntime(parent => {\n  const state = map.state;\n  if (state._tag === \"Closed\") return Effect.void;\n  map.state = {\n    _tag: \"Closed\"\n  };\n  return Fiber.interruptAllAs(Iterable.map(state.backing, ([, fiber]) => fiber), FiberId.combine(parent.id(), internalFiberId)).pipe(Effect.intoDeferred(map.deferred));\n}));\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = () => Effect.flatMap(make(), self => runtime(self)());\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = () => Effect.flatMap(make(), self => runtimePromise(self)());\nconst internalFiberIdId = -1;\nconst internalFiberId = /*#__PURE__*/FiberId.make(internalFiberIdId, 0);\nconst isInternalInterruption = /*#__PURE__*/Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n});\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeSet = /*#__PURE__*/dual(args => isFiberMap(args[0]), (self, key, fiber, options) => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n    return;\n  }\n  const previous = MutableHashMap.get(self.state.backing, key);\n  if (previous._tag === \"Some\") {\n    if (options?.onlyIfMissing === true) {\n      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n      return;\n    } else if (previous.value === fiber) {\n      return;\n    }\n    previous.value.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n  }\n  MutableHashMap.set(self.state.backing, key, fiber);\n  fiber.addObserver(exit => {\n    if (self.state._tag === \"Closed\") {\n      return;\n    }\n    const current = MutableHashMap.get(self.state.backing, key);\n    if (Option.isSome(current) && fiber === current.value) {\n      MutableHashMap.remove(self.state.backing, key);\n    }\n    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {\n      Deferred.unsafeDone(self.deferred, exit);\n    }\n  });\n});\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const set = /*#__PURE__*/dual(args => isFiberMap(args[0]), (self, key, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeSet(self, key, fiber, {\n  ...options,\n  interruptAs: fiberId\n}))));\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, key) => self.state._tag === \"Closed\" ? Option.none() : MutableHashMap.get(self.state.backing, key));\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const get = /*#__PURE__*/dual(2, (self, key) => Effect.suspend(() => unsafeGet(self, key)));\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeHas = /*#__PURE__*/dual(2, (self, key) => self.state._tag === \"Closed\" ? false : MutableHashMap.has(self.state.backing, key));\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const has = /*#__PURE__*/dual(2, (self, key) => Effect.sync(() => unsafeHas(self, key)));\n/**\n * Remove a fiber from the FiberMap, interrupting it if it exists.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const remove = /*#__PURE__*/dual(2, (self, key) => Effect.withFiberRuntime(removeFiber => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.void;\n  }\n  const fiber = MutableHashMap.get(self.state.backing, key);\n  if (fiber._tag === \"None\") {\n    return Effect.void;\n  }\n  // will be removed by the observer\n  return Fiber.interruptAs(fiber.value, FiberId.combine(removeFiber.id(), internalFiberId));\n}));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = self => Effect.withFiberRuntime(clearFiber => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.void;\n  }\n  return Effect.forEach(self.state.backing, ([, fiber]) =>\n  // will be removed by the observer\n  Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)));\n});\nconst constInterruptedFiber = /*#__PURE__*/function () {\n  let fiber = undefined;\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt);\n    }\n    return fiber;\n  };\n}();\n/**\n * Run an Effect and add the forked fiber to the FiberMap.\n * When the fiber completes, it will be removed from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run = function () {\n  const self = arguments[0];\n  if (Effect.isEffect(arguments[2])) {\n    return runImpl(self, arguments[1], arguments[2], arguments[3]);\n  }\n  const key = arguments[1];\n  const options = arguments[2];\n  return effect => runImpl(self, key, effect, options);\n};\nconst runImpl = (self, key, effect, options) => Effect.withFiberRuntime(parent => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.interrupt;\n  } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n    return Effect.sync(constInterruptedFiber);\n  }\n  const runtime = Runtime.make({\n    context: parent.currentContext,\n    fiberRefs: parent.getFiberRefs(),\n    runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n  });\n  const fiber = Runtime.runFork(runtime)(effect);\n  unsafeSet(self, key, fiber, {\n    ...options,\n    interruptAs: parent.id()\n  });\n  return Effect.succeed(fiber);\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberMap } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *   const run = yield* FiberMap.runtime(map)<Users>()\n *\n *   // run some effects and add the fibers to the map\n *   run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n *   run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime = self => () => Effect.map(Effect.runtime(), runtime => {\n  const runFork = Runtime.runFork(runtime);\n  return (key, effect, options) => {\n    if (self.state._tag === \"Closed\") {\n      return constInterruptedFiber();\n    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n      return constInterruptedFiber();\n    }\n    const fiber = runFork(effect, options);\n    unsafeSet(self, key, fiber, options);\n    return fiber;\n  };\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = self => () => Effect.map(runtime(self)(), runFork => (key, effect, options) => new Promise((resolve, reject) => runFork(key, effect, options).addObserver(exit => {\n  if (Exit.isSuccess(exit)) {\n    resolve(exit.value);\n  } else {\n    reject(Cause.squash(exit.cause));\n  }\n})));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const size = self => Effect.sync(() => self.state._tag === \"Closed\" ? 0 : MutableHashMap.size(self.state.backing));\n/**\n * Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const map = yield* _(FiberMap.make());\n *   yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberMap.join(map));\n * });\n * ```\n */\nexport const join = self => Deferred.await(self.deferred);\n/**\n * Wait for the FiberMap to be empty.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = self => Effect.whileLoop({\n  while: () => self.state._tag === \"Open\" && MutableHashMap.size(self.state.backing) > 0,\n  body: () => Fiber.await(Iterable.unsafeHead(self)[1]),\n  step: constVoid\n});\n//# sourceMappingURL=FiberMap.js.map",
      "start": 1768772628410,
      "end": 1768772628410
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628410,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628416,
      "end": 1768772628420,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
