{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/JSONSchema.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 3.10.0\n */\nimport * as Arr from \"./Array.js\";\nimport * as errors_ from \"./internal/schema/errors.js\";\nimport * as schemaId_ from \"./internal/schema/schemaId.js\";\nimport * as Option from \"./Option.js\";\nimport * as ParseResult from \"./ParseResult.js\";\nimport * as Predicate from \"./Predicate.js\";\nimport * as Record from \"./Record.js\";\nimport * as AST from \"./SchemaAST.js\";\n/**\n * Generates a JSON Schema from a schema.\n *\n * **Options**\n *\n * - `target`: The target JSON Schema version. Possible values are:\n *   - `\"jsonSchema7\"`: JSON Schema draft-07 (default behavior).\n *   - `\"jsonSchema2019-09\"`: JSON Schema draft-2019-09.\n *   - `\"jsonSchema2020-12\"`: JSON Schema draft-2020-12.\n *   - `\"openApi3.1\"`: OpenAPI 3.1.\n *\n * @category encoding\n * @since 3.10.0\n */\nexport const make = (schema, options) => {\n  const definitions = {};\n  const target = options?.target ?? \"jsonSchema7\";\n  const ast = AST.isTransformation(schema.ast) && isParseJsonTransformation(schema.ast.from)\n  // Special case top level `parseJson` transformations\n  ? schema.ast.to : schema.ast;\n  const jsonSchema = fromAST(ast, {\n    definitions,\n    target\n  });\n  const out = {\n    $schema: getMetaSchemaUri(target),\n    $defs: {},\n    ...jsonSchema\n  };\n  if (Record.isEmptyRecord(definitions)) {\n    delete out.$defs;\n  } else {\n    out.$defs = definitions;\n  }\n  return out;\n};\n/** @internal */\nexport function getMetaSchemaUri(target) {\n  switch (target) {\n    case \"jsonSchema7\":\n      return \"http://json-schema.org/draft-07/schema#\";\n    case \"jsonSchema2019-09\":\n      return \"https://json-schema.org/draft/2019-09/schema\";\n    case \"jsonSchema2020-12\":\n    case \"openApi3.1\":\n      return \"https://json-schema.org/draft/2020-12/schema\";\n  }\n}\n/**\n * Returns a JSON Schema with additional options and definitions.\n *\n * **Warning**\n *\n * This function is experimental and subject to change.\n *\n * **Options**\n *\n * - `definitions`: A record of definitions that are included in the schema.\n * - `definitionPath`: The path to the definitions within the schema (defaults\n *   to \"#/$defs/\").\n * - `target`: Which spec to target. Possible values are:\n *   - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).\n *   - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.\n *   - `'openApi3.1'`: OpenAPI 3.1.\n * - `topLevelReferenceStrategy`: Controls the handling of the top-level\n *   reference. Possible values are:\n *   - `\"keep\"`: Keep the top-level reference (default behavior).\n *   - `\"skip\"`: Skip the top-level reference.\n * - `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n *   - `\"strict\"`: Disallow additional properties (default behavior).\n *   - `\"allow\"`: Allow additional properties.\n *\n * @category encoding\n * @since 3.11.5\n * @experimental\n */\nexport const fromAST = (ast, options) => {\n  const definitionPath = options.definitionPath ?? \"#/$defs/\";\n  const getRef = id => definitionPath + id;\n  const target = options.target ?? \"jsonSchema7\";\n  const topLevelReferenceStrategy = options.topLevelReferenceStrategy ?? \"keep\";\n  const additionalPropertiesStrategy = options.additionalPropertiesStrategy ?? \"strict\";\n  return go(ast, options.definitions, \"handle-identifier\", [], {\n    getRef,\n    target,\n    topLevelReferenceStrategy,\n    additionalPropertiesStrategy\n  }, \"handle-annotation\", \"handle-errors\");\n};\nconst constNever = {\n  $id: \"/schemas/never\",\n  not: {}\n};\nconst constAny = {\n  $id: \"/schemas/any\"\n};\nconst constUnknown = {\n  $id: \"/schemas/unknown\"\n};\nconst constVoid = {\n  $id: \"/schemas/void\"\n};\nconst constObject = {\n  $id: \"/schemas/object\",\n  \"anyOf\": [{\n    \"type\": \"object\"\n  }, {\n    \"type\": \"array\"\n  }]\n};\nconst constEmptyStruct = {\n  $id: \"/schemas/%7B%7D\",\n  \"anyOf\": [{\n    \"type\": \"object\"\n  }, {\n    \"type\": \"array\"\n  }]\n};\nfunction getRawDescription(annotated) {\n  if (annotated !== undefined) return Option.getOrUndefined(AST.getDescriptionAnnotation(annotated));\n}\nfunction getRawTitle(annotated) {\n  if (annotated !== undefined) return Option.getOrUndefined(AST.getTitleAnnotation(annotated));\n}\nfunction getRawDefault(annotated) {\n  if (annotated !== undefined) return AST.getDefaultAnnotation(annotated);\n  return Option.none();\n}\nfunction encodeDefault(ast, def) {\n  const getOption = ParseResult.getOption(ast, false);\n  return getOption(def);\n}\nfunction getRawExamples(annotated) {\n  if (annotated !== undefined) return Option.getOrUndefined(AST.getExamplesAnnotation(annotated));\n}\nfunction encodeExamples(ast, examples) {\n  const getOption = ParseResult.getOption(ast, false);\n  const out = Arr.filterMap(examples, e => getOption(e).pipe(Option.filter(isJsonValue)));\n  return out.length > 0 ? out : undefined;\n}\nfunction filterBuiltIn(ast, annotation, key) {\n  if (annotation !== undefined) {\n    switch (ast._tag) {\n      case \"StringKeyword\":\n        return annotation !== AST.stringKeyword.annotations[key] ? annotation : undefined;\n      case \"NumberKeyword\":\n        return annotation !== AST.numberKeyword.annotations[key] ? annotation : undefined;\n      case \"BooleanKeyword\":\n        return annotation !== AST.booleanKeyword.annotations[key] ? annotation : undefined;\n    }\n  }\n  return annotation;\n}\nfunction isJsonValue(value, visited = new Set()) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value) || typeof value === \"object\") {\n    // Check for cyclic references\n    if (visited.has(value)) {\n      return false;\n    }\n    visited.add(value);\n    try {\n      if (Array.isArray(value)) {\n        return value.every(item => isJsonValue(item, visited));\n      }\n      // Exclude non-plain objects (Date, RegExp, etc.) by checking constructor\n      const proto = Object.getPrototypeOf(value);\n      if (proto !== null && proto !== Object.prototype) {\n        return false;\n      }\n      // JSON only allows string keys, so exclude objects with Symbol keys\n      if (Object.getOwnPropertySymbols(value).length > 0) {\n        return false;\n      }\n      // Check all values are JSON values\n      return Object.values(value).every(v => isJsonValue(v, visited));\n    } finally {\n      visited.delete(value);\n    }\n  }\n  return false;\n}\nfunction pruneJsonSchemaAnnotations(ast, description, title, def, examples) {\n  const out = {};\n  if (description !== undefined) out.description = description;\n  if (title !== undefined) out.title = title;\n  if (Option.isSome(def)) {\n    const o = encodeDefault(ast, def.value);\n    if (Option.isSome(o) && isJsonValue(o.value)) {\n      out.default = o.value;\n    }\n  }\n  if (examples !== undefined) {\n    const encodedExamples = encodeExamples(ast, examples);\n    if (encodedExamples !== undefined) {\n      out.examples = encodedExamples;\n    }\n  }\n  if (Object.keys(out).length === 0) {\n    return undefined;\n  }\n  return out;\n}\nfunction getContextJsonSchemaAnnotations(ast, annotated) {\n  return pruneJsonSchemaAnnotations(ast, getRawDescription(annotated), getRawTitle(annotated), getRawDefault(annotated), getRawExamples(annotated));\n}\nfunction getJsonSchemaAnnotations(ast) {\n  return pruneJsonSchemaAnnotations(ast, filterBuiltIn(ast, getRawDescription(ast), AST.DescriptionAnnotationId), filterBuiltIn(ast, getRawTitle(ast), AST.TitleAnnotationId), getRawDefault(ast), getRawExamples(ast));\n}\nfunction mergeJsonSchemaAnnotations(jsonSchema, jsonSchemaAnnotations) {\n  if (jsonSchemaAnnotations) {\n    if (\"$ref\" in jsonSchema) {\n      return {\n        allOf: [jsonSchema],\n        ...jsonSchemaAnnotations\n      };\n    }\n    return {\n      ...jsonSchema,\n      ...jsonSchemaAnnotations\n    };\n  }\n  return jsonSchema;\n}\nconst pruneUndefined = ast => {\n  if (Option.isNone(AST.getJSONSchemaAnnotation(ast))) {\n    return AST.pruneUndefined(ast, pruneUndefined, ast => pruneUndefined(ast.from));\n  }\n};\nconst isParseJsonTransformation = ast => ast.annotations[AST.SchemaIdAnnotationId] === AST.ParseJsonSchemaId;\nconst isOverrideAnnotation = (ast, jsonSchema) => {\n  if (AST.isRefinement(ast)) {\n    const schemaId = ast.annotations[AST.SchemaIdAnnotationId];\n    if (schemaId === schemaId_.IntSchemaId) {\n      return \"type\" in jsonSchema && jsonSchema.type !== \"integer\";\n    }\n  }\n  return \"type\" in jsonSchema || \"oneOf\" in jsonSchema || \"anyOf\" in jsonSchema || \"$ref\" in jsonSchema;\n};\nconst mergeRefinements = (from, jsonSchema, ast) => {\n  const out = {\n    ...from,\n    ...getJsonSchemaAnnotations(ast),\n    ...jsonSchema\n  };\n  out.allOf ??= [];\n  const handle = (name, filter) => {\n    if (name in jsonSchema && name in from) {\n      out.allOf.unshift({\n        [name]: from[name]\n      });\n      out.allOf = out.allOf.filter(filter);\n    }\n  };\n  handle(\"minLength\", i => i.minLength > jsonSchema.minLength);\n  handle(\"maxLength\", i => i.maxLength < jsonSchema.maxLength);\n  handle(\"pattern\", i => i.pattern !== jsonSchema.pattern);\n  handle(\"minItems\", i => i.minItems > jsonSchema.minItems);\n  handle(\"maxItems\", i => i.maxItems < jsonSchema.maxItems);\n  handle(\"minimum\", i => i.minimum > jsonSchema.minimum);\n  handle(\"maximum\", i => i.maximum < jsonSchema.maximum);\n  handle(\"exclusiveMinimum\", i => i.exclusiveMinimum > jsonSchema.exclusiveMinimum);\n  handle(\"exclusiveMaximum\", i => i.exclusiveMaximum < jsonSchema.exclusiveMaximum);\n  handle(\"multipleOf\", i => i.multipleOf !== jsonSchema.multipleOf);\n  if (out.allOf.length === 0) {\n    delete out.allOf;\n  }\n  return out;\n};\nfunction isContentSchemaSupported(options) {\n  switch (options.target) {\n    case \"jsonSchema7\":\n      return false;\n    case \"jsonSchema2019-09\":\n    case \"jsonSchema2020-12\":\n    case \"openApi3.1\":\n      return true;\n  }\n}\nfunction getAdditionalProperties(options) {\n  switch (options.additionalPropertiesStrategy) {\n    case \"allow\":\n      return true;\n    case \"strict\":\n      return false;\n  }\n}\nfunction addASTAnnotations(jsonSchema, ast) {\n  return addAnnotations(jsonSchema, getJsonSchemaAnnotations(ast));\n}\nfunction addAnnotations(jsonSchema, annotations) {\n  if (annotations === undefined || Object.keys(annotations).length === 0) {\n    return jsonSchema;\n  }\n  if (\"$ref\" in jsonSchema) {\n    return {\n      allOf: [jsonSchema],\n      ...annotations\n    };\n  }\n  return {\n    ...jsonSchema,\n    ...annotations\n  };\n}\nfunction getIdentifierAnnotation(ast) {\n  const identifier = Option.getOrUndefined(AST.getJSONIdentifier(ast));\n  if (identifier === undefined) {\n    if (AST.isSuspend(ast)) {\n      return getIdentifierAnnotation(ast.f());\n    }\n    if (AST.isTransformation(ast) && AST.isTypeLiteral(ast.from) && AST.isDeclaration(ast.to)) {\n      const to = ast.to;\n      const surrogate = AST.getSurrogateAnnotation(to);\n      if (Option.isSome(surrogate)) {\n        return getIdentifierAnnotation(to);\n      }\n    }\n  }\n  return identifier;\n}\nfunction go(ast, $defs, identifier, path, options, annotation, errors) {\n  if (identifier === \"handle-identifier\" && (options.topLevelReferenceStrategy !== \"skip\" || AST.isSuspend(ast))) {\n    const id = getIdentifierAnnotation(ast);\n    if (id !== undefined) {\n      const escapedId = id.replace(/~/ig, \"~0\").replace(/\\//ig, \"~1\");\n      const out = {\n        $ref: options.getRef(escapedId)\n      };\n      if (!Record.has($defs, id)) {\n        $defs[id] = out;\n        $defs[id] = go(ast, $defs, \"ignore-identifier\", path, options, \"handle-annotation\", errors);\n      }\n      return out;\n    }\n  }\n  if (annotation === \"handle-annotation\") {\n    const hook = AST.getJSONSchemaAnnotation(ast);\n    if (Option.isSome(hook)) {\n      const handler = hook.value;\n      if (isOverrideAnnotation(ast, handler)) {\n        switch (ast._tag) {\n          case \"Declaration\":\n            return addASTAnnotations(handler, ast);\n          default:\n            return handler;\n        }\n      } else {\n        switch (ast._tag) {\n          case \"Refinement\":\n            {\n              const t = AST.getTransformationFrom(ast);\n              if (t === undefined) {\n                return mergeRefinements(go(ast.from, $defs, identifier, path, options, \"handle-annotation\", errors), handler, ast);\n              } else {\n                return go(t, $defs, identifier, path, options, \"handle-annotation\", errors);\n              }\n            }\n          default:\n            return {\n              ...go(ast, $defs, identifier, path, options, \"ignore-annotation\", errors),\n              ...handler\n            };\n        }\n      }\n    }\n  }\n  const surrogate = AST.getSurrogateAnnotation(ast);\n  if (Option.isSome(surrogate)) {\n    return go(surrogate.value, $defs, identifier, path, options, \"handle-annotation\", errors);\n  }\n  switch (ast._tag) {\n    // Unsupported\n    case \"Declaration\":\n    case \"UndefinedKeyword\":\n    case \"BigIntKeyword\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n      {\n        if (errors === \"ignore-errors\") return addASTAnnotations(constAny, ast);\n        throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));\n      }\n    case \"Suspend\":\n      {\n        if (identifier === \"handle-identifier\") {\n          if (errors === \"ignore-errors\") return addASTAnnotations(constAny, ast);\n          throw new Error(errors_.getJSONSchemaMissingIdentifierAnnotationErrorMessage(path, ast));\n        }\n        return go(ast.f(), $defs, \"ignore-identifier\", path, options, \"handle-annotation\", errors);\n      }\n    // Primitives\n    case \"NeverKeyword\":\n      return addASTAnnotations(constNever, ast);\n    case \"VoidKeyword\":\n      return addASTAnnotations(constVoid, ast);\n    case \"UnknownKeyword\":\n      return addASTAnnotations(constUnknown, ast);\n    case \"AnyKeyword\":\n      return addASTAnnotations(constAny, ast);\n    case \"ObjectKeyword\":\n      return addASTAnnotations(constObject, ast);\n    case \"StringKeyword\":\n      return addASTAnnotations({\n        type: \"string\"\n      }, ast);\n    case \"NumberKeyword\":\n      return addASTAnnotations({\n        type: \"number\"\n      }, ast);\n    case \"BooleanKeyword\":\n      return addASTAnnotations({\n        type: \"boolean\"\n      }, ast);\n    case \"Literal\":\n      {\n        const literal = ast.literal;\n        if (literal === null) {\n          return addASTAnnotations({\n            type: \"null\"\n          }, ast);\n        } else if (Predicate.isString(literal)) {\n          return addASTAnnotations({\n            type: \"string\",\n            enum: [literal]\n          }, ast);\n        } else if (Predicate.isNumber(literal)) {\n          return addASTAnnotations({\n            type: \"number\",\n            enum: [literal]\n          }, ast);\n        } else if (Predicate.isBoolean(literal)) {\n          return addASTAnnotations({\n            type: \"boolean\",\n            enum: [literal]\n          }, ast);\n        }\n        if (errors === \"ignore-errors\") return addASTAnnotations(constAny, ast);\n        throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));\n      }\n    case \"Enums\":\n      {\n        const anyOf = ast.enums.map(e => {\n          const type = Predicate.isNumber(e[1]) ? \"number\" : \"string\";\n          return {\n            type,\n            title: e[0],\n            enum: [e[1]]\n          };\n        });\n        return anyOf.length >= 1 ? addASTAnnotations({\n          $comment: \"/schemas/enums\",\n          anyOf\n        }, ast) : addASTAnnotations(constNever, ast);\n      }\n    case \"TupleType\":\n      {\n        const elements = ast.elements.map((e, i) => mergeJsonSchemaAnnotations(go(e.type, $defs, \"handle-identifier\", path.concat(i), options, \"handle-annotation\", errors), getContextJsonSchemaAnnotations(e.type, e)));\n        const rest = ast.rest.map(type => mergeJsonSchemaAnnotations(go(type.type, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors), getContextJsonSchemaAnnotations(type.type, type)));\n        const output = {\n          type: \"array\"\n        };\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        const len = ast.elements.length;\n        if (len > 0) {\n          output.minItems = len - ast.elements.filter(element => element.isOptional).length;\n          if (options.target === \"jsonSchema7\") {\n            output.items = elements;\n          } else {\n            output.prefixItems = elements;\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        const restLength = rest.length;\n        if (restLength > 0) {\n          const head = rest[0];\n          const isHomogeneous = restLength === 1 && ast.elements.every(e => e.type === ast.rest[0].type);\n          if (isHomogeneous) {\n            if (options.target === \"jsonSchema7\") {\n              output.items = head;\n            } else {\n              output.items = head;\n              delete output.prefixItems;\n            }\n          } else {\n            if (options.target === \"jsonSchema7\") {\n              output.additionalItems = head;\n            } else {\n              output.items = head;\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          if (restLength > 1) {\n            if (errors === \"ignore-errors\") return addASTAnnotations(constAny, ast);\n            throw new Error(errors_.getJSONSchemaUnsupportedPostRestElementsErrorMessage(path));\n          }\n        } else {\n          if (len > 0) {\n            if (options.target === \"jsonSchema7\") {\n              output.additionalItems = false;\n            } else {\n              output.items = false;\n            }\n          } else {\n            output.maxItems = 0;\n          }\n        }\n        return addASTAnnotations(output, ast);\n      }\n    case \"TypeLiteral\":\n      {\n        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n          return addASTAnnotations(constEmptyStruct, ast);\n        }\n        const output = {\n          type: \"object\",\n          required: [],\n          properties: {},\n          additionalProperties: getAdditionalProperties(options)\n        };\n        let patternProperties = undefined;\n        let propertyNames = undefined;\n        for (const is of ast.indexSignatures) {\n          const pruned = pruneUndefined(is.type) ?? is.type;\n          const parameter = is.parameter;\n          switch (parameter._tag) {\n            case \"StringKeyword\":\n              {\n                output.additionalProperties = go(pruned, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors);\n                break;\n              }\n            case \"TemplateLiteral\":\n              {\n                patternProperties = go(pruned, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors);\n                propertyNames = {\n                  type: \"string\",\n                  pattern: AST.getTemplateLiteralRegExp(parameter).source\n                };\n                break;\n              }\n            case \"Refinement\":\n              {\n                patternProperties = go(pruned, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors);\n                propertyNames = go(parameter, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors);\n                break;\n              }\n            case \"SymbolKeyword\":\n              {\n                const indexSignaturePath = path.concat(\"[symbol]\");\n                output.additionalProperties = go(pruned, $defs, \"handle-identifier\", indexSignaturePath, options, \"handle-annotation\", errors);\n                propertyNames = go(parameter, $defs, \"handle-identifier\", indexSignaturePath, options, \"handle-annotation\", errors);\n                break;\n              }\n          }\n        }\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < ast.propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i];\n          const name = ps.name;\n          if (Predicate.isString(name)) {\n            const pruned = pruneUndefined(ps.type);\n            const type = pruned ?? ps.type;\n            output.properties[name] = mergeJsonSchemaAnnotations(go(type, $defs, \"handle-identifier\", path.concat(ps.name), options, \"handle-annotation\", errors), getContextJsonSchemaAnnotations(type, ps));\n            // ---------------------------------------------\n            // handle optional property signatures\n            // ---------------------------------------------\n            if (!ps.isOptional && pruned === undefined) {\n              output.required.push(name);\n            }\n          } else {\n            if (errors === \"ignore-errors\") return addASTAnnotations(constAny, ast);\n            throw new Error(errors_.getJSONSchemaUnsupportedKeyErrorMessage(name, path));\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        if (patternProperties !== undefined) {\n          delete output.additionalProperties;\n          output.patternProperties = {\n            \"\": patternProperties\n          };\n        }\n        if (propertyNames !== undefined) {\n          output.propertyNames = propertyNames;\n        }\n        return addASTAnnotations(output, ast);\n      }\n    case \"Union\":\n      {\n        const members = ast.types.map(t => go(t, $defs, \"handle-identifier\", path, options, \"handle-annotation\", errors));\n        const anyOf = compactUnion(members);\n        switch (anyOf.length) {\n          case 0:\n            return constNever;\n          case 1:\n            return addASTAnnotations(anyOf[0], ast);\n          default:\n            return addASTAnnotations({\n              anyOf\n            }, ast);\n        }\n      }\n    case \"Refinement\":\n      return go(ast.from, $defs, identifier, path, options, \"handle-annotation\", errors);\n    case \"TemplateLiteral\":\n      {\n        const regex = AST.getTemplateLiteralRegExp(ast);\n        return addASTAnnotations({\n          type: \"string\",\n          title: String(ast),\n          description: \"a template literal\",\n          pattern: regex.source\n        }, ast);\n      }\n    case \"Transformation\":\n      {\n        if (isParseJsonTransformation(ast.from)) {\n          const out = {\n            \"type\": \"string\",\n            \"contentMediaType\": \"application/json\"\n          };\n          if (isContentSchemaSupported(options)) {\n            out[\"contentSchema\"] = go(ast.to, $defs, identifier, path, options, \"handle-annotation\", errors);\n          }\n          return out;\n        }\n        const from = go(ast.from, $defs, identifier, path, options, \"handle-annotation\", errors);\n        if (ast.transformation._tag === \"TypeLiteralTransformation\" && isJsonSchema7Object(from)) {\n          const to = go(ast.to, {}, \"ignore-identifier\", path, options, \"handle-annotation\", \"ignore-errors\");\n          if (isJsonSchema7Object(to)) {\n            for (const t of ast.transformation.propertySignatureTransformations) {\n              const toKey = t.to;\n              const fromKey = t.from;\n              if (Predicate.isString(toKey) && Predicate.isString(fromKey)) {\n                const toProperty = to.properties[toKey];\n                if (Predicate.isRecord(toProperty)) {\n                  const fromProperty = from.properties[fromKey];\n                  if (Predicate.isRecord(fromProperty)) {\n                    const annotations = {};\n                    if (Predicate.isString(toProperty.title)) annotations.title = toProperty.title;\n                    if (Predicate.isString(toProperty.description)) annotations.description = toProperty.description;\n                    if (Array.isArray(toProperty.examples)) annotations.examples = toProperty.examples;\n                    if (Object.hasOwn(toProperty, \"default\") && toProperty.default !== undefined) {\n                      annotations.default = toProperty.default;\n                    }\n                    from.properties[fromKey] = addAnnotations(fromProperty, annotations);\n                  }\n                }\n              }\n            }\n          }\n        }\n        return addASTAnnotations(from, ast);\n      }\n  }\n}\nfunction isJsonSchema7Object(jsonSchema) {\n  return Predicate.isRecord(jsonSchema) && jsonSchema.type === \"object\" && Predicate.isRecord(jsonSchema.properties);\n}\nfunction isNeverWithoutCustomAnnotations(jsonSchema) {\n  return jsonSchema === constNever || Predicate.hasProperty(jsonSchema, \"$id\") && jsonSchema.$id === constNever.$id && Object.keys(jsonSchema).length === 3 && jsonSchema.title === AST.neverKeyword.annotations[AST.TitleAnnotationId];\n}\nfunction isAny(jsonSchema) {\n  return \"$id\" in jsonSchema && jsonSchema.$id === constAny.$id;\n}\nfunction isUnknown(jsonSchema) {\n  return \"$id\" in jsonSchema && jsonSchema.$id === constUnknown.$id;\n}\nfunction isVoid(jsonSchema) {\n  return \"$id\" in jsonSchema && jsonSchema.$id === constVoid.$id;\n}\nfunction isCompactableLiteral(jsonSchema) {\n  return Predicate.hasProperty(jsonSchema, \"enum\") && \"type\" in jsonSchema && Object.keys(jsonSchema).length === 2;\n}\nfunction compactUnion(members) {\n  const out = [];\n  for (const m of members) {\n    if (isNeverWithoutCustomAnnotations(m)) continue;\n    if (isAny(m) || isUnknown(m) || isVoid(m)) return [m];\n    if (isCompactableLiteral(m) && out.length > 0) {\n      const last = out[out.length - 1];\n      if (isCompactableLiteral(last) && last.type === m.type) {\n        out[out.length - 1] = {\n          type: last.type,\n          enum: [...last.enum, ...m.enum]\n        };\n        continue;\n      }\n    }\n    out.push(m);\n  }\n  return out;\n}\n//# sourceMappingURL=JSONSchema.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
