{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/internal/worker.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Channel from \"effect/Channel\";\nimport * as Context from \"effect/Context\";\nimport * as Deferred from \"effect/Deferred\";\nimport * as Effect from \"effect/Effect\";\nimport * as Exit from \"effect/Exit\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as FiberSet from \"effect/FiberSet\";\nimport { identity, pipe } from \"effect/Function\";\nimport * as Layer from \"effect/Layer\";\nimport * as Mailbox from \"effect/Mailbox\";\nimport * as Option from \"effect/Option\";\nimport * as Pool from \"effect/Pool\";\nimport * as Runtime from \"effect/Runtime\";\nimport * as Schedule from \"effect/Schedule\";\nimport * as Schema from \"effect/Schema\";\nimport * as Scope from \"effect/Scope\";\nimport * as Stream from \"effect/Stream\";\nimport * as Tracer from \"effect/Tracer\";\nimport * as Transferable from \"../Transferable.js\";\nimport { WorkerError } from \"../WorkerError.js\";\n/** @internal */\nexport const PlatformWorkerTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Worker/PlatformWorker\");\n/** @internal */\nexport const PlatformWorker = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Worker/PlatformWorker\");\n/** @internal */\nexport const WorkerManagerTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Worker/WorkerManager\");\n/** @internal */\nexport const WorkerManager = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Worker/WorkerManager\");\n/** @internal */\nexport const Spawner = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Worker/Spawner\");\n/** @internal */\nexport const makeManager = /*#__PURE__*/Effect.gen(function* () {\n  const platform = yield* PlatformWorker;\n  let idCounter = 0;\n  return WorkerManager.of({\n    [WorkerManagerTypeId]: WorkerManagerTypeId,\n    spawn({\n      encode,\n      initialMessage\n    }) {\n      return Effect.gen(function* () {\n        const id = idCounter++;\n        let requestIdCounter = 0;\n        const requestMap = new Map();\n        const collector = Transferable.unsafeMakeCollector();\n        const wrappedEncode = encode ? message => Effect.zipRight(collector.clear, Effect.provideService(encode(message), Transferable.Collector, collector)) : Effect.succeed;\n        const readyLatch = yield* Deferred.make();\n        const backing = yield* platform.spawn(id);\n        yield* backing.run(message => {\n          if (message[0] === 0) {\n            return Deferred.complete(readyLatch, Effect.void);\n          }\n          return handleMessage(message[1]);\n        }).pipe(Effect.onError(cause => Effect.forEach(requestMap.values(), mailbox => Deferred.DeferredTypeId in mailbox ? Deferred.failCause(mailbox, cause) : mailbox.failCause(cause))), Effect.tapErrorCause(Effect.logWarning), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({\n          package: \"@effect/platform\",\n          module: \"Worker\"\n        }), Effect.interruptible, Effect.forkScoped);\n        yield* Effect.addFinalizer(() => Effect.zipRight(Effect.forEach(requestMap.values(), mailbox => Deferred.DeferredTypeId in mailbox ? Deferred.interrupt(mailbox) : mailbox.end, {\n          discard: true\n        }), Effect.sync(() => requestMap.clear())));\n        const handleMessage = response => Effect.suspend(() => {\n          const mailbox = requestMap.get(response[0]);\n          if (!mailbox) return Effect.void;\n          switch (response[1]) {\n            // data\n            case 0:\n              {\n                return Deferred.DeferredTypeId in mailbox ? Deferred.succeed(mailbox, response[2][0]) : mailbox.offerAll(response[2]);\n              }\n            // end\n            case 1:\n              {\n                if (response.length === 2) {\n                  return Deferred.DeferredTypeId in mailbox ? Deferred.interrupt(mailbox) : mailbox.end;\n                }\n                return Deferred.DeferredTypeId in mailbox ? Deferred.succeed(mailbox, response[2][0]) : Effect.zipRight(mailbox.offerAll(response[2]), mailbox.end);\n              }\n            // error / defect\n            case 2:\n            case 3:\n              {\n                if (response[1] === 2) {\n                  return Deferred.DeferredTypeId in mailbox ? Deferred.fail(mailbox, response[2]) : mailbox.fail(response[2]);\n                }\n                const cause = WorkerError.decodeCause(response[2]);\n                return Deferred.DeferredTypeId in mailbox ? Deferred.failCause(mailbox, cause) : mailbox.failCause(cause);\n              }\n          }\n        });\n        const executeAcquire = (request, makeMailbox) => Effect.withFiberRuntime(fiber => {\n          const context = fiber.getFiberRef(FiberRef.currentContext);\n          const span = Context.getOption(context, Tracer.ParentSpan).pipe(Option.filter(span => span._tag === \"Span\"));\n          const id = requestIdCounter++;\n          return makeMailbox.pipe(Effect.tap(mailbox => {\n            requestMap.set(id, mailbox);\n            return wrappedEncode(request).pipe(Effect.tap(payload => backing.send([id, 0, payload, span._tag === \"Some\" ? [span.value.traceId, span.value.spanId, span.value.sampled] : undefined], collector.unsafeRead())), Effect.catchAllCause(cause => Mailbox.isMailbox(mailbox) ? mailbox.failCause(cause) : Deferred.failCause(mailbox, cause)));\n          }), Effect.map(mailbox => ({\n            id,\n            mailbox\n          })));\n        });\n        const executeRelease = ({\n          id\n        }, exit) => {\n          const release = Effect.sync(() => requestMap.delete(id));\n          return Exit.isFailure(exit) ? Effect.zipRight(Effect.orDie(backing.send([id, 1])), release) : release;\n        };\n        const execute = request => Stream.fromChannel(Channel.acquireUseRelease(executeAcquire(request, Mailbox.make()), ({\n          mailbox\n        }) => Mailbox.toChannel(mailbox), executeRelease));\n        const executeEffect = request => Effect.acquireUseRelease(executeAcquire(request, Deferred.make()), ({\n          mailbox\n        }) => Deferred.await(mailbox), executeRelease);\n        yield* Deferred.await(readyLatch);\n        if (initialMessage) {\n          yield* Effect.sync(initialMessage).pipe(Effect.flatMap(executeEffect), Effect.mapError(cause => new WorkerError({\n            reason: \"spawn\",\n            cause\n          })));\n        }\n        return {\n          id,\n          execute,\n          executeEffect\n        };\n      });\n    }\n  });\n});\n/** @internal */\nexport const layerManager = /*#__PURE__*/Layer.effect(WorkerManager, makeManager);\n/** @internal */\nexport const makePool = options => Effect.gen(function* () {\n  const manager = yield* WorkerManager;\n  const workers = new Set();\n  const acquire = pipe(manager.spawn(options), Effect.tap(worker => Effect.acquireRelease(Effect.sync(() => workers.add(worker)), () => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : identity);\n  const backing = \"minSize\" in options ? yield* Pool.makeWithTTL({\n    acquire,\n    min: options.minSize,\n    max: options.maxSize,\n    concurrency: options.concurrency,\n    targetUtilization: options.targetUtilization,\n    timeToLive: options.timeToLive\n  }) : yield* Pool.make({\n    acquire,\n    size: options.size,\n    concurrency: options.concurrency,\n    targetUtilization: options.targetUtilization\n  });\n  const pool = {\n    backing,\n    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {\n      concurrency: \"unbounded\",\n      discard: true\n    }),\n    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),\n    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))\n  };\n  // report any spawn errors\n  yield* Effect.scoped(backing.get);\n  return pool;\n});\n/** @internal */\nexport const makePoolLayer = (tag, options) => Layer.scoped(tag, makePool(options));\n/** @internal */\nexport const makeSerialized = options => Effect.gen(function* () {\n  const manager = yield* WorkerManager;\n  const backing = yield* manager.spawn({\n    ...options,\n    encode(message) {\n      return Effect.mapError(Schema.serialize(message), cause => new WorkerError({\n        reason: \"encode\",\n        cause\n      }));\n    }\n  });\n  const execute = message => {\n    const parseSuccess = Schema.decode(Schema.successSchema(message));\n    const parseFailure = Schema.decode(Schema.failureSchema(message));\n    return pipe(backing.execute(message), Stream.catchAll(error => Effect.flatMap(parseFailure(error), Effect.fail)), Stream.mapEffect(parseSuccess));\n  };\n  const executeEffect = message => {\n    const parseSuccess = Schema.decode(Schema.successSchema(message));\n    const parseFailure = Schema.decode(Schema.failureSchema(message));\n    return Effect.matchEffect(backing.executeEffect(message), {\n      onFailure: error => Effect.flatMap(parseFailure(error), Effect.fail),\n      onSuccess: parseSuccess\n    });\n  };\n  return identity({\n    id: backing.id,\n    execute: execute,\n    executeEffect: executeEffect\n  });\n});\n/** @internal */\nexport const makePoolSerialized = options => Effect.gen(function* () {\n  const manager = yield* WorkerManager;\n  const workers = new Set();\n  const acquire = pipe(makeSerialized(options), Effect.tap(worker => Effect.sync(() => workers.add(worker))), Effect.tap(worker => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : identity, Effect.provideService(WorkerManager, manager));\n  const backing = yield* \"timeToLive\" in options ? Pool.makeWithTTL({\n    acquire,\n    min: options.minSize,\n    max: options.maxSize,\n    concurrency: options.concurrency,\n    targetUtilization: options.targetUtilization,\n    timeToLive: options.timeToLive\n  }) : Pool.make({\n    acquire,\n    size: options.size,\n    concurrency: options.concurrency,\n    targetUtilization: options.targetUtilization\n  });\n  const pool = {\n    backing,\n    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {\n      concurrency: \"unbounded\",\n      discard: true\n    }),\n    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),\n    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))\n  };\n  // report any spawn errors\n  yield* Effect.scoped(backing.get);\n  return pool;\n});\n/** @internal */\nexport const makePoolSerializedLayer = (tag, options) => Layer.scoped(tag, makePoolSerialized(options));\n/** @internal */\nexport const layerSpawner = spawner => Layer.succeed(Spawner, spawner);\n/** @internal */\nexport const makePlatform = () => options => PlatformWorker.of({\n  [PlatformWorkerTypeId]: PlatformWorkerTypeId,\n  spawn(id) {\n    return Effect.gen(function* () {\n      const spawn = yield* Spawner;\n      let currentPort;\n      const buffer = [];\n      const run = handler => Effect.uninterruptibleMask(restore => Effect.gen(function* () {\n        const scope = yield* Effect.scope;\n        const port = yield* options.setup({\n          worker: spawn(id),\n          scope\n        });\n        currentPort = port;\n        yield* Scope.addFinalizer(scope, Effect.sync(() => {\n          currentPort = undefined;\n        }));\n        const runtime = (yield* Effect.runtime()).pipe(Runtime.updateContext(Context.omit(Scope.Scope)));\n        const fiberSet = yield* FiberSet.make();\n        const runFork = Runtime.runFork(runtime);\n        yield* options.listen({\n          port,\n          scope,\n          emit(data) {\n            FiberSet.unsafeAdd(fiberSet, runFork(handler(data)));\n          },\n          deferred: fiberSet.deferred\n        });\n        if (buffer.length > 0) {\n          for (const [message, transfers] of buffer) {\n            port.postMessage([0, message], transfers);\n          }\n          buffer.length = 0;\n        }\n        return yield* restore(FiberSet.join(fiberSet));\n      }).pipe(Effect.scoped));\n      const send = (message, transfers) => Effect.try({\n        try: () => {\n          if (currentPort === undefined) {\n            buffer.push([message, transfers]);\n          } else {\n            currentPort.postMessage([0, message], transfers);\n          }\n        },\n        catch: cause => new WorkerError({\n          reason: \"send\",\n          cause\n        })\n      });\n      return {\n        run,\n        send\n      };\n    });\n  }\n});\n//# sourceMappingURL=worker.js.map",
      "start": 1768772628754,
      "end": 1768772628754
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628754,
      "end": 1768772628768,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628770,
      "end": 1768772628785,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628789,
      "end": 1768772628803,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628807,
      "end": 1768772628811,
      "order": "post-post"
    }
  ]
}
