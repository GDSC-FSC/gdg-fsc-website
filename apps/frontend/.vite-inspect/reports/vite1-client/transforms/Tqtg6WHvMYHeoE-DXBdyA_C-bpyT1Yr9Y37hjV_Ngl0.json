{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/TQueue.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/stm/tQueue.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TDequeueTypeId = internal.TDequeueTypeId;\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TEnqueueTypeId = internal.TEnqueueTypeId;\n/**\n * Returns `true` if the specified value is a `TQueue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isTQueue = internal.isTQueue;\n/**\n * Returns `true` if the specified value is a `TDequeue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isTDequeue = internal.isTDequeue;\n/**\n * Returns `true` if the specified value is a `TEnqueue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isTEnqueue = internal.isTEnqueue;\n/**\n * Waits until the queue is shutdown. The `STM` returned by this method will\n * not resume until the queue has been shutdown. If the queue is already\n * shutdown, the `STM` will resume right away.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const awaitShutdown = internal.awaitShutdown;\n/**\n * Creates a bounded queue with the back pressure strategy. The queue will\n * retain values until they have been taken, applying back pressure to\n * offerors if the queue is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const bounded = internal.bounded;\n/**\n * Returns the number of elements the queue can hold.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const capacity = internal.capacity;\n/**\n * Creates a bounded queue with the dropping strategy. The queue will drop new\n * values if the queue is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropping = internal.dropping;\n/**\n * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `TQueue` contains at least one element, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFull = internal.isFull;\n/**\n * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isShutdown = internal.isShutdown;\n/**\n * Places one value in the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const offer = internal.offer;\n/**\n * For Bounded TQueue: uses the `BackPressure` Strategy, places the values in\n * the queue and always returns true. If the queue has reached capacity, then\n * the fiber performing the `offerAll` will be suspended until there is room\n * in the queue.\n *\n * For Unbounded TQueue: Places all values in the queue and returns true.\n *\n * For Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,\n * it places the values otherwise it removes the old elements and enqueues the\n * new ones. Always returns true.\n *\n * For Dropping TQueue: uses `Dropping` Strategy, It places the values in the\n * queue but if there is no room it will not enqueue them and return false.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const offerAll = internal.offerAll;\n/**\n * Views the next element in the queue without removing it, retrying if the\n * queue is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const peek = internal.peek;\n/**\n * Views the next element in the queue without removing it, returning `None`\n * if the queue is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const peekOption = internal.peekOption;\n/**\n * Takes a single element from the queue, returning `None` if the queue is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const poll = internal.poll;\n/**\n * Drops elements from the queue while they do not satisfy the predicate,\n * taking and returning the first element that does satisfy the predicate.\n * Retries if no elements satisfy the predicate.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const seek = internal.seek;\n/**\n * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n * to `offer*` and `take*` will be interrupted immediately.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const shutdown = internal.shutdown;\n/**\n * Retrieves the size of the queue, which is equal to the number of elements\n * in the queue. This may be negative if fibers are suspended waiting for\n * elements to be added to the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = internal.size;\n/**\n * Creates a bounded queue with the sliding strategy. The queue will add new\n * values and drop old values if the queue is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sliding = internal.sliding;\n/**\n * Takes the oldest value in the queue. If the queue is empty, this will return\n * a computation that resumes when an item has been added to the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const take = internal.take;\n/**\n * Takes all the values in the queue and returns the values. If the queue is\n * empty returns an empty collection.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeAll = internal.takeAll;\n/**\n * Takes a number of elements from the queue between the specified minimum and\n * maximum. If there are fewer than the minimum number of elements available,\n * retries until at least the minimum number of elements have been collected.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeBetween = internal.takeBetween;\n/**\n * Takes the specified number of elements from the queue. If there are fewer\n * than the specified number of elements available, it retries until they\n * become available.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeN = internal.takeN;\n/**\n * Takes up to max number of values from the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeUpTo = internal.takeUpTo;\n/**\n * Creates an unbounded queue.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unbounded = internal.unbounded;\n//# sourceMappingURL=TQueue.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
