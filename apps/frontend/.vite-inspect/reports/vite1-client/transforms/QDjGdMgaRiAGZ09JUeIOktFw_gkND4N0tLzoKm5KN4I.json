{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/runtime.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Context from \"../Context.js\";\nimport { equals } from \"../Equal.js\";\nimport * as Exit from \"../Exit.js\";\nimport * as Fiber from \"../Fiber.js\";\nimport * as FiberId from \"../FiberId.js\";\nimport * as FiberRefs from \"../FiberRefs.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport * as Inspectable from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Predicate from \"../Predicate.js\";\nimport * as scheduler_ from \"../Scheduler.js\";\nimport * as scope_ from \"../Scope.js\";\nimport * as InternalCause from \"./cause.js\";\nimport * as core from \"./core.js\";\nimport * as executionStrategy from \"./executionStrategy.js\";\nimport * as FiberRuntime from \"./fiberRuntime.js\";\nimport * as fiberScope from \"./fiberScope.js\";\nimport * as OpCodes from \"./opCodes/effect.js\";\nimport * as runtimeFlags from \"./runtimeFlags.js\";\nimport * as supervisor_ from \"./supervisor.js\";\nconst makeDual = f => function () {\n  if (arguments.length === 1) {\n    const runtime = arguments[0];\n    return (effect, ...args) => f(runtime, effect, ...args);\n  }\n  return f.apply(this, arguments);\n};\n/** @internal */\nexport const unsafeFork = /*#__PURE__*/makeDual((runtime, self, options) => {\n  const fiberId = FiberId.unsafeMake();\n  const fiberRefUpdates = [[core.currentContext, [[fiberId, runtime.context]]]];\n  if (options?.scheduler) {\n    fiberRefUpdates.push([scheduler_.currentScheduler, [[fiberId, options.scheduler]]]);\n  }\n  let fiberRefs = FiberRefs.updateManyAs(runtime.fiberRefs, {\n    entries: fiberRefUpdates,\n    forkAs: fiberId\n  });\n  if (options?.updateRefs) {\n    fiberRefs = options.updateRefs(fiberRefs, fiberId);\n  }\n  const fiberRuntime = new FiberRuntime.FiberRuntime(fiberId, fiberRefs, runtime.runtimeFlags);\n  let effect = self;\n  if (options?.scope) {\n    effect = core.flatMap(scope_.fork(options.scope, executionStrategy.sequential), closeableScope => core.zipRight(core.scopeAddFinalizer(closeableScope, core.fiberIdWith(id => equals(id, fiberRuntime.id()) ? core.void : core.interruptAsFiber(fiberRuntime, id))), core.onExit(self, exit => scope_.close(closeableScope, exit))));\n  }\n  const supervisor = fiberRuntime.currentSupervisor;\n  // we can compare by reference here as _supervisor.none is wrapped with globalValue\n  if (supervisor !== supervisor_.none) {\n    supervisor.onStart(runtime.context, effect, Option.none(), fiberRuntime);\n    fiberRuntime.addObserver(exit => supervisor.onEnd(exit, fiberRuntime));\n  }\n  fiberScope.globalScope.add(runtime.runtimeFlags, fiberRuntime);\n  // Only an explicit false will prevent immediate execution\n  if (options?.immediate === false) {\n    fiberRuntime.resume(effect);\n  } else {\n    fiberRuntime.start(effect);\n  }\n  return fiberRuntime;\n});\n/** @internal */\nexport const unsafeRunCallback = /*#__PURE__*/makeDual((runtime, effect, options = {}) => {\n  const fiberRuntime = unsafeFork(runtime, effect, options);\n  if (options.onExit) {\n    fiberRuntime.addObserver(exit => {\n      options.onExit(exit);\n    });\n  }\n  return (id, cancelOptions) => unsafeRunCallback(runtime)(pipe(fiberRuntime, Fiber.interruptAs(id ?? FiberId.none)), {\n    ...cancelOptions,\n    onExit: cancelOptions?.onExit ? exit => cancelOptions.onExit(Exit.flatten(exit)) : undefined\n  });\n});\n/** @internal */\nexport const unsafeRunSync = /*#__PURE__*/makeDual((runtime, effect) => {\n  const result = unsafeRunSyncExit(runtime)(effect);\n  if (result._tag === \"Failure\") {\n    throw fiberFailure(result.effect_instruction_i0);\n  }\n  return result.effect_instruction_i0;\n});\nclass AsyncFiberExceptionImpl extends Error {\n  fiber;\n  _tag = \"AsyncFiberException\";\n  constructor(fiber) {\n    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);\n    this.fiber = fiber;\n    this.name = this._tag;\n    this.stack = this.message;\n  }\n}\nconst asyncFiberException = fiber => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  const error = new AsyncFiberExceptionImpl(fiber);\n  Error.stackTraceLimit = limit;\n  return error;\n};\n/** @internal */\nexport const isAsyncFiberException = u => Predicate.isTagged(u, \"AsyncFiberException\") && \"fiber\" in u;\n/** @internal */\nexport const FiberFailureId = /*#__PURE__*/Symbol.for(\"effect/Runtime/FiberFailure\");\n/** @internal */\nexport const FiberFailureCauseId = /*#__PURE__*/Symbol.for(\"effect/Runtime/FiberFailure/Cause\");\nclass FiberFailureImpl extends Error {\n  [FiberFailureId];\n  [FiberFailureCauseId];\n  constructor(cause) {\n    const head = InternalCause.prettyErrors(cause)[0];\n    super(head?.message || \"An error has occurred\");\n    this[FiberFailureId] = FiberFailureId;\n    this[FiberFailureCauseId] = cause;\n    this.name = head ? `(FiberFailure) ${head.name}` : \"FiberFailure\";\n    if (head?.stack) {\n      this.stack = head.stack;\n    }\n  }\n  toJSON() {\n    return {\n      _id: \"FiberFailure\",\n      cause: this[FiberFailureCauseId].toJSON()\n    };\n  }\n  toString() {\n    return \"(FiberFailure) \" + InternalCause.pretty(this[FiberFailureCauseId], {\n      renderErrorCause: true\n    });\n  }\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toString();\n  }\n}\n/** @internal */\nexport const fiberFailure = cause => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  const error = new FiberFailureImpl(cause);\n  Error.stackTraceLimit = limit;\n  return error;\n};\n/** @internal */\nexport const isFiberFailure = u => Predicate.hasProperty(u, FiberFailureId);\nconst fastPath = effect => {\n  const op = effect;\n  switch (op._op) {\n    case \"Failure\":\n    case \"Success\":\n      {\n        // @ts-expect-error\n        return op;\n      }\n    case \"Left\":\n      {\n        return core.exitFail(op.left);\n      }\n    case \"Right\":\n      {\n        return core.exitSucceed(op.right);\n      }\n    case \"Some\":\n      {\n        return core.exitSucceed(op.value);\n      }\n    case \"None\":\n      {\n        // @ts-expect-error\n        return core.exitFail(new core.NoSuchElementException());\n      }\n  }\n};\n/** @internal */\nexport const unsafeRunSyncExit = /*#__PURE__*/makeDual((runtime, effect) => {\n  const op = fastPath(effect);\n  if (op) {\n    return op;\n  }\n  const scheduler = new scheduler_.SyncScheduler();\n  const fiberRuntime = unsafeFork(runtime)(effect, {\n    scheduler\n  });\n  scheduler.flush();\n  const result = fiberRuntime.unsafePoll();\n  if (result) {\n    return result;\n  }\n  return core.exitDie(core.capture(asyncFiberException(fiberRuntime), core.currentSpanFromFiber(fiberRuntime)));\n});\n/** @internal */\nexport const unsafeRunPromise = /*#__PURE__*/makeDual((runtime, effect, options) => unsafeRunPromiseExit(runtime, effect, options).then(result => {\n  switch (result._tag) {\n    case OpCodes.OP_SUCCESS:\n      {\n        return result.effect_instruction_i0;\n      }\n    case OpCodes.OP_FAILURE:\n      {\n        throw fiberFailure(result.effect_instruction_i0);\n      }\n  }\n}));\n/** @internal */\nexport const unsafeRunPromiseExit = /*#__PURE__*/makeDual((runtime, effect, options) => new Promise(resolve => {\n  const op = fastPath(effect);\n  if (op) {\n    resolve(op);\n  }\n  const fiber = unsafeFork(runtime)(effect);\n  fiber.addObserver(exit => {\n    resolve(exit);\n  });\n  if (options?.signal !== undefined) {\n    if (options.signal.aborted) {\n      fiber.unsafeInterruptAsFork(fiber.id());\n    } else {\n      options.signal.addEventListener(\"abort\", () => {\n        fiber.unsafeInterruptAsFork(fiber.id());\n      }, {\n        once: true\n      });\n    }\n  }\n}));\n/** @internal */\nexport class RuntimeImpl {\n  context;\n  runtimeFlags;\n  fiberRefs;\n  constructor(context, runtimeFlags, fiberRefs) {\n    this.context = context;\n    this.runtimeFlags = runtimeFlags;\n    this.fiberRefs = fiberRefs;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nexport const make = options => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);\n/** @internal */\nexport const runtime = () => core.withFiberRuntime((state, status) => core.succeed(new RuntimeImpl(state.getFiberRef(core.currentContext), status.runtimeFlags, state.getFiberRefs())));\n/** @internal */\nexport const defaultRuntimeFlags = /*#__PURE__*/runtimeFlags.make(runtimeFlags.Interruption, runtimeFlags.CooperativeYielding, runtimeFlags.RuntimeMetrics);\n/** @internal */\nexport const defaultRuntime = /*#__PURE__*/make({\n  context: /*#__PURE__*/Context.empty(),\n  runtimeFlags: defaultRuntimeFlags,\n  fiberRefs: /*#__PURE__*/FiberRefs.empty()\n});\n/** @internal */\nexport const updateRuntimeFlags = /*#__PURE__*/dual(2, (self, f) => make({\n  context: self.context,\n  runtimeFlags: f(self.runtimeFlags),\n  fiberRefs: self.fiberRefs\n}));\n/** @internal */\nexport const disableRuntimeFlag = /*#__PURE__*/dual(2, (self, flag) => updateRuntimeFlags(self, runtimeFlags.disable(flag)));\n/** @internal */\nexport const enableRuntimeFlag = /*#__PURE__*/dual(2, (self, flag) => updateRuntimeFlags(self, runtimeFlags.enable(flag)));\n/** @internal */\nexport const updateContext = /*#__PURE__*/dual(2, (self, f) => make({\n  context: f(self.context),\n  runtimeFlags: self.runtimeFlags,\n  fiberRefs: self.fiberRefs\n}));\n/** @internal */\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, service) => updateContext(self, Context.add(tag, service)));\n/** @internal */\nexport const updateFiberRefs = /*#__PURE__*/dual(2, (self, f) => make({\n  context: self.context,\n  runtimeFlags: self.runtimeFlags,\n  fiberRefs: f(self.fiberRefs)\n}));\n/** @internal */\nexport const setFiberRef = /*#__PURE__*/dual(3, (self, fiberRef, value) => updateFiberRefs(self, FiberRefs.updateAs({\n  fiberId: FiberId.none,\n  fiberRef,\n  value\n})));\n/** @internal */\nexport const deleteFiberRef = /*#__PURE__*/dual(2, (self, fiberRef) => updateFiberRefs(self, FiberRefs.delete(fiberRef)));\n/** @internal */\nexport const unsafeRunEffect = /*#__PURE__*/unsafeRunCallback(defaultRuntime);\n/** @internal */\nexport const unsafeForkEffect = /*#__PURE__*/unsafeFork(defaultRuntime);\n/** @internal */\nexport const unsafeRunPromiseEffect = /*#__PURE__*/unsafeRunPromise(defaultRuntime);\n/** @internal */\nexport const unsafeRunPromiseExitEffect = /*#__PURE__*/unsafeRunPromiseExit(defaultRuntime);\n/** @internal */\nexport const unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);\n/** @internal */\nexport const unsafeRunSyncExitEffect = /*#__PURE__*/unsafeRunSyncExit(defaultRuntime);\n// circular with Effect\n/** @internal */\nexport const asyncEffect = register => core.suspend(() => {\n  let cleanup = undefined;\n  return core.flatMap(core.deferredMake(), deferred => core.flatMap(runtime(), runtime => core.uninterruptibleMask(restore => core.zipRight(FiberRuntime.fork(restore(core.matchCauseEffect(register(cb => unsafeRunCallback(runtime)(core.intoDeferred(cb, deferred))), {\n    onFailure: cause => core.deferredFailCause(deferred, cause),\n    onSuccess: cleanup_ => {\n      cleanup = cleanup_;\n      return core.void;\n    }\n  }))), restore(core.onInterrupt(core.deferredAwait(deferred), () => cleanup ?? core.void))))));\n});\n//# sourceMappingURL=runtime.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
