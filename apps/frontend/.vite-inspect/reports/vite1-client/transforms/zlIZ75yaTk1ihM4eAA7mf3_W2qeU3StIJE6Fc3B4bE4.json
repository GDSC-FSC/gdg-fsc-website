{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Queue.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as internal from \"./internal/queue.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const EnqueueTypeId = internal.EnqueueTypeId;\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const DequeueTypeId = internal.DequeueTypeId;\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const QueueStrategyTypeId = internal.QueueStrategyTypeId;\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const BackingQueueTypeId = internal.BackingQueueTypeId;\n/**\n * Returns `true` if the specified value is a `Queue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isQueue = internal.isQueue;\n/**\n * Returns `true` if the specified value is a `Dequeue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isDequeue = internal.isDequeue;\n/**\n * Returns `true` if the specified value is a `Enqueue`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isEnqueue = internal.isEnqueue;\n/**\n * @since 2.0.0\n * @category strategies\n */\nexport const backPressureStrategy = internal.backPressureStrategy;\n/**\n * @since 2.0.0\n * @category strategies\n */\nexport const droppingStrategy = internal.droppingStrategy;\n/**\n * @since 2.0.0\n * @category strategies\n */\nexport const slidingStrategy = internal.slidingStrategy;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Makes a new bounded `Queue`. When the capacity of the queue is reached, any\n * additional calls to `offer` will be suspended until there is more room in\n * the queue.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const bounded = internal.bounded;\n/**\n * Makes a new bounded `Queue` with the dropping strategy.\n *\n * When the capacity of the queue is reached, new elements will be dropped and the\n * old elements will remain.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropping = internal.dropping;\n/**\n * Makes a new bounded `Queue` with the sliding strategy.\n *\n * When the capacity of the queue is reached, new elements will be added and the\n * old elements will be dropped.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sliding = internal.sliding;\n/**\n * Creates a new unbounded `Queue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unbounded = internal.unbounded;\n/**\n * Returns the number of elements the queue can hold.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const capacity = internal.capacity;\n/**\n * Retrieves the size of the queue, which is equal to the number of elements\n * in the queue. This may be negative if fibers are suspended waiting for\n * elements to be added to the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = internal.size;\n/**\n * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `Queue` contains at least one element, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFull = internal.isFull;\n/**\n * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isShutdown = internal.isShutdown;\n/**\n * Waits until the queue is shutdown. The `Effect` returned by this method will\n * not resume until the queue has been shutdown. If the queue is already\n * shutdown, the `Effect` will resume right away.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const awaitShutdown = internal.awaitShutdown;\n/**\n * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n * to `offer*` and `take*` will be interrupted immediately.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const shutdown = internal.shutdown;\n/**\n * Places one value in the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const offer = internal.offer;\n/**\n * Places one value in the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const unsafeOffer = internal.unsafeOffer;\n/**\n * For Bounded Queue: uses the `BackPressure` Strategy, places the values in\n * the queue and always returns true. If the queue has reached capacity, then\n * the fiber performing the `offerAll` will be suspended until there is room\n * in the queue.\n *\n * For Unbounded Queue: Places all values in the queue and returns true.\n *\n * For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\n * it places the values otherwise it removes the old elements and enqueues the\n * new ones. Always returns true.\n *\n * For Dropping Queue: uses `Dropping` Strategy, It places the values in the\n * queue but if there is no room it will not enqueue them and return false.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const offerAll = internal.offerAll;\n/**\n * Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\n * is empty.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const poll = internal.poll;\n/**\n * Takes the oldest value in the queue. If the queue is empty, this will return\n * a computation that resumes when an item has been added to the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const take = internal.take;\n/**\n * Takes all the values in the queue and returns the values. If the queue is\n * empty returns an empty collection.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const takeAll = internal.takeAll;\n/**\n * Takes up to max number of values from the queue.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const takeUpTo = internal.takeUpTo;\n/**\n * Takes a number of elements from the queue between the specified minimum and\n * maximum. If there are fewer than the minimum number of elements available,\n * suspends until at least the minimum number of elements have been collected.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const takeBetween = internal.takeBetween;\n/**\n * Takes the specified number of elements from the queue. If there are fewer\n * than the specified number of elements available, it suspends until they\n * become available.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const takeN = internal.takeN;\n//# sourceMappingURL=Queue.js.map",
      "start": 1768772628414,
      "end": 1768772628414
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628414,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628435,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
