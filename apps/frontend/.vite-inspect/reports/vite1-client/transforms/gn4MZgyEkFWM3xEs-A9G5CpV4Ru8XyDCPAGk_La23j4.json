{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/BigInt.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @module BigInt\n * @since 2.0.0\n * @see {@link module:BigDecimal} for more similar operations on `BigDecimal` types\n * @see {@link module:Number} for more similar operations on `number` types\n */\nimport * as equivalence from \"./Equivalence.js\";\nimport { dual } from \"./Function.js\";\nimport * as Option from \"./Option.js\";\nimport * as order from \"./Order.js\";\nimport * as predicate from \"./Predicate.js\";\nconst bigint0 = /*#__PURE__*/BigInt(0);\nconst bigint1 = /*#__PURE__*/BigInt(1);\nconst bigint2 = /*#__PURE__*/BigInt(2);\n/**\n * Tests if a value is a `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBigInt } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n * assert.deepStrictEqual(isBigInt(1), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBigInt = predicate.isBigInt;\n/**\n * Provides an addition operation on `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sum } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(sum(2n, 3n), 5n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sum = /*#__PURE__*/dual(2, (self, that) => self + that);\n/**\n * Provides a multiplication operation on `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { multiply } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(multiply(2n, 3n), 6n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiply = /*#__PURE__*/dual(2, (self, that) => self * that);\n/**\n * Provides a subtraction operation on `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { subtract } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(subtract(2n, 3n), -1n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const subtract = /*#__PURE__*/dual(2, (self, that) => self - that);\n/**\n * Provides a division operation on `bigint`s.\n *\n * If the dividend is not a multiple of the divisor the result will be a `bigint` value\n * which represents the integer division rounded down to the nearest integer.\n *\n * Returns `None` if the divisor is `0n`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))\n * assert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const divide = /*#__PURE__*/dual(2, (self, that) => that === bigint0 ? Option.none() : Option.some(self / that));\n/**\n * Provides a division operation on `bigint`s.\n *\n * If the dividend is not a multiple of the divisor the result will be a `bigint` value\n * which represents the integer division rounded down to the nearest integer.\n *\n * Throws a `RangeError` if the divisor is `0n`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeDivide } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)\n * assert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const unsafeDivide = /*#__PURE__*/dual(2, (self, that) => self / that);\n/**\n * Returns the result of adding `1n` to a given number.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { increment } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(increment(2n), 3n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const increment = n => n + bigint1;\n/**\n * Decrements a number by `1n`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { decrement } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(decrement(3n), 2n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const decrement = n => n - bigint1;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence = equivalence.bigint;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order = order.bigint;\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThan } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(lessThan(2n, 3n), true)\n * assert.deepStrictEqual(lessThan(3n, 3n), false)\n * assert.deepStrictEqual(lessThan(4n, 3n), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * Returns a function that checks if a given `bigint` is less than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThanOrEqualTo } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThan } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(greaterThan(2n, 3n), false)\n * assert.deepStrictEqual(greaterThan(3n, 3n), false)\n * assert.deepStrictEqual(greaterThan(4n, 3n), true)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * Returns a function that checks if a given `bigint` is greater than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThanOrEqualTo } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt } from \"effect\"\n *\n * const between = BigInt.between({ minimum: 0n, maximum: 5n })\n *\n * assert.deepStrictEqual(between(3n), true)\n * assert.deepStrictEqual(between(-1n), false)\n * assert.deepStrictEqual(between(6n), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const between = /*#__PURE__*/order.between(Order);\n/**\n * Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt } from \"effect\"\n *\n * const clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })\n *\n * assert.equal(clamp(3n), 3n)\n * assert.equal(clamp(0n), 1n)\n * assert.equal(clamp(6n), 5n)\n * ```\n *\n * @since 2.0.0\n */\nexport const clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * Returns the minimum between two `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { min } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(min(2n, 3n), 2n)\n * ```\n *\n * @since 2.0.0\n */\nexport const min = /*#__PURE__*/order.min(Order);\n/**\n * Returns the maximum between two `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { max } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(max(2n, 3n), 3n)\n * ```\n *\n * @since 2.0.0\n */\nexport const max = /*#__PURE__*/order.max(Order);\n/**\n * Determines the sign of a given `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sign } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(sign(-5n), -1)\n * assert.deepStrictEqual(sign(0n), 0)\n * assert.deepStrictEqual(sign(5n), 1)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sign = n => Order(n, bigint0);\n/**\n * Determines the absolute value of a given `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { abs } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(abs(-5n), 5n)\n * assert.deepStrictEqual(abs(0n), 0n)\n * assert.deepStrictEqual(abs(5n), 5n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const abs = n => n < bigint0 ? -n : n;\n/**\n * Determines the greatest common divisor of two `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { gcd } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(gcd(2n, 3n), 1n)\n * assert.deepStrictEqual(gcd(2n, 4n), 2n)\n * assert.deepStrictEqual(gcd(16n, 24n), 8n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const gcd = /*#__PURE__*/dual(2, (self, that) => {\n  while (that !== bigint0) {\n    const t = that;\n    that = self % that;\n    self = t;\n  }\n  return self;\n});\n/**\n * Determines the least common multiple of two `bigint`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lcm } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(lcm(2n, 3n), 6n)\n * assert.deepStrictEqual(lcm(2n, 4n), 4n)\n * assert.deepStrictEqual(lcm(16n, 24n), 48n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const lcm = /*#__PURE__*/dual(2, (self, that) => self * that / gcd(self, that));\n/**\n * Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeSqrt } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(unsafeSqrt(4n), 2n)\n * assert.deepStrictEqual(unsafeSqrt(9n), 3n)\n * assert.deepStrictEqual(unsafeSqrt(16n), 4n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const unsafeSqrt = n => {\n  if (n < bigint0) {\n    throw new RangeError(\"Cannot take the square root of a negative number\");\n  }\n  if (n < bigint2) {\n    return n;\n  }\n  let x = n / bigint2;\n  while (x * x > n) {\n    x = (n / x + x) / bigint2;\n  }\n  return x;\n};\n/**\n * Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))\n * assert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))\n * assert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))\n * assert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sqrt = n => greaterThanOrEqualTo(n, bigint0) ? Option.some(unsafeSqrt(n)) : Option.none();\n/**\n * Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sumAll } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sumAll = collection => {\n  let out = bigint0;\n  for (const n of collection) {\n    out += n;\n  }\n  return out;\n};\n/**\n * Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { multiplyAll } from \"effect/BigInt\"\n *\n * assert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiplyAll = collection => {\n  let out = bigint1;\n  for (const n of collection) {\n    if (n === bigint0) {\n      return bigint0;\n    }\n    out *= n;\n  }\n  return out;\n};\n/**\n * Takes a `bigint` and returns an `Option` of `number`.\n *\n * If the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\n * and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`\n * to a number and returns `Option.some(number)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt as BI, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))\n * assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())\n * assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toNumber = b => {\n  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {\n    return Option.none();\n  }\n  return Option.some(Number(b));\n};\n/**\n * Takes a string and returns an `Option` of `bigint`.\n *\n * If the string is empty or contains characters that cannot be converted into a `bigint`,\n * it returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt as BI, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BI.fromString(\"42\"), Option.some(BigInt(42)))\n * assert.deepStrictEqual(BI.fromString(\" \"), Option.none())\n * assert.deepStrictEqual(BI.fromString(\"a\"), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.4.12\n */\nexport const fromString = s => {\n  try {\n    return s.trim() === \"\" ? Option.none() : Option.some(BigInt(s));\n  } catch {\n    return Option.none();\n  }\n};\n/**\n * Takes a number and returns an `Option` of `bigint`.\n *\n * If the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\n * and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to\n * convert the number to a `bigint` and returns `Option.some(bigint)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigInt as BI, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))\n * assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())\n * assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.4.12\n */\nexport const fromNumber = n => {\n  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {\n    return Option.none();\n  }\n  try {\n    return Option.some(BigInt(n));\n  } catch {\n    return Option.none();\n  }\n};\n//# sourceMappingURL=BigInt.js.map",
      "start": 1768772628411,
      "end": 1768772628411
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628411,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628420,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
