{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Schedule.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as internal from \"./internal/schedule.js\";\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport const ScheduleTypeId = internal.ScheduleTypeId;\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport const ScheduleDriverTypeId = internal.ScheduleDriverTypeId;\n/**\n * Creates a new schedule with a custom state and step function.\n *\n * **Details**\n *\n * This function constructs a `Schedule` by defining its initial state and a\n * step function, which determines how the schedule progresses over time. The\n * step function is called on each iteration with the current time, an input\n * value, and the schedule's current state. It returns the next state, an output\n * value, and a decision on whether the schedule should continue or stop.\n *\n * This function is useful for creating custom scheduling logic that goes beyond\n * predefined schedules like fixed intervals or exponential backoff. It allows\n * full control over how the schedule behaves at each step.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const makeWithState = internal.makeWithState;\n/**\n * Checks whether a given value is a `Schedule`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isSchedule = internal.isSchedule;\n/**\n * Adds a delay to every interval in a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying an additional delay to\n * every interval it defines. The delay is determined by the provided function,\n * which takes the schedule's output and returns a delay duration.\n *\n * @see {@link addDelayEffect} If you need to compute the delay using an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const addDelay = internal.addDelay;\n/**\n * Adds an effectfully computed delay to every interval in a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying an additional delay to\n * each interval, where the delay is determined by an effectful function. The\n * function takes the schedule’s output and returns an effect that produces a\n * delay duration.\n *\n * @see {@link addDelay} If you need to compute the delay using a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const addDelayEffect = internal.addDelayEffect;\n/**\n * Runs two schedules sequentially, merging their outputs.\n *\n * **Details**\n *\n * This function executes two schedules one after the other. The first schedule\n * runs to completion, and then the second schedule begins execution. Unlike\n * {@link andThenEither}, this function merges the outputs instead of wrapping\n * them in `Either`, allowing both schedules to contribute their results\n * directly.\n *\n * This is useful when a workflow consists of two phases where the second phase\n * should start only after the first one has fully completed.\n *\n * @see {@link andThenEither} If you need to keep track of which schedule\n * produced each result.\n *\n * @since 2.0.0\n * @category Sequential Composition\n */\nexport const andThen = internal.andThen;\n/**\n * Runs two schedules sequentially, collecting results in an `Either`.\n *\n * **Details**\n *\n * This function combines two schedules in sequence. The first schedule runs to\n * completion, and then the second schedule starts and runs to completion as\n * well. The outputs of both schedules are collected into an `Either` structure:\n * - `Either.Left` contains the output of the second schedule.\n * - `Either.Right` contains the output of the first schedule.\n *\n * This is useful when you need to switch from one schedule to another after the\n * first one finishes, while still keeping track of which schedule produced each\n * result.\n *\n * @see {@link andThen} If you need to merge the outputs of both schedules.\n *\n * @since 2.0.0\n * @category Sequential Composition\n */\nexport const andThenEither = internal.andThenEither;\n/**\n * Transforms a schedule to always produce a constant output.\n *\n * **Details**\n *\n * This function modifies a given schedule so that instead of returning its\n * computed outputs, it always returns a constant value.\n *\n * This is useful when you need a schedule for timing but don’t care about its\n * actual output, or when you want to standardize results across different\n * scheduling strategies.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const as = internal.as;\n/**\n * Transforms a schedule to always return `void` instead of its output.\n *\n * **Details**\n *\n * This function modifies a given schedule so that it no longer returns\n * meaningful output—each execution produces `void`. This is useful when the\n * schedule is used only for timing purposes and the actual output of the\n * schedule is irrelevant.\n *\n * The schedule still determines when executions should occur, but the results\n * are discarded.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const asVoid = internal.asVoid;\n// TODO(4.0): rename to `zip`?\n/**\n * Combines two schedules, preserving both their inputs and outputs.\n *\n * **Details**\n *\n * This function merges two schedules so that both their input types and output\n * types are retained. When executed, the resulting schedule will take inputs\n * from both original schedules and produce a tuple containing both outputs.\n *\n * It recurs if either schedule wants to continue, using the shorter delay.\n *\n * This is useful when you want to track multiple schedules simultaneously,\n * ensuring that both receive the same inputs and produce combined results.\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const bothInOut = internal.bothInOut;\n/**\n * Filters schedule executions based on a custom condition.\n *\n * **Details**\n *\n * This function modifies a schedule by applying a custom test function to each\n * input-output pair. The test function determines whether the schedule should\n * continue or stop. If the function returns `true`, the schedule proceeds as\n * usual; if it returns `false`, the schedule terminates.\n *\n * This is useful for conditional retries, custom stop conditions, or\n * dynamically controlling execution based on observed inputs and outputs.\n *\n * @see {@link checkEffect} If you need to use an effectful test function.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const check = internal.check;\n/**\n * Conditionally filters schedule executions using an effectful function.\n *\n * **Details**\n *\n * This function modifies a schedule by applying a custom effectful test\n * function to each input-output pair. The test function determines whether the\n * schedule should continue (`true`) or stop (`false`).\n *\n * This is useful when the decision to continue depends on external factors such\n * as database lookups, API calls, or other asynchronous computations.\n *\n * @see {@link check} If you need to use a pure test function.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const checkEffect = internal.checkEffect;\n/**\n * A schedule that collects all inputs into a `Chunk`.\n *\n * **Details**\n *\n * This function creates a schedule that never terminates and continuously\n * collects every input it receives into a `Chunk`. Each time the schedule runs,\n * it appends the new input to the collected list.\n *\n * This is useful when you need to track all received inputs over time, such as\n * logging user actions, recording retry attempts, or accumulating data for\n * later processing.\n *\n * @see {@link collectAllOutputs} If you need to collect outputs instead of\n * inputs.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectAllInputs = internal.collectAllInputs;\n/**\n * Collects all outputs of a schedule into a `Chunk`.\n *\n * **Details**\n *\n * This function modifies a given schedule so that instead of returning\n * individual outputs, it accumulates them into a `Chunk`. The schedule\n * continues to run, appending each output to the collected list.\n *\n * This is useful when you need to track all results over time, such as logging\n * outputs, aggregating data, or keeping a history of previous values.\n *\n * @see {@link collectAllInputs} If you need to collect inputs instead of\n * outputs.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectAllOutputs = internal.collectAllOutputs;\n/**\n * Collects all inputs into a `Chunk` until a condition fails.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` until the given predicate function `f` evaluates to `false`. Once the\n * condition fails, the schedule stops.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectUntil = internal.collectUntil;\n/**\n * Collects all inputs into a `Chunk` until an effectful condition fails.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` until the given effectful predicate `f` returns `false`. The\n * predicate runs as an effect, meaning it can involve asynchronous computations\n * like API calls, database lookups, or randomness.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectUntilEffect = internal.collectUntilEffect;\n/**\n * Collects all inputs into a `Chunk` while a condition holds.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` while the given predicate function `f` evaluates to `true`. As soon\n * as the condition fails, the schedule stops.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectWhile = internal.collectWhile;\n/**\n * Collects all inputs into a `Chunk` while an effectful condition holds.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` while the given effectful predicate `f` returns `true`. The predicate\n * returns an effect, meaning it can depend on external state, such as database\n * queries, API responses, or real-time user conditions.\n *\n * As soon as the effectful condition returns `false`, the schedule stops. This\n * is useful for dynamically controlled data collection, where stopping depends\n * on an external or asynchronous factor.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectWhileEffect = internal.collectWhileEffect;\n/**\n * Chains two schedules, passing the output of the first as the input to the\n * second, while selecting the shorter delay between them.\n *\n * **Details**\n *\n * This function composes two schedules so that the output of the first schedule\n * becomes the input of the second schedule. The first schedule executes first,\n * and once it produces a result, the second schedule receives that result and\n * continues execution based on it.\n *\n * This is useful for building complex scheduling workflows where one schedule's\n * behavior determines how the next schedule behaves.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const compose = internal.compose;\n/**\n * Transforms the input type of a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying a transformation function\n * to its inputs. Instead of directly receiving values of type `In`, the\n * schedule will now accept values of type `In2`, which are converted to `In`\n * using the provided mapping function `f`.\n *\n * This is useful when you have a schedule that expects a specific input type\n * but you need to adapt it to work with a different type.\n *\n * @see {@link mapInputEffect} If you need to use an effectful transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInput = internal.mapInput;\n/**\n * Transforms the input type of a schedule using an effectful function.\n *\n * **Details**\n *\n * This function modifies a schedule by applying an effectful transformation to\n * its inputs. Instead of directly receiving values of type `In`, the schedule\n * will now accept values of type `In2`, which are converted to `In` via an\n * effectful function `f`.\n *\n * This is useful when the input transformation involves external dependencies,\n * such as API calls, database lookups, or other asynchronous computations.\n *\n * @see {@link mapInput} If you need to use a pure transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInputEffect = internal.mapInputEffect;\n/**\n * Transforms the required context of a schedule.\n *\n * **Details**\n *\n * This function modifies a schedule by mapping its required context (`R`) into\n * a new context (`R0`) using the provided function `f`.\n *\n * This is useful when you need to adapt a schedule to work with a different\n * dependency environment without changing its core logic.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInputContext = internal.mapInputContext;\n/**\n * A schedule that recurs indefinitely, counting the number of recurrences.\n *\n * **Details**\n *\n * This schedule never stops and simply counts how many times it has executed.\n * Each recurrence increases the count, starting from `0`.\n *\n * This is useful when tracking the number of attempts in retry policies,\n * measuring execution loops, or implementing infinite polling scenarios.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const count = internal.count;\n/**\n * Creates a schedule that recurs based on a cron expression.\n *\n * **Details**\n *\n * This schedule automatically executes at intervals defined by a cron\n * expression. It triggers at the beginning of each matched interval and\n * produces timestamps representing the start and end of the cron window.\n *\n * The cron `expression` is validated lazily, meaning errors may only be\n * detected when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const cron = internal.cron;\n/**\n * Cron-like schedule that recurs at a specific second of each minute.\n *\n * **Details**\n *\n * This schedule triggers at the specified `second` of each minute,\n * starting at zero nanoseconds. It produces a count of executions\n * (0, 1, 2, ...). The `second` parameter is validated lazily, meaning\n * invalid values will only be caught at runtime.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const secondOfMinute = internal.secondOfMinute;\n/**\n * Creates a schedule that recurs every specified minute of each hour.\n *\n * **Details**\n *\n * This schedule triggers once per hour at the specified `minute`, starting\n * exactly at `minute:00` (zero seconds). The schedule produces a count of\n * executions (`0, 1, 2, ...`), representing how many times it has run.\n *\n * The `minute` parameter must be between `0` and `59`. It is validated lazily,\n * meaning an invalid value will cause errors only when the schedule is\n * executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const minuteOfHour = internal.minuteOfHour;\n/**\n * Creates a schedule that recurs at a specific hour of each day.\n *\n * **Details**\n *\n * This schedule triggers once per day at the specified `hour`, starting at zero\n * minutes of that hour. The schedule produces a count of executions (`0, 1, 2,\n * ...`), indicating how many times it has been triggered.\n *\n * The `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is\n * validated lazily, meaning an invalid value will cause errors only when the\n * schedule is executed.\n *\n * This is useful for scheduling daily recurring tasks at a fixed time, such as\n * running batch jobs or refreshing data.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const hourOfDay = internal.hourOfDay;\n/**\n * Creates a schedule that recurs on a specific day of the month.\n *\n * **Details**\n *\n * This schedule triggers at midnight on the specified day of each month. It\n * will not execute in months that have fewer days than the given day. For\n * example, if the schedule is set to run on the 31st, it will not execute in\n * months with only 30 days.\n *\n * The schedule produces a count of executions, starting at 0 and incrementing\n * with each recurrence.\n *\n * The `day` parameter is validated lazily, meaning errors may only be detected\n * when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const dayOfMonth = internal.dayOfMonth;\n/**\n * Creates a schedule that recurs on a specific day of the week.\n *\n * **Details**\n *\n * This schedule triggers at midnight on the specified day of the week. The\n * `day` parameter follows the standard convention where `Monday = 1` and\n * `Sunday = 7`. The schedule produces a count of executions, starting at 0 and\n * incrementing with each recurrence.\n *\n * The `day` parameter is validated lazily, meaning errors may only be detected\n * when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const dayOfWeek = internal.dayOfWeek;\n/**\n * Modifies a schedule by adding a computed delay before each execution.\n *\n * **Details**\n *\n * This function adjusts an existing schedule by applying a transformation to\n * its delays. Instead of using the default interval, each delay is modified\n * using the provided function `f`, which takes the current delay and returns a\n * new delay.\n *\n * This is useful for dynamically adjusting wait times between executions, such\n * as introducing jitter, exponential backoff, or custom delay logic.\n *\n * @see {@link delayedEffect} If you need to compute the delay using an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayed = internal.delayed;\n/**\n * Modifies a schedule by adding an effectfully computed delay before each\n * execution.\n *\n * **Details**\n *\n * This function adjusts an existing schedule by introducing a delay that is\n * computed via an effect. Instead of using a fixed delay, each interval is\n * dynamically adjusted based on an effectful function `f`, which takes the\n * current delay and returns a new delay wrapped in an `Effect`.\n *\n * This is useful for adaptive scheduling where delays depend on external\n * factors, such as API calls, database queries, or dynamic system conditions.\n *\n * @see {@link delayed} If you need to compute the delay using a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayedEffect = internal.delayedEffect;\n/**\n * Uses the delays produced by a schedule to further delay its intervals.\n *\n * **Details**\n *\n * This function modifies a schedule by using its own output delays to control\n * its execution timing. Instead of executing immediately at each interval, the\n * schedule will be delayed by the duration it produces.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayedSchedule = internal.delayedSchedule;\n/**\n * Transforms a schedule to output the delay between each occurrence.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that instead of producing its\n * original output, it now returns the delay between each scheduled execution.\n *\n * @since 2.0.0\n * @category Monitoring\n */\nexport const delays = internal.delays;\n/**\n * Transforms both the input and output of a schedule.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying a transformation to\n * both its input values and its output values. The provided transformation\n * functions `onInput` and `onOutput` allow you to map the schedule to work with\n * a different input type while modifying its outputs as well.\n *\n * @see {@link mapBothEffect} If you need to use effectful transformation functions.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapBoth = internal.mapBoth;\n/**\n * Transforms both the input and output of a schedule using effectful\n * computations.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying effectful\n * transformations to both its input values and its output values. The provided\n * effectful functions `onInput` and `onOutput` allow you to transform inputs\n * and outputs using computations that may involve additional logic, resource\n * access, or side effects.\n *\n * @see {@link mapBoth} If you need to use pure transformation functions.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapBothEffect = internal.mapBothEffect;\n/**\n * Creates a driver to manually control the execution of a schedule.\n *\n * **Details**\n *\n * This function returns a `ScheduleDriver`, which allows stepping through a\n * schedule manually while handling delays and sleeping appropriately. A driver\n * is useful when you need fine-grained control over how a schedule progresses,\n * rather than relying on automatic execution.\n *\n * The returned driver exposes methods for retrieving the current state,\n * executing the next step, and resetting the schedule when needed.\n *\n * @since 2.0.0\n * @category getter\n */\nexport const driver = internal.driver;\n// TODO(4.0): remove?\n/**\n * Alias of {@link fromDelay}.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const duration = internal.duration;\n// TODO(4.0): remove?\n/**\n * Alias of {@link union}.\n *\n * @since 2.0.0\n * @category Alternatives\n */\nexport const either = internal.either;\n// TODO(4.0): remove?\n/**\n * Alias of {@link unionWith}.\n *\n * @since 2.0.0\n * @category Alternatives\n */\nexport const eitherWith = internal.eitherWith;\n/**\n * Creates a schedule that tracks the total elapsed duration since it started.\n *\n * **Details**\n *\n * This schedule executes continuously and returns the total time that has\n * passed since the first execution. The duration keeps increasing with each\n * step, providing a way to measure elapsed time.\n *\n * This is useful for tracking execution time, monitoring delays, or\n * implementing logic based on how long a process has been running.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const elapsed = internal.elapsed;\n/**\n * Attaches a finalizer to a schedule that runs when the schedule completes.\n *\n * **Details**\n *\n * This function returns a new schedule that executes a given finalizer when the\n * schedule reaches completion. Unlike `Effect.ensuring`, this method does not\n * guarantee the finalizer will run in all cases. If the schedule never\n * initializes or is not driven to completion, the finalizer may not execute.\n * However, if the schedule decides not to continue, the finalizer will be\n * invoked.\n *\n * This is useful for cleaning up resources, logging, or executing other side\n * effects when a schedule completes.\n *\n * @since 2.0.0\n * @category Finalization\n */\nexport const ensuring = internal.ensuring;\n/**\n * Creates a schedule that recurs indefinitely with exponentially increasing\n * delays.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `base` and increases the delay\n * exponentially on each repetition using the formula `base * factor^n`, where\n * `n` is the number of times the schedule has executed so far. If no `factor`\n * is provided, it defaults to `2`, causing the delay to double after each\n * execution.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const exponential = internal.exponential;\n/**\n * Creates a schedule that recurs indefinitely with Fibonacci-based increasing\n * delays.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `one` and increases subsequent\n * delays by summing the two previous delays, following the Fibonacci sequence.\n * The delay pattern follows: `one, one, one + one, (one + one) + one, ...`,\n * resulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.\n *\n * This is useful for progressive backoff strategies, where delays grow\n * naturally over time without increasing as aggressively as an exponential\n * schedule.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fibonacci = internal.fibonacci;\n/**\n * Creates a schedule that recurs at a fixed interval.\n *\n * **Details**\n *\n * This schedule executes at regular, evenly spaced intervals, returning the\n * number of times it has run so far. If the action being executed takes longer\n * than the interval, the next execution will happen immediately to prevent\n * \"pile-ups,\" ensuring that the schedule remains consistent without overlapping\n * executions.\n *\n * ```text\n * |-----interval-----|-----interval-----|-----interval-----|\n * |---------action--------||action|-----|action|-----------|\n * ```\n *\n * @see {@link spaced} If you need to run from the end of the last execution.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fixed = internal.fixed;\n/**\n * Creates a schedule that recurs indefinitely, producing a count of\n * repetitions.\n *\n * **Details**\n *\n * This schedule runs indefinitely, returning an increasing count of executions\n * (`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking\n * of how many times it has executed.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const forever = internal.forever;\n/**\n * Creates a schedule that recurs once after a specified duration.\n *\n * **Details**\n *\n * This schedule executes a single time after waiting for the given duration.\n * Once it has executed, it does not repeat.\n *\n * @see {@link fromDelays} If you need to create a schedule with multiple delays.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromDelay = internal.fromDelay;\n/**\n * Creates a schedule that recurs once for each specified duration, applying the\n * given delays sequentially.\n *\n * **Details**\n *\n * This schedule executes multiple times, each time waiting for the\n * corresponding duration from the provided list of delays. The first execution\n * waits for `delay`, the next for the second value in `delays`, and so on. Once\n * all delays have been used, the schedule stops executing.\n *\n * This is useful for defining a custom delay sequence that does not follow a\n * fixed pattern like exponential or Fibonacci backoff.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromDelays = internal.fromDelays;\n/**\n * Creates a schedule that always recurs, transforming input values using the\n * specified function.\n *\n * **Details**\n *\n * This schedule continuously executes and applies the given function `f` to\n * each input value, producing a transformed output. The schedule itself does\n * not control delays or stopping conditions; it simply transforms the input\n * values as they are processed.\n *\n * This is useful when defining schedules that map inputs to outputs, allowing\n * dynamic transformations of incoming data.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromFunction = internal.fromFunction;\n/**\n * Creates a schedule that always recurs, passing inputs directly as outputs.\n *\n * **Details**\n *\n * This schedule runs indefinitely, returning each input value as its output\n * without modification. It effectively acts as a pass-through that simply\n * echoes its input values at each step.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const identity = internal.identity;\n/**\n * Transforms a schedule to pass through its inputs as outputs.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it returns its input\n * values instead of its original output values. The schedule's timing remains\n * unchanged, but its outputs are replaced with whatever inputs it receives.\n *\n * @since 2.0.0\n */\nexport const passthrough = internal.passthrough;\n/**\n * Combines two schedules, continuing only if both schedules want to continue,\n * using the longer delay.\n *\n * **Details**\n *\n * This function takes two schedules and creates a new schedule that only\n * continues execution if both schedules allow it. The interval between\n * recurrences is determined by the longer delay between the two schedules.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules. The input type is the intersection of both schedules' input\n * types.\n *\n * This is useful when coordinating multiple scheduling conditions where\n * execution should proceed only when both schedules permit it.\n *\n * @see {@link intersectWith} If you need to use a custom merge function.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const intersect = internal.intersect;\n/**\n * Combines two schedules, continuing only if both want to continue, merging\n * intervals using a custom function.\n *\n * **Details**\n *\n * This function takes two schedules and creates a new schedule that only\n * continues execution if both schedules allow it. Instead of automatically\n * using the longer delay (like {@link intersect}), this function applies a\n * user-provided merge function `f` to determine the next interval between\n * executions.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules, and the input type is the intersection of both schedules'\n * input types.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const intersectWith = internal.intersectWith;\n/**\n * Returns a new schedule that randomly adjusts the interval size within a\n * range.\n *\n * **Details**\n *\n * This function modifies a schedule so that its delay between executions is\n * randomly varied within a range. By default, the delay is adjusted between\n * `80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original\n * interval size.\n *\n * This is useful for adding randomness to repeated executions, reducing\n * contention in distributed systems, and avoiding synchronized execution\n * patterns that can cause bottlenecks.\n *\n * @see {@link jitteredWith} If you need to specify custom min/max values.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const jittered = internal.jittered;\n/**\n * Returns a new schedule that randomly adjusts the interval size within a\n * user-defined range.\n *\n * **Details**\n *\n * This function modifies a schedule so that its delay between executions is\n * randomly varied within a specified range. Instead of using the default `0.8 -\n * 1.2` range like {@link jittered}, this function allows customizing the `min`\n * and `max` multipliers.\n *\n * The delay for each step will be adjusted within `min * original_interval` and\n * `max * original_interval`. If `min` and `max` are not provided, the defaults\n * are `0.8` and `1.2`, respectively.\n *\n * This is useful for introducing randomness into scheduling behavior while\n * having precise control over the jitter range.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const jitteredWith = internal.jitteredWith;\n/**\n * Creates a schedule that recurs indefinitely, increasing the delay linearly.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `base` and increases the delay\n * on each recurrence in a linear fashion, following the formula:\n *\n * `delay = base * n`\n *\n * where `n` is the number of times the schedule has executed so far. This\n * results in increasing intervals between executions.\n *\n * This is useful for implementing linear backoff strategies where the wait time\n * between retries increases at a steady rate.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const linear = internal.linear;\n/**\n * Returns a new schedule that transforms its output using the specified\n * function.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that its outputs are\n * transformed by the provided function `f`. The timing and recurrence behavior\n * of the schedule remain unchanged, but the values it produces are mapped to\n * new values.\n *\n * This is useful when composing schedules where you need to adjust the output\n * format or apply additional processing.\n *\n * @see {@link mapEffect} If you need to use an effectful transformation\n * function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const map = internal.map;\n/**\n * Returns a new schedule that applies an effectful transformation to its\n * output.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying an effectful function\n * `f` to its output values. The timing and recurrence behavior of the schedule\n * remain unchanged, but each output is mapped to a new value within an\n * `Effect`.\n *\n * This is useful when you need to perform side effects or asynchronous\n * transformations before passing the output forward.\n *\n * @see {@link map} If you need to use a pure transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapEffect = internal.mapEffect;\n/**\n * Returns a new schedule that modifies the delay between executions using a\n * custom function.\n *\n * **Details**\n *\n * This function transforms an existing schedule by applying `f` to modify the\n * delay before each execution. The function receives both the schedule's output\n * (`out`) and the originally computed delay (`duration`), and returns a new\n * adjusted delay.\n *\n * @see {@link modifyDelayEffect} If you need to use an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const modifyDelay = internal.modifyDelay;\n/**\n * Returns a new schedule that modifies the delay before execution using an\n * effectful function.\n *\n * **Details**\n *\n * This function takes an existing schedule and applies an effectful function\n * `f` to dynamically adjust the delay before each execution. The function\n * receives both the schedule's output (`out`) and the originally computed delay\n * (`duration`), returning a new adjusted delay wrapped in an `Effect`.\n *\n * @see {@link modifyDelay} If you need to use a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const modifyDelayEffect = internal.modifyDelayEffect;\n/**\n * Returns a new schedule that executes an effect every time the schedule makes\n * a decision.\n *\n * **Details**\n *\n * This function enhances an existing schedule by running an effectful function\n * `f` whenever a scheduling decision is made. The function receives the current\n * schedule output (`out`) and the decision (`ScheduleDecision`), allowing\n * additional logic to be executed, such as logging, monitoring, or side\n * effects.\n *\n * @since 2.0.0\n */\nexport const onDecision = internal.onDecision;\n/**\n * A schedule that executes only once and then stops.\n *\n * **Details**\n *\n * This schedule triggers a single execution and then terminates. It does not\n * repeat or apply any additional logic.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const once = internal.once;\n/**\n * Returns a new schedule with a provided context, eliminating the need for\n * external dependencies.\n *\n * **Details**\n *\n * This function supplies a required `context` to a schedule, allowing it to run\n * without requiring external dependencies. After calling this function, the\n * schedule can be used freely without needing to pass a context at execution\n * time.\n *\n * This is useful when working with schedules that rely on contextual\n * information, such as logging services, database connections, or configuration\n * settings.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideContext = internal.provideContext;\n/**\n * Returns a new schedule with a single required service provided, eliminating\n * the need for external dependencies.\n *\n * **Details**\n *\n * This function supplies a single service dependency to a schedule, allowing it\n * to run without requiring that service externally. If a schedule depends on\n * multiple services, consider using `provideContext` instead.\n *\n * This is useful when working with schedules that require a specific service,\n * such as logging, metrics, or configuration retrieval.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideService = internal.provideService;\n/**\n * A schedule that recurs until the given predicate evaluates to true.\n *\n * **Details**\n *\n * This schedule will continue executing as long as the provided predicate `f`\n * returns `false` for the input value. Once `f` evaluates to `true`, the\n * schedule stops recurring.\n *\n * This is useful for defining schedules that should stop when a certain\n * condition is met, such as detecting a success state, reaching a threshold, or\n * avoiding unnecessary retries.\n *\n * @see {@link recurUntilEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntil = internal.recurUntil;\n/**\n * A schedule that recurs until the given effectful predicate evaluates to true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `false`. Once `f` evaluates to `true`, the schedule stops\n * recurring. Unlike {@link recurUntil}, this function allows the stopping\n * condition to be computed asynchronously or based on external dependencies.\n *\n * This is useful when the stopping condition depends on an effectful\n * computation, such as checking a database, making an API call, or retrieving\n * system state dynamically.\n *\n * @see {@link recurUntil} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntilEffect = internal.recurUntilEffect;\n/**\n * A schedule that recurs until the input value matches a partial function, then\n * maps the value.\n *\n * **Details**\n *\n * This schedule continues executing until the provided partial function `pf`\n * returns `Some(value)`. At that point, it stops and maps the resulting value\n * to an `Option<B>`. If `pf` returns `None`, the schedule continues.\n *\n * This is useful when defining schedules that should stop once a certain\n * condition is met and transform the final value before completion.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntilOption = internal.recurUntilOption;\n/**\n * A schedule that recurs until the specified duration has elapsed.\n *\n * **Details**\n *\n * This schedule continues executing for the given `duration`, after which it\n * stops. The schedule outputs the elapsed time on each recurrence.\n *\n * This is useful for limiting the duration of retries, enforcing time-based\n * constraints, or ensuring that an operation does not run indefinitely.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUpTo = internal.recurUpTo;\n/**\n * A schedule that recurs as long as the given predicate evaluates to true.\n *\n * **Details*\n *\n * This schedule continues executing as long as the provided predicate `f`\n * returns `true` for the input value. Once `f` evaluates to `false`, the\n * schedule stops recurring.\n *\n * @see {@link recurWhileEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurWhile = internal.recurWhile;\n/**\n * A schedule that recurs as long as the given effectful predicate evaluates to\n * true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `true`. Once `f` evaluates to `false`, the schedule stops\n * recurring. Unlike {@link recurWhile}, this function allows the condition to\n * be computed dynamically using an effectful computation.\n *\n * @see {@link recurWhile} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurWhileEffect = internal.recurWhileEffect;\n/**\n * A schedule that recurs a fixed number of times before terminating.\n *\n * **Details**\n *\n * This schedule will continue executing until it has been stepped `n` times,\n * after which it will stop. The output of the schedule is the current count of\n * recurrences.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const recurs = internal.recurs;\n/**\n * Returns a new schedule that folds over the outputs of this one.\n *\n * **Details**\n *\n * This schedule transforms the output by accumulating values over time using a\n * reducer function `f`. It starts with an initial value `zero` and updates it\n * each time the schedule produces an output.\n *\n * This is useful for tracking statistics, aggregating results, or summarizing\n * data across multiple executions.\n *\n * @see {@link reduceEffect} If you need to use an effectful reducer function.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduce = internal.reduce;\n/**\n * Returns a new schedule that effectfully folds over the outputs of this one.\n *\n * **Details**\n *\n * This schedule accumulates outputs over time using an effectful reducer\n * function `f`. It starts with an initial value `zero` and updates it\n * asynchronously or based on external dependencies.\n *\n * This is useful for asynchronous state tracking, logging, external metrics\n * aggregation, or any scenario where accumulation needs to involve an effectful\n * computation.\n *\n * @see {@link reduce} If you need to use a pure reducer function.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduceEffect = internal.reduceEffect;\n// TODO(4.0): remove?\n/**\n * Alias of {@link forever}.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const repeatForever = internal.forever;\n/**\n * Returns a new schedule that outputs the number of repetitions of this one.\n *\n * **Details**\n *\n * This schedule tracks how many times the given schedule has executed and\n * outputs the count instead of the original values. The first execution starts\n * at `0`, and the count increases with each recurrence.\n *\n * @since 2.0.0\n * @category Monitoring\n */\nexport const repetitions = internal.repetitions;\n/**\n * Returns a new schedule that automatically resets to its initial state after a\n * period of inactivity defined by `duration`.\n *\n * **Details**\n *\n * This function modifies a schedule so that if no inputs are received for the\n * specified `duration`, the schedule resets as if it were new.\n *\n * @see {@link resetWhen} If you need to reset based on output values.\n *\n * @since 2.0.0\n * @category State Management\n */\nexport const resetAfter = internal.resetAfter;\n/**\n * Resets the schedule when the specified predicate on the schedule output\n * evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies a schedule so that it resets to its initial state\n * whenever the provided predicate `f` returns `true` for an output value.\n *\n * @see {@link resetAfter} If you need to reset based on inactivity.\n *\n * @since 2.0.0\n * @category State Management\n */\nexport const resetWhen = internal.resetWhen;\n/**\n * Runs a schedule using the provided inputs and collects all outputs.\n *\n * **Details**\n *\n * This function executes a given schedule with a sequence of input values and\n * accumulates all outputs into a `Chunk`. The schedule starts execution at the\n * specified `now` timestamp and proceeds according to its defined behavior.\n *\n * This is useful for batch processing, simulating execution, or testing\n * schedules with predefined input sequences.\n *\n * @since 2.0.0\n * @category Execution\n */\nexport const run = internal.run;\n/**\n * Returns a schedule that recurs continuously, with each repetition\n * spaced by the specified `duration` from the last run.\n *\n * **Details**\n *\n * This schedule ensures that executions occur at a fixed interval,\n * maintaining a consistent delay between repetitions. The delay starts\n * from the end of the last execution, not from the schedule start time.\n *\n * @see {@link fixed} If you need to run at a fixed interval from the start.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const spaced = internal.spaced;\n/**\n * A schedule that does not recur and stops immediately.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const stop = internal.stop;\n/**\n * Returns a schedule that recurs indefinitely, always producing the specified\n * constant value.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const succeed = internal.succeed;\n/**\n * Returns a schedule that recurs indefinitely, evaluating the given function to\n * produce a constant value.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const sync = internal.sync;\n/**\n * Returns a new schedule that runs the given effectful function for each input\n * before continuing execution.\n *\n * **Details**\n *\n * This function allows side effects to be performed on each input processed by\n * the schedule. It does not modify the schedule’s behavior but ensures that the\n * provided function `f` runs before each step.\n *\n * @since 2.0.0\n * @category Tapping\n */\nexport const tapInput = internal.tapInput;\n/**\n * Returns a new schedule that runs the given effectful function for each output\n * before continuing execution.\n *\n * **Details**\n *\n * This function allows side effects to be performed on each output produced by\n * the schedule. It does not modify the schedule’s behavior but ensures that the\n * provided function `f` runs after each step.\n *\n * @since 2.0.0\n * @category Tapping\n */\nexport const tapOutput = internal.tapOutput;\n/**\n * Creates a schedule that repeatedly applies a function to transform a state\n * value, producing a sequence of values.\n *\n * **Details**\n *\n * This function starts with an `initial` value and applies `f` recursively to\n * generate the next state at each step. The schedule continues indefinitely,\n * producing a stream of values by unfolding the state over time.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const unfold = internal.unfold;\n/**\n * Combines two schedules, continuing execution as long as at least one of them\n * allows it, using the shorter delay.\n *\n * **Details**\n *\n * This function combines two schedules into a single schedule that executes in\n * parallel. If either schedule allows continuation, the merged schedule\n * continues. When both schedules produce delays, the schedule selects the\n * shorter delay to determine the next step.\n *\n * The output of the new schedule is a tuple containing the outputs of both\n * schedules. The input type is the intersection of both schedules' input types.\n *\n * This is useful for scenarios where multiple scheduling conditions should be\n * considered, ensuring execution proceeds if at least one schedule permits it.\n *\n * @see {@link unionWith} If you need to use a custom merge function.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const union = internal.union;\n/**\n * Combines two schedules, continuing execution as long as at least one of them\n * wants to continue, merging their intervals using a custom merge function.\n *\n * **Details**\n *\n * This function allows you to combine two schedules while defining how their\n * intervals should be merged. Unlike {@link union}, which simply selects the\n * shorter delay, this function lets you specify a custom merging strategy for\n * the schedules’ intervals.\n *\n * The merged schedule continues execution as long as at least one of the input\n * schedules allows it. The next interval is determined by applying the provided\n * merge function to the intervals of both schedules.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules. The input type is the intersection of both schedules' input\n * types.\n *\n * @see {@link union} If you need to use the shorter delay.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const unionWith = internal.unionWith;\n/**\n * Returns a new schedule that stops execution when the given predicate on the\n * input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it continues executing\n * only while the provided predicate returns `false` for incoming inputs. Once\n * an input satisfies the condition, the schedule terminates immediately.\n *\n * @see {@link untilInputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilInput = internal.untilInput;\n/**\n * Returns a new schedule that stops execution when the given effectful\n * predicate on the input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it continues executing\n * only while the provided effectful predicate returns `false` for incoming\n * inputs. The predicate is an `Effect`, meaning it can involve asynchronous\n * computations or dependency-based logic.\n *\n * @see {@link untilInput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilInputEffect = internal.untilInputEffect;\n/**\n * Returns a new schedule that stops execution when the given predicate on the\n * output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * executing while the given predicate returns false for its output values. Once\n * the predicate evaluates to `true`, execution stops.\n *\n * The output of the resulting schedule remains the same, but its duration is\n * now constrained by a stopping condition based on its own output.\n *\n * @see {@link untilOutputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilOutput = internal.untilOutput;\n/**\n * Returns a new schedule that stops execution when the given effectful\n * predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * executing while the provided effectful predicate returns `false` for its\n * output values. Once the predicate returns `true`, execution stops.\n *\n * @see {@link untilOutput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilOutputEffect = internal.untilOutputEffect;\n/**\n * Returns a new schedule that limits execution to a fixed duration.\n *\n * **Details**\n *\n * This function modifies an existing schedule to stop execution after a\n * specified duration has passed. The schedule continues as normal until the\n * duration is reached, at which point it stops automatically.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const upTo = internal.upTo;\n/**\n * Returns a new schedule that continues execution as long as the given\n * predicate on the input is true.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while a specified predicate holds true for its input. If the\n * predicate evaluates to `false` at any step, the schedule stops.\n *\n * @see {@link whileInputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileInput = internal.whileInput;\n/**\n * Returns a new schedule that continues execution for as long as the given\n * effectful predicate on the input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while an effectful predicate holds true for its input. If the\n * predicate evaluates to `false` at any step, the schedule stops.\n *\n * @see {@link whileInput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileInputEffect = internal.whileInputEffect;\n/**\n * Returns a new schedule that continues execution for as long as the given\n * predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while a provided condition holds true for its output. If the\n * predicate returns `false`, the schedule stops.\n *\n * @see {@link whileOutputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileOutput = internal.whileOutput;\n/**\n * Returns a new schedule that continues execution for as long as the given\n * effectful predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while an effectful condition holds true for its output. If the\n * effectful predicate returns `false`, the schedule stops.\n *\n * @see {@link whileOutput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileOutputEffect = internal.whileOutputEffect;\n/**\n * Creates a schedule that divides time into fixed `interval`-long windows,\n * triggering execution at the start of each new window.\n *\n * **Details**\n *\n * This function produces a schedule that waits until the next time window\n * boundary before executing. Each window spans a fixed duration specified by\n * `interval`. If an action completes midway through a window, the schedule\n * waits until the next full window starts before proceeding.\n *\n * For example, `windowed(Duration.seconds(10))` would produce a schedule as\n * follows:\n *\n * ```text\n *      10s        10s        10s       10s\n * |----------|----------|----------|----------|\n * |action------|sleep---|act|-sleep|action----|\n * ```\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const windowed = internal.windowed;\n/**\n * The same as {@link intersect} but ignores the right output.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipLeft = internal.zipLeft;\n/**\n * The same as {@link intersect} but ignores the left output.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipRight = internal.zipRight;\n/**\n * Equivalent to {@link intersect} followed by {@link map}.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipWith = internal.zipWith;\n/**\n * @since 3.15.0\n * @category models\n */\nexport const CurrentIterationMetadata = internal.CurrentIterationMetadata;\n//# sourceMappingURL=Schedule.js.map",
      "start": 1768772628410,
      "end": 1768772628410
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628410,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628420,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628435,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628478,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
