{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/pool.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as Effectable from \"../Effectable.js\";\nimport { dual, identity } from \"../Function.js\";\nimport * as Iterable from \"../Iterable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as coreEffect from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport * as circular from \"./effect/circular.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\nimport * as internalQueue from \"./queue.js\";\n/** @internal */\nexport const PoolTypeId = /*#__PURE__*/Symbol.for(\"effect/Pool\");\nconst poolVariance = {\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport const isPool = u => hasProperty(u, PoolTypeId);\n/** @internal */\nexport const makeWith = options => core.uninterruptibleMask(restore => core.flatMap(core.context(), context => {\n  const scope = Context.get(context, fiberRuntime.scopeTag);\n  const acquire = core.mapInputContext(options.acquire, input => Context.merge(context, input));\n  const pool = new PoolImpl(scope, acquire, options.concurrency ?? 1, options.min, options.max, options.strategy, Math.min(Math.max(options.targetUtilization ?? 1, 0.1), 1));\n  const initialize = core.tap(fiberRuntime.forkDaemon(restore(pool.resize)), fiber => scope.addFinalizer(() => core.interruptFiber(fiber)));\n  const runStrategy = core.tap(fiberRuntime.forkDaemon(restore(options.strategy.run(pool))), fiber => scope.addFinalizer(() => core.interruptFiber(fiber)));\n  return core.succeed(pool).pipe(core.zipLeft(scope.addFinalizer(() => pool.shutdown)), core.zipLeft(initialize), core.zipLeft(runStrategy));\n}));\n/** @internal */\nexport const make = options => makeWith({\n  ...options,\n  min: options.size,\n  max: options.size,\n  strategy: strategyNoop()\n});\n/** @internal */\nexport const makeWithTTL = options => core.flatMap(options.timeToLiveStrategy === \"creation\" ? strategyCreationTTL(options.timeToLive) : strategyUsageTTL(options.timeToLive), strategy => makeWith({\n  ...options,\n  strategy\n}));\n/** @internal */\nexport const get = self => self.get;\n/** @internal */\nexport const invalidate = /*#__PURE__*/dual(2, (self, item) => self.invalidate(item));\nclass PoolImpl extends Effectable.Class {\n  scope;\n  acquire;\n  concurrency;\n  minSize;\n  maxSize;\n  strategy;\n  targetUtilization;\n  [PoolTypeId];\n  isShuttingDown = false;\n  semaphore;\n  items = /*#__PURE__*/new Set();\n  available = /*#__PURE__*/new Set();\n  availableLatch = /*#__PURE__*/circular.unsafeMakeLatch(false);\n  invalidated = /*#__PURE__*/new Set();\n  waiters = 0;\n  constructor(scope, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {\n    super();\n    this.scope = scope;\n    this.acquire = acquire;\n    this.concurrency = concurrency;\n    this.minSize = minSize;\n    this.maxSize = maxSize;\n    this.strategy = strategy;\n    this.targetUtilization = targetUtilization;\n    this[PoolTypeId] = poolVariance;\n    this.semaphore = circular.unsafeMakeSemaphore(concurrency * maxSize);\n  }\n  allocate = /*#__PURE__*/core.acquireUseRelease(/*#__PURE__*/fiberRuntime.scopeMake(), scope => this.acquire.pipe(fiberRuntime.scopeExtend(scope), core.exit, core.flatMap(exit => {\n    const item = {\n      exit,\n      finalizer: core.catchAllCause(scope.close(exit), reportUnhandledError),\n      refCount: 0,\n      disableReclaim: false\n    };\n    this.items.add(item);\n    this.available.add(item);\n    return core.as(exit._tag === \"Success\" ? this.strategy.onAcquire(item) : core.zipRight(item.finalizer, this.strategy.onAcquire(item)), item);\n  })), (scope, exit) => exit._tag === \"Failure\" ? scope.close(exit) : core.void);\n  get currentUsage() {\n    let count = this.waiters;\n    for (const item of this.items) {\n      count += item.refCount;\n    }\n    return count;\n  }\n  get targetSize() {\n    if (this.isShuttingDown) return 0;\n    const utilization = this.currentUsage / this.targetUtilization;\n    const target = Math.ceil(utilization / this.concurrency);\n    return Math.min(Math.max(this.minSize, target), this.maxSize);\n  }\n  get activeSize() {\n    return this.items.size - this.invalidated.size;\n  }\n  resizeLoop = /*#__PURE__*/core.suspend(() => {\n    if (this.activeSize >= this.targetSize) {\n      return core.void;\n    }\n    const toAcquire = this.targetSize - this.activeSize;\n    return this.strategy.reclaim(this).pipe(core.flatMap(Option.match({\n      onNone: () => this.allocate,\n      onSome: core.succeed\n    })), fiberRuntime.replicateEffect(toAcquire, {\n      concurrency: toAcquire\n    }), core.zipLeft(this.availableLatch.open), core.flatMap(items => items.some(_ => _.exit._tag === \"Failure\") ? core.void : this.resizeLoop));\n  });\n  resizeSemaphore = /*#__PURE__*/circular.unsafeMakeSemaphore(1);\n  resize = /*#__PURE__*/this.resizeSemaphore.withPermits(1)(this.resizeLoop);\n  getPoolItem = /*#__PURE__*/core.uninterruptibleMask(restore => restore(this.semaphore.take(1)).pipe(core.zipRight(fiberRuntime.scopeTag), core.flatMap(scope => core.suspend(() => {\n    this.waiters++;\n    if (this.isShuttingDown) {\n      return core.interrupt;\n    } else if (this.targetSize > this.activeSize) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const self = this;\n      return core.flatMap(this.resizeSemaphore.withPermitsIfAvailable(1)(circular.forkIn(core.interruptible(this.resize), this.scope)), function loop() {\n        if (self.isShuttingDown) {\n          return core.interrupt;\n        } else if (self.available.size > 0) {\n          return core.succeed(Iterable.unsafeHead(self.available));\n        }\n        self.availableLatch.unsafeClose();\n        return core.flatMap(self.availableLatch.await, loop);\n      });\n    }\n    return core.succeed(Iterable.unsafeHead(this.available));\n  }).pipe(fiberRuntime.ensuring(core.sync(() => this.waiters--)), core.tap(item => {\n    if (item.exit._tag === \"Failure\") {\n      this.items.delete(item);\n      this.invalidated.delete(item);\n      this.available.delete(item);\n      return this.semaphore.release(1);\n    }\n    item.refCount++;\n    this.available.delete(item);\n    if (item.refCount < this.concurrency) {\n      this.available.add(item);\n    }\n    return scope.addFinalizer(() => core.zipRight(core.suspend(() => {\n      item.refCount--;\n      if (this.invalidated.has(item)) {\n        return this.invalidatePoolItem(item);\n      }\n      this.available.add(item);\n      return core.exitVoid;\n    }), this.semaphore.release(1)));\n  }), core.onInterrupt(() => this.semaphore.release(1))))));\n  commit() {\n    return this.get;\n  }\n  get = /*#__PURE__*/core.flatMap(/*#__PURE__*/core.suspend(() => this.isShuttingDown ? core.interrupt : this.getPoolItem), _ => _.exit);\n  invalidate(item) {\n    return core.suspend(() => {\n      if (this.isShuttingDown) return core.void;\n      for (const poolItem of this.items) {\n        if (poolItem.exit._tag === \"Success\" && poolItem.exit.value === item) {\n          poolItem.disableReclaim = true;\n          return core.uninterruptible(this.invalidatePoolItem(poolItem));\n        }\n      }\n      return core.void;\n    });\n  }\n  invalidatePoolItem(poolItem) {\n    return core.suspend(() => {\n      if (!this.items.has(poolItem)) {\n        return core.void;\n      } else if (poolItem.refCount === 0) {\n        this.items.delete(poolItem);\n        this.available.delete(poolItem);\n        this.invalidated.delete(poolItem);\n        return core.zipRight(poolItem.finalizer, circular.forkIn(core.interruptible(this.resize), this.scope));\n      }\n      this.invalidated.add(poolItem);\n      this.available.delete(poolItem);\n      return core.void;\n    });\n  }\n  get shutdown() {\n    return core.suspend(() => {\n      if (this.isShuttingDown) return core.void;\n      this.isShuttingDown = true;\n      const size = this.items.size;\n      const semaphore = circular.unsafeMakeSemaphore(size);\n      return core.forEachSequentialDiscard(this.items, item => {\n        if (item.refCount > 0) {\n          item.finalizer = core.zipLeft(item.finalizer, semaphore.release(1));\n          this.invalidated.add(item);\n          return semaphore.take(1);\n        }\n        this.items.delete(item);\n        this.available.delete(item);\n        this.invalidated.delete(item);\n        return item.finalizer;\n      }).pipe(core.zipRight(this.semaphore.releaseAll), core.zipRight(this.availableLatch.open), core.zipRight(semaphore.take(size)));\n    });\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\nconst strategyNoop = () => ({\n  run: _ => core.void,\n  onAcquire: _ => core.void,\n  reclaim: _ => coreEffect.succeedNone\n});\nconst strategyCreationTTL = ttl => defaultServices.clockWith(clock => core.map(internalQueue.unbounded(), queue => {\n  const ttlMillis = Duration.toMillis(ttl);\n  const creationTimes = new WeakMap();\n  return identity({\n    run: pool => {\n      const process = item => core.suspend(() => {\n        if (!pool.items.has(item) || pool.invalidated.has(item)) {\n          return core.void;\n        }\n        const now = clock.unsafeCurrentTimeMillis();\n        const created = creationTimes.get(item);\n        const remaining = ttlMillis - (now - created);\n        return remaining > 0 ? coreEffect.delay(process(item), remaining) : pool.invalidatePoolItem(item);\n      });\n      return queue.take.pipe(core.tap(process), coreEffect.forever);\n    },\n    onAcquire: item => core.suspend(() => {\n      creationTimes.set(item, clock.unsafeCurrentTimeMillis());\n      return queue.offer(item);\n    }),\n    reclaim: _ => coreEffect.succeedNone\n  });\n}));\nconst strategyUsageTTL = ttl => core.map(internalQueue.unbounded(), queue => {\n  return identity({\n    run: pool => {\n      const process = core.suspend(() => {\n        const excess = pool.activeSize - pool.targetSize;\n        if (excess <= 0) return core.void;\n        return queue.take.pipe(core.tap(item => pool.invalidatePoolItem(item)), core.zipRight(process));\n      });\n      return process.pipe(coreEffect.delay(ttl), coreEffect.forever);\n    },\n    onAcquire: item => queue.offer(item),\n    reclaim(pool) {\n      return core.suspend(() => {\n        if (pool.invalidated.size === 0) {\n          return coreEffect.succeedNone;\n        }\n        const item = Iterable.head(Iterable.filter(pool.invalidated, item => !item.disableReclaim));\n        if (item._tag === \"None\") {\n          return coreEffect.succeedNone;\n        }\n        pool.invalidated.delete(item.value);\n        if (item.value.refCount < pool.concurrency) {\n          pool.available.add(item.value);\n        }\n        return core.as(queue.offer(item.value), item);\n      });\n    }\n  });\n});\nconst reportUnhandledError = cause => core.withFiberRuntime(fiber => {\n  const unhandledLogLevel = fiber.getFiberRef(core.currentUnhandledErrorLogLevel);\n  if (unhandledLogLevel._tag === \"Some\") {\n    fiber.log(\"Unhandled error in pool finalizer\", cause, unhandledLogLevel);\n  }\n  return core.void;\n});\n//# sourceMappingURL=pool.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
