{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/packages/shared/dist/utils/src/lib/logger.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * Copyright 2025 GDG on Campus Farmingdale State College\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Effect, Logger as EffectLogger, LogLevel as EffectLogLevel } from 'effect';\n/**\n * @fileoverview A comprehensive logging utility for both client and server environments.\n * Provides structured logging with support for different log levels, colorization,\n * and contextual information.\n */\n/**\n * Determines if the code is running in a server environment\n */\n/**\n * Enum representing different logging levels with their priority values.\n * Higher values indicate more verbose logging.\n * @enum {number}\n */\nexport var LogLevel;\n(function (LogLevel) {\n    /** No logging */\n    LogLevel[LogLevel[\"NONE\"] = 0] = \"NONE\";\n    /** Only error messages */\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    /** Errors and warnings */\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    /** Errors, warnings, and informational messages */\n    LogLevel[LogLevel[\"INFO\"] = 3] = \"INFO\";\n    /** Errors, warnings, info, and debug messages */\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    /** Errors, warnings, info, debug, and trace messages */\n    LogLevel[LogLevel[\"TRACE\"] = 5] = \"TRACE\";\n    /** All possible log messages */\n    LogLevel[LogLevel[\"ALL\"] = 6] = \"ALL\";\n})(LogLevel || (LogLevel = {}));\n/**\n * A versatile logging utility that works in both browser and Node.js environments.\n * Supports multiple log levels, colorized output, and structured data logging.\n */\nexport class Logger {\n    /** The context/category name for this logger instance */\n    context;\n    /** The minimum log level that will be output */\n    minLevel;\n    /** Registry of logger instances to implement the singleton pattern */\n    static instances = new Map();\n    /**\n     * Create a new Logger instance or return an existing one for the given context\n     * @param {string} context - The context name for this logger (e.g., component or service name)\n     * @param {LoggerOptions} [options={}] - Optional logger configuration\n     */\n    constructor(context, options = {}) {\n        this.context = context;\n        this.minLevel =\n            options.minLevel ?? (process.env.NODE_ENV === 'production' ? LogLevel.ERROR : LogLevel.ALL);\n    }\n    /**\n     * Get a logger instance for the given context.\n     * If a logger with this context already exists, returns the existing instance.\n     *\n     * @param {string} context - The context name\n     * @param {LoggerOptions} [options] - Optional logger configuration\n     * @returns {Logger} A logger instance for the specified context\n     */\n    static getLogger(context, options) {\n        let instance = Logger.instances.get(context);\n        if (!instance) {\n            instance = new Logger(context, options);\n            Logger.instances.set(context, instance);\n        }\n        return instance;\n    }\n    /**\n     * Set global minimum log level for all logger instances\n     *\n     * @param {LogLevel} level - The minimum level to log across all loggers\n     */\n    static setGlobalLogLevel(level) {\n        Logger.instances.forEach((logger) => {\n            logger.minLevel = level;\n        });\n    }\n    /**\n     * Maps internal LogLevel to Effect's LogLevel\n     */\n    getEffectLogLevel(level) {\n        switch (level) {\n            case LogLevel.NONE:\n                return EffectLogLevel.None;\n            case LogLevel.ERROR:\n                return EffectLogLevel.Error;\n            case LogLevel.WARN:\n                return EffectLogLevel.Warning;\n            case LogLevel.INFO:\n                return EffectLogLevel.Info;\n            case LogLevel.DEBUG:\n                return EffectLogLevel.Debug;\n            case LogLevel.TRACE:\n                return EffectLogLevel.Debug; // Effect doesn't have Trace, mapping to Debug\n            case LogLevel.ALL:\n                return EffectLogLevel.All;\n            default:\n                return EffectLogLevel.Info;\n        }\n    }\n    /**\n     * Run an effect with the logger's context and configuration\n     */\n    run(effect) {\n        // Determine the minimum log level for this execution\n        const minEffectLevel = this.getEffectLogLevel(this.minLevel);\n        // Apply context and log level configuration\n        const program = effect.pipe(Effect.annotateLogs({ context: this.context }), EffectLogger.withMinimumLogLevel(minEffectLevel));\n        // If the configured minLevel is higher (less verbose) than what we want to log,\n        // Effect's default logger might still show it if we don't configure it.\n        // But since we are just wrapping Effect.log*, we can just run it.\n        // To strictly enforce minLevel per instance, we would need a custom logger layer.\n        // For now, we'll assume the global configuration or default is acceptable,\n        // or we can manually check before running.\n        // Manual check to match previous behavior's strictness\n        // (This is a bit redundant with Effect's own level handling but ensures backward compat)\n        // We'll skip the manual check here and let Effect handle it, assuming standard usage.\n        // If we strictly need to suppress, we can do:\n        // if (this.getEffectLogLevel(this.minLevel).ordinal > ... ) return;\n        try {\n            Effect.runSync(Effect.scoped(program));\n        }\n        catch (error) {\n            // Fallback if Effect fails (shouldn't happen for standard logging)\n            console.error('Logger failed:', error);\n        }\n    }\n    /**\n     * Log an informational message\n     *\n     * @param {string} message - The message to log\n     * @param {LogData} [data] - Optional data to include\n     */\n    info(message, data) {\n        if (this.minLevel < LogLevel.INFO)\n            return;\n        this.run(Effect.logInfo(message).pipe(Effect.annotateLogs(data || {})));\n    }\n    /**\n     * Log an error message\n     *\n     * @param {string} message - The error message\n     * @param {Error|unknown} [error] - Optional Error object or unknown error\n     * @param {LogData} [data] - Optional additional data\n     */\n    error(message, error, data) {\n        if (this.minLevel < LogLevel.ERROR)\n            return;\n        let errorObj = error;\n        if (error instanceof Error) {\n            errorObj = { name: error.name, message: error.message, stack: error.stack };\n        }\n        this.run(Effect.logError(message).pipe(Effect.annotateLogs({ ...data, error: errorObj })));\n    }\n    /**\n     * Log a warning message\n     *\n     * @param {string} message - The warning message\n     * @param {LogData} [data] - Optional data to include\n     */\n    warn(message, data) {\n        if (this.minLevel < LogLevel.WARN)\n            return;\n        this.run(Effect.logWarning(message).pipe(Effect.annotateLogs(data || {})));\n    }\n    /**\n     * Log a debug message\n     *\n     * @param {string} message - The debug message\n     * @param {LogData} [data] - Optional data to include\n     */\n    debug(message, data) {\n        if (this.minLevel < LogLevel.DEBUG)\n            return;\n        this.run(Effect.logDebug(message).pipe(Effect.annotateLogs(data || {})));\n    }\n    /**\n     * Log a trace message (most verbose level)\n     *\n     * @param {string} message - The trace message\n     * @param {LogData} [data] - Optional data to include\n     */\n    trace(message, data) {\n        if (this.minLevel < LogLevel.TRACE)\n            return;\n        // Mapping trace to debug as Effect doesn't have a distinct trace level exposed easily\n        this.run(Effect.logDebug(message).pipe(Effect.annotateLogs({ ...data, level: 'TRACE' })));\n    }\n    /**\n     * Log an action message (for server actions or important user interactions)\n     *\n     * @param {string} message - The action message\n     * @param {LogData} [data] - Optional data to include\n     */\n    action(message, data) {\n        if (this.minLevel < LogLevel.INFO)\n            return;\n        // Action is effectively Info but we tag it\n        this.run(Effect.logInfo(message).pipe(Effect.annotateLogs({ ...data, type: 'ACTION' })));\n    }\n    /**\n     * Log a success message\n     *\n     * @param {string} message - The success message\n     * @param {LogData} [data] - Optional data to include\n     */\n    success(message, data) {\n        if (this.minLevel < LogLevel.INFO)\n            return;\n        // Success is effectively Info but we tag it\n        this.run(Effect.logInfo(message).pipe(Effect.annotateLogs({ ...data, type: 'SUCCESS' })));\n    }\n    /**\n     * Group related log messages (Console.group wrapper)\n     *\n     * @param {string} label - The group label\n     */\n    group(label) {\n        if (this.minLevel < LogLevel.INFO)\n            return;\n        // Effect doesn't have a direct equivalent for console.group in its Logger\n        // We can use Console.group directly as it's a wrapper around console.group\n        // but we should be careful about mixing Effect logs and direct console logs.\n        // For now, we'll use the direct Console import from effect which wraps console.\n        // Note: This might not respect Effect's structured logging output format for the group header itself.\n        console.group(label);\n    }\n    /**\n     * End a log group (Console.groupEnd wrapper)\n     */\n    groupEnd() {\n        if (this.minLevel < LogLevel.INFO)\n            return;\n        console.groupEnd();\n    }\n    /**\n     * Log execution time of a function\n     *\n     * @template T - The return type of the function being timed\n     * @param {string} label - Description of the operation being timed\n     * @param {() => Promise<T> | T} fn - Function to execute and time\n     * @returns {Promise<T>} The result of the function execution\n     */\n    async time(label, fn) {\n        if (this.minLevel < LogLevel.DEBUG)\n            return fn();\n        // We can use Effect.timed if we wrap the function in an Effect,\n        // but since fn returns a Promise or value, we might just want to measure it manually\n        // to avoid wrapping everything in Effect if the consumer isn't using Effect.\n        const startTime = performance.now();\n        try {\n            const result = await fn();\n            const endTime = performance.now();\n            const duration = (endTime - startTime).toFixed(2);\n            this.info(`${label} completed`, { duration: `${duration}ms` });\n            return result;\n        }\n        catch (error) {\n            const endTime = performance.now();\n            const duration = (endTime - startTime).toFixed(2);\n            this.error(`${label} failed`, error, { duration: `${duration}ms` });\n            throw error;\n        }\n    }\n}\nexport const logger = new Logger('[LOGGER]', {\n    includeTimestamp: true,\n    colorize: true,\n});\n//# sourceMappingURL=logger.js.map",
      "start": 1768772628388,
      "end": 1768772628388
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628388,
      "end": 1768772628389,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628394,
      "end": 1768772628394,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628410,
      "end": 1768772628410,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628422,
      "end": 1768772628422,
      "order": "post-post"
    }
  ]
}
