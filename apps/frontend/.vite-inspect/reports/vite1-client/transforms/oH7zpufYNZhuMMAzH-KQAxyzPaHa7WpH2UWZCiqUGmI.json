{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Chunk.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as RA from \"./Array.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity, pipe } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as O from \"./Option.js\";\nimport * as Order from \"./Order.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Chunk\");\nfunction copy(src, srcPos, dest, destPos, len) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i];\n  }\n  return dest;\n}\nconst emptyArray = [];\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i))));\nconst _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);\nconst ChunkProto = {\n  [TypeId]: {\n    _A: _ => _\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Chunk\",\n      values: toReadonlyArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Equal.symbol](that) {\n    return isChunk(that) && _equivalence(this, that);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(toReadonlyArray(this)));\n  },\n  [Symbol.iterator]() {\n    switch (this.backing._tag) {\n      case \"IArray\":\n        {\n          return this.backing.array[Symbol.iterator]();\n        }\n      case \"IEmpty\":\n        {\n          return emptyArray[Symbol.iterator]();\n        }\n      default:\n        {\n          return toReadonlyArray(this)[Symbol.iterator]();\n        }\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeChunk = backing => {\n  const chunk = Object.create(ChunkProto);\n  chunk.backing = backing;\n  switch (backing._tag) {\n    case \"IEmpty\":\n      {\n        chunk.length = 0;\n        chunk.depth = 0;\n        chunk.left = chunk;\n        chunk.right = chunk;\n        break;\n      }\n    case \"IConcat\":\n      {\n        chunk.length = backing.left.length + backing.right.length;\n        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);\n        chunk.left = backing.left;\n        chunk.right = backing.right;\n        break;\n      }\n    case \"IArray\":\n      {\n        chunk.length = backing.array.length;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISingleton\":\n      {\n        chunk.length = 1;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISlice\":\n      {\n        chunk.length = backing.length;\n        chunk.depth = backing.chunk.depth + 1;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n  }\n  return chunk;\n};\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const isChunk = u => hasProperty(u, TypeId);\nconst _empty = /*#__PURE__*/makeChunk({\n  _tag: \"IEmpty\"\n});\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = () => _empty;\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = (...as) => unsafeFromNonEmptyArray(as);\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = a => makeChunk({\n  _tag: \"ISingleton\",\n  a\n});\n/**\n * Creates a new `Chunk` from an iterable collection of values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = self => isChunk(self) ? self : unsafeFromArray(RA.fromIterable(self));\nconst copyToArray = (self, array, initial) => {\n  switch (self.backing._tag) {\n    case \"IArray\":\n      {\n        copy(self.backing.array, 0, array, initial, self.length);\n        break;\n      }\n    case \"IConcat\":\n      {\n        copyToArray(self.left, array, initial);\n        copyToArray(self.right, array, initial + self.left.length);\n        break;\n      }\n    case \"ISingleton\":\n      {\n        array[initial] = self.backing.a;\n        break;\n      }\n    case \"ISlice\":\n      {\n        let i = 0;\n        let j = initial;\n        while (i < self.length) {\n          array[j] = unsafeGet(self, i);\n          i += 1;\n          j += 1;\n        }\n        break;\n      }\n  }\n};\nconst toArray_ = self => toReadonlyArray(self).slice();\n/**\n * Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n * (`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\n * non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = toArray_;\nconst toReadonlyArray_ = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        return emptyArray;\n      }\n    case \"IArray\":\n      {\n        return self.backing.array;\n      }\n    default:\n      {\n        const arr = new Array(self.length);\n        copyToArray(self, arr, 0);\n        self.backing = {\n          _tag: \"IArray\",\n          array: arr\n        };\n        self.left = _empty;\n        self.right = _empty;\n        self.depth = 0;\n        return arr;\n      }\n  }\n};\n/**\n * Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\n * non-empty (`NonEmptyChunk`), the function will return a\n * `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toReadonlyArray = toReadonlyArray_;\nconst reverseChunk = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n    case \"ISingleton\":\n      return self;\n    case \"IArray\":\n      {\n        return makeChunk({\n          _tag: \"IArray\",\n          array: RA.reverse(self.backing.array)\n        });\n      }\n    case \"IConcat\":\n      {\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: reverse(self.backing.right),\n          right: reverse(self.backing.left)\n        });\n      }\n    case \"ISlice\":\n      return unsafeFromArray(RA.reverse(toReadonlyArray(self)));\n  }\n};\n/**\n * Reverses the order of elements in a `Chunk`.\n * Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const chunk = Chunk.make(1, 2, 3)\n * const result = Chunk.reverse(chunk)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 3, 2, 1 ] }\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = reverseChunk;\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const get = /*#__PURE__*/dual(2, (self, index) => index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index)));\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromArray = self => self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({\n  _tag: \"IArray\",\n  array: self\n});\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromNonEmptyArray = self => unsafeFromArray(self);\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        throw new Error(`Index out of bounds`);\n      }\n    case \"ISingleton\":\n      {\n        if (index !== 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.a;\n      }\n    case \"IArray\":\n      {\n        if (index >= self.length || index < 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.array[index];\n      }\n    case \"IConcat\":\n      {\n        return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);\n      }\n    case \"ISlice\":\n      {\n        return unsafeGet(self.backing.chunk, index + self.backing.offset);\n      }\n  }\n});\n/**\n * Appends the specified element to the end of the `Chunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, a) => appendAll(self, of(a)));\n/**\n * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, elem) => appendAll(of(elem), self));\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _empty;\n  } else if (n >= self.length) {\n    return self;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            length: n,\n            offset: self.backing.offset\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return makeChunk({\n              _tag: \"IConcat\",\n              left: self.left,\n              right: take(self.right, n - self.left.length)\n            });\n          }\n          return take(self.left, n);\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: 0,\n            length: n\n          });\n        }\n    }\n  }\n});\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  } else if (n >= self.length) {\n    return _empty;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            offset: self.backing.offset + n,\n            length: self.backing.length - n\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return drop(self.right, n - self.left.length);\n          }\n          return makeChunk({\n            _tag: \"IConcat\",\n            left: drop(self.left, n),\n            right: self.right\n          });\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: n,\n            length: self.length - n\n          });\n        }\n    }\n  }\n});\n/**\n * Drops the last `n` elements.\n *\n * @since 2.0.0\n */\nexport const dropRight = /*#__PURE__*/dual(2, (self, n) => take(self, Math.max(0, self.length - n)));\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n */\nexport const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const arr = toReadonlyArray(self);\n  const len = arr.length;\n  let i = 0;\n  while (i < len && predicate(arr[i])) {\n    i++;\n  }\n  return drop(self, i);\n});\n/**\n * Prepends the specified prefix chunk to the beginning of the specified chunk.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ \"a\", \"b\", 1, 2 ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, that) => appendAll(that, self));\n/**\n * Concatenates two chunks, combining their elements.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ 1, 2, \"a\", \"b\" ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that;\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self;\n  }\n  const diff = that.depth - self.depth;\n  if (Math.abs(diff) <= 1) {\n    return makeChunk({\n      _tag: \"IConcat\",\n      left: self,\n      right: that\n    });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = appendAll(self.right, that);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: self.left,\n        right: nr\n      });\n    } else {\n      const nrr = appendAll(self.right.right, that);\n      if (nrr.depth === self.depth - 3) {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: self.right.left,\n          right: nrr\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: nr\n        });\n      } else {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: self.right.left\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: nrr\n        });\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = appendAll(self, that.left);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: nl,\n        right: that.right\n      });\n    } else {\n      const nll = appendAll(self, that.left.left);\n      if (nll.depth === that.depth - 3) {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: that.left.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: that.right\n        });\n      } else {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: that.left.right,\n          right: that.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: nr\n        });\n      }\n    }\n  }\n});\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(RA.filterMap(self, f)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => unsafeFromArray(RA.filter(self, predicate)));\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMapWhile = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(RA.filterMapWhile(self, f)));\n/**\n * Filter out optional values\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a, 0);\n  }\n  let out = _empty;\n  let i = 0;\n  for (const k of self) {\n    out = appendAll(out, f(k, i++));\n  }\n  return out;\n});\n/**\n * Iterates over each element of a `Chunk` and applies a function to it.\n *\n * **Details**\n *\n * This function processes every element of the given `Chunk`, calling the\n * provided function `f` on each element. It does not return a new value;\n * instead, it is primarily used for side effects, such as logging or\n * accumulating data in an external variable.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => toReadonlyArray(self).forEach(f));\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten = /*#__PURE__*/flatMap(identity);\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const gr = [];\n  let current = [];\n  toReadonlyArray(self).forEach(a => {\n    current.push(a);\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current));\n      current = [];\n    }\n  });\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current));\n  }\n  return unsafeFromArray(gr);\n});\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const intersection = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that))));\n/**\n * Determines if the chunk is empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = self => self.length === 0;\n/**\n * Determines if the chunk is not empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isNonEmpty = self => self.length > 0;\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * Returns the first element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => unsafeGet(self, 0);\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const headNonEmpty = unsafeHead;\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const last = self => get(self, self.length - 1);\n/**\n * Returns the last element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => unsafeGet(self, self.length - 1);\n/**\n * Returns the last element of this non empty chunk.\n *\n * @since 3.4.0\n * @category elements\n */\nexport const lastNonEmpty = unsafeLast;\n/**\n * Transforms the elements of a chunk using the specified mapping function.\n * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 2, 3 ] }\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), RA.map((a, i) => f(a, i)))));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  const [s1, as] = RA.mapAccum(self, s, f);\n  return [s1, unsafeFromArray(as)];\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => pipe(RA.partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => pipe(RA.partitionMap(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate = self => pipe(RA.separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);\n/**\n * Retireves the size of the chunk\n *\n * @since 2.0.0\n * @category elements\n */\nexport const size = self => self.length;\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 2.0.0\n * @category sorting\n */\nexport const sort = /*#__PURE__*/dual(2, (self, O) => unsafeFromArray(RA.sort(toReadonlyArray(self), O)));\n/**\n * @since 2.0.0\n * @category sorting\n */\nexport const sortWith = /*#__PURE__*/dual(3, (self, f, order) => sort(self, Order.mapInput(order, f)));\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {\n  const _n = Math.max(1, Math.floor(n));\n  return _n >= self.length ? [self, empty()] : [take(self, _n), drop(self, _n)];\n});\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split = /*#__PURE__*/dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));\n/**\n * Splits this chunk on the first element that matches this predicate.\n * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      break;\n    } else {\n      i++;\n    }\n  }\n  return splitAt(self, i);\n});\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tail = self => self.length > 0 ? O.some(drop(self, 1)) : O.none();\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tailNonEmpty = self => drop(self, 1);\n/**\n * Takes the last `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => drop(self, self.length - n));\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const out = [];\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(out);\n});\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const union = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that))));\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const dedupe = self => unsafeFromArray(RA.dedupe(toReadonlyArray(self)));\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const dedupeAdjacent = self => unsafeFromArray(RA.dedupeAdjacent(self));\n/**\n * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const unzip = self => {\n  const [left, right] = RA.unzip(self);\n  return [unsafeFromArray(left), unsafeFromArray(right)];\n};\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => unsafeFromArray(RA.zipWith(self, that, f)));\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Delete the element at the specified index, creating a new `Chunk`.\n *\n * @since 2.0.0\n */\nexport const remove = /*#__PURE__*/dual(2, (self, i) => {\n  if (i < 0 || i >= self.length) return self;\n  return unsafeFromArray(RA.remove(toReadonlyArray(self), i));\n});\n/**\n * @since 3.16.0\n */\nexport const removeOption = /*#__PURE__*/dual(2, (self, i) => {\n  if (i < 0 || i >= self.length) return O.none();\n  return O.some(unsafeFromArray(RA.remove(toReadonlyArray(self), i)));\n});\n/**\n * @since 2.0.0\n */\nexport const modifyOption = /*#__PURE__*/dual(3, (self, i, f) => {\n  if (i < 0 || i >= self.length) return O.none();\n  return O.some(unsafeFromArray(RA.modify(toReadonlyArray(self), i, f)));\n});\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modify = /*#__PURE__*/dual(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => self));\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @since 2.0.0\n */\nexport const replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy = /*#__PURE__*/dual(2, (n, f) => fromIterable(RA.makeBy(n, f)));\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);\n// -------------------------------------------------------------------------------------\n// re-exports from ReadonlyArray\n// -------------------------------------------------------------------------------------\n/**\n * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains = RA.contains;\n/**\n * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = RA.containsWith;\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = RA.findFirst;\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex = RA.findFirstIndex;\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast = RA.findLast;\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex = RA.findLastIndex;\n/**\n * Check if a predicate holds true for every `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => RA.fromIterable(self).every(refinement));\n/**\n * Check if a predicate holds true for some `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => RA.fromIterable(self).some(predicate));\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const join = RA.join;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce = RA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight = RA.reduceRight;\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const differenceWith = isEquivalent => {\n  return dual(2, (self, that) => unsafeFromArray(RA.differenceWith(isEquivalent)(that, self)));\n};\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk`.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const difference = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.difference(that, self)));\n//# sourceMappingURL=Chunk.js.map",
      "start": 1768772628414,
      "end": 1768772628414
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628414,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628419,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
