{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/TestClock.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Chunk from \"./Chunk.js\";\nimport * as Context from \"./Context.js\";\nimport * as DateTime from \"./DateTime.js\";\nimport * as Duration from \"./Duration.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as FiberStatus from \"./FiberStatus.js\";\nimport { constVoid, dual, identity, pipe } from \"./Function.js\";\nimport * as HashMap from \"./HashMap.js\";\nimport * as clock from \"./internal/clock.js\";\nimport * as effect from \"./internal/core-effect.js\";\nimport * as core from \"./internal/core.js\";\nimport * as defaultServices from \"./internal/defaultServices.js\";\nimport * as circular from \"./internal/effect/circular.js\";\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\";\nimport * as layer from \"./internal/layer.js\";\nimport * as ref from \"./internal/ref.js\";\nimport * as synchronized from \"./internal/synchronizedRef.js\";\nimport * as SuspendedWarningData from \"./internal/testing/suspendedWarningData.js\";\nimport * as WarningData from \"./internal/testing/warningData.js\";\nimport * as number from \"./Number.js\";\nimport * as Option from \"./Option.js\";\nimport * as Order from \"./Order.js\";\nimport * as Annotations from \"./TestAnnotations.js\";\nimport * as Live from \"./TestLive.js\";\n/**\n * @since 2.0.0\n */\nexport const makeData = (instant, sleeps) => ({\n  instant,\n  sleeps\n});\n/**\n * @since 2.0.0\n */\nexport const TestClock = /*#__PURE__*/Context.GenericTag(\"effect/TestClock\");\n/**\n * The warning message that will be displayed if a test is using time but is\n * not advancing the `TestClock`.\n *\n * @internal\n */\nconst warning = \"Warning: A test is using time, but is not advancing \" + \"the test clock, which may result in the test hanging. Use TestClock.adjust to \" + \"manually advance the time.\";\n/**\n * The warning message that will be displayed if a test is advancing the clock\n * but a fiber is still running.\n *\n * @internal\n */\nconst suspendedWarning = \"Warning: A test is advancing the test clock, \" + \"but a fiber is not suspending, which may result in the test hanging. Use \" + \"TestAspect.diagnose to identity the fiber that is not suspending.\";\n/** @internal */\nexport class TestClockImpl {\n  clockState;\n  live;\n  annotations;\n  warningState;\n  suspendedWarningState;\n  [clock.ClockTypeId] = clock.ClockTypeId;\n  constructor(clockState, live, annotations, warningState, suspendedWarningState) {\n    this.clockState = clockState;\n    this.live = live;\n    this.annotations = annotations;\n    this.warningState = warningState;\n    this.suspendedWarningState = suspendedWarningState;\n    this.currentTimeMillis = core.map(ref.get(this.clockState), data => data.instant);\n    this.currentTimeNanos = core.map(ref.get(this.clockState), data => BigInt(data.instant * 1000000));\n  }\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis() {\n    return ref.unsafeGet(this.clockState).instant;\n  }\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos() {\n    return BigInt(ref.unsafeGet(this.clockState).instant * 1000000);\n  }\n  /**\n   * Returns the current clock time in milliseconds.\n   */\n  currentTimeMillis;\n  /**\n   * Returns the current clock time in nanoseconds.\n   */\n  currentTimeNanos;\n  /**\n   * Saves the `TestClock`'s current state in an effect which, when run, will\n   * restore the `TestClock` state to the saved state.\n   */\n  get save() {\n    return core.map(ref.get(this.clockState), data => ref.set(this.clockState, data));\n  }\n  /**\n   * Sets the current clock time to the specified instant. Any effects that\n   * were scheduled to occur on or before the new time will be run in order.\n   */\n  setTime(instant) {\n    return core.zipRight(this.warningDone(), this.run(() => instant));\n  }\n  /**\n   * Semantically blocks the current fiber until the clock time is equal to or\n   * greater than the specified duration. Once the clock time is adjusted to\n   * on or after the duration, the fiber will automatically be resumed.\n   */\n  sleep(durationInput) {\n    const duration = Duration.decode(durationInput);\n    return core.flatMap(core.deferredMake(), deferred => pipe(ref.modify(this.clockState, data => {\n      const end = data.instant + Duration.toMillis(duration);\n      if (end > data.instant) {\n        return [true, makeData(data.instant, pipe(data.sleeps, Chunk.prepend([end, deferred])))];\n      }\n      return [false, data];\n    }), core.flatMap(shouldAwait => shouldAwait ? pipe(this.warningStart(), core.zipRight(core.deferredAwait(deferred))) : pipe(core.deferredSucceed(deferred, void 0), core.asVoid))));\n  }\n  /**\n   * Returns a list of the times at which all queued effects are scheduled to\n   * resume.\n   */\n  get sleeps() {\n    return core.map(ref.get(this.clockState), data => Chunk.map(data.sleeps, _ => _[0]));\n  }\n  /**\n   * Increments the current clock time by the specified duration. Any effects\n   * that were scheduled to occur on or before the new time will be run in\n   * order.\n   */\n  adjust(durationInput) {\n    const duration = Duration.decode(durationInput);\n    return core.zipRight(this.warningDone(), this.run(n => n + Duration.toMillis(duration)));\n  }\n  /**\n   * Increments the current clock time by the specified duration. Any effects\n   * that were scheduled to occur on or before the new time will be run in\n   * order.\n   */\n  adjustWith(durationInput) {\n    const duration = Duration.decode(durationInput);\n    return effect => fiberRuntime.zipLeftOptions(effect, this.adjust(duration), {\n      concurrent: true\n    });\n  }\n  /**\n   * Returns a set of all fibers in this test.\n   */\n  supervisedFibers() {\n    return this.annotations.supervisedFibers;\n  }\n  /**\n   * Captures a \"snapshot\" of the identifier and status of all fibers in this\n   * test other than the current fiber. Fails with the `void` value if any of\n   * these fibers are not done or suspended. Note that because we cannot\n   * synchronize on the status of multiple fibers at the same time this\n   * snapshot may not be fully consistent.\n   */\n  freeze() {\n    return core.flatMap(this.supervisedFibers(), fibers => pipe(fibers, effect.reduce(HashMap.empty(), (map, fiber) => pipe(fiber.status, core.flatMap(status => {\n      if (FiberStatus.isDone(status)) {\n        return core.succeed(HashMap.set(map, fiber.id(), status));\n      }\n      if (FiberStatus.isSuspended(status)) {\n        return core.succeed(HashMap.set(map, fiber.id(), status));\n      }\n      return core.fail(void 0);\n    })))));\n  }\n  /**\n   * Forks a fiber that will display a warning message if a test is using time\n   * but is not advancing the `TestClock`.\n   */\n  warningStart() {\n    return synchronized.updateSomeEffect(this.warningState, data => WarningData.isStart(data) ? Option.some(pipe(this.live.provide(pipe(effect.logWarning(warning), effect.delay(Duration.seconds(5)))), core.interruptible, fiberRuntime.fork, core.map(fiber => WarningData.pending(fiber)))) : Option.none());\n  }\n  /**\n   * Cancels the warning message that is displayed if a test is using time but\n   * is not advancing the `TestClock`.\n   */\n  warningDone() {\n    return synchronized.updateSomeEffect(this.warningState, warningData => {\n      if (WarningData.isStart(warningData)) {\n        return Option.some(core.succeed(WarningData.done));\n      }\n      if (WarningData.isPending(warningData)) {\n        return Option.some(pipe(core.interruptFiber(warningData.fiber), core.as(WarningData.done)));\n      }\n      return Option.none();\n    });\n  }\n  yieldTimer = /*#__PURE__*/core.async(resume => {\n    const timer = setTimeout(() => {\n      resume(core.void);\n    }, 0);\n    return core.sync(() => clearTimeout(timer));\n  });\n  /**\n   * Returns whether all descendants of this fiber are done or suspended.\n   */\n  suspended() {\n    return pipe(this.freeze(), core.zip(pipe(this.yieldTimer, core.zipRight(this.freeze()))), core.flatMap(([first, last]) => Equal.equals(first, last) ? core.succeed(first) : core.fail(void 0)));\n  }\n  /**\n   * Polls until all descendants of this fiber are done or suspended.\n   */\n  awaitSuspended() {\n    return pipe(this.suspendedWarningStart(), core.zipRight(pipe(this.suspended(), core.zipWith(pipe(this.yieldTimer, core.zipRight(this.suspended())), Equal.equals), effect.filterOrFail(identity, constVoid), effect.eventually)), core.zipRight(this.suspendedWarningDone()));\n  }\n  /**\n   * Forks a fiber that will display a warning message if a test is advancing\n   * the `TestClock` but a fiber is not suspending.\n   */\n  suspendedWarningStart() {\n    return synchronized.updateSomeEffect(this.suspendedWarningState, suspendedWarningData => {\n      if (SuspendedWarningData.isStart(suspendedWarningData)) {\n        return Option.some(pipe(this.live.provide(pipe(effect.logWarning(suspendedWarning), core.zipRight(ref.set(this.suspendedWarningState, SuspendedWarningData.done)), effect.delay(Duration.seconds(5)))), core.interruptible, fiberRuntime.fork, core.map(fiber => SuspendedWarningData.pending(fiber))));\n      }\n      return Option.none();\n    });\n  }\n  /**\n   * Cancels the warning message that is displayed if a test is advancing the\n   * `TestClock` but a fiber is not suspending.\n   */\n  suspendedWarningDone() {\n    return synchronized.updateSomeEffect(this.suspendedWarningState, suspendedWarningData => {\n      if (SuspendedWarningData.isPending(suspendedWarningData)) {\n        return Option.some(pipe(core.interruptFiber(suspendedWarningData.fiber), core.as(SuspendedWarningData.start)));\n      }\n      return Option.none();\n    });\n  }\n  /**\n   * Runs all effects scheduled to occur on or before the specified instant,\n   * which may depend on the current time, in order.\n   */\n  run(f) {\n    return pipe(this.awaitSuspended(), core.zipRight(pipe(ref.modify(this.clockState, data => {\n      const end = f(data.instant);\n      const sorted = pipe(data.sleeps, Chunk.sort(pipe(number.Order, Order.mapInput(_ => _[0]))));\n      if (Chunk.isNonEmpty(sorted)) {\n        const [instant, deferred] = Chunk.headNonEmpty(sorted);\n        if (instant <= end) {\n          return [Option.some([end, deferred]), makeData(instant, Chunk.tailNonEmpty(sorted))];\n        }\n      }\n      return [Option.none(), makeData(end, data.sleeps)];\n    }), core.flatMap(option => {\n      switch (option._tag) {\n        case \"None\":\n          {\n            return core.void;\n          }\n        case \"Some\":\n          {\n            const [end, deferred] = option.value;\n            return pipe(core.deferredSucceed(deferred, void 0), core.zipRight(core.yieldNow()), core.zipRight(this.run(() => end)));\n          }\n      }\n    }))));\n  }\n}\n/**\n * @since 2.0.0\n */\nexport const live = data => layer.scoped(TestClock, core.gen(function* () {\n  const live = yield* Live.TestLive;\n  const annotations = yield* Annotations.TestAnnotations;\n  const clockState = yield* core.sync(() => ref.unsafeMake(data));\n  const warningState = yield* circular.makeSynchronized(WarningData.start);\n  const suspendedWarningState = yield* circular.makeSynchronized(SuspendedWarningData.start);\n  const testClock = new TestClockImpl(clockState, live, annotations, warningState, suspendedWarningState);\n  yield* fiberRuntime.withClockScoped(testClock);\n  yield* fiberRuntime.addFinalizer(() => core.zipRight(testClock.warningDone(), testClock.suspendedWarningDone()));\n  return testClock;\n}));\n/**\n * @since 2.0.0\n */\nexport const defaultTestClock = /*#__PURE__*/live(/*#__PURE__*/makeData(/*#__PURE__*/new Date(0).getTime(), /*#__PURE__*/Chunk.empty()));\n/**\n * Accesses a `TestClock` instance in the context and increments the time\n * by the specified duration, running any actions scheduled for on or before\n * the new time in order.\n *\n * @since 2.0.0\n */\nexport const adjust = durationInput => {\n  const duration = Duration.decode(durationInput);\n  return testClockWith(testClock => testClock.adjust(duration));\n};\n/**\n * @since 2.0.0\n */\nexport const adjustWith = /*#__PURE__*/dual(2, (effect, durationInput) => {\n  const duration = Duration.decode(durationInput);\n  return testClockWith(testClock => testClock.adjustWith(duration)(effect));\n});\n/**\n * Accesses a `TestClock` instance in the context and saves the clock\n * state in an effect which, when run, will restore the `TestClock` to the\n * saved state.\n *\n * @since 2.0.0\n */\nexport const save = () => testClockWith(testClock => testClock.save);\n/**\n * Accesses a `TestClock` instance in the context and sets the clock time\n * to the specified `Instant` or `Date`, running any actions scheduled for on or before\n * the new time in order.\n *\n * @since 2.0.0\n */\nexport const setTime = input => testClockWith(testClock => testClock.setTime(typeof input === \"number\" ? input : DateTime.unsafeMake(input).epochMillis));\n/**\n * Semantically blocks the current fiber until the clock time is equal to or\n * greater than the specified duration. Once the clock time is adjusted to\n * on or after the duration, the fiber will automatically be resumed.\n *\n * @since 2.0.0\n */\nexport const sleep = durationInput => {\n  const duration = Duration.decode(durationInput);\n  return testClockWith(testClock => testClock.sleep(duration));\n};\n/**\n * Accesses a `TestClock` instance in the context and returns a list of\n * times that effects are scheduled to run.\n *\n * @since 2.0.0\n */\nexport const sleeps = () => testClockWith(testClock => testClock.sleeps);\n/**\n * Retrieves the `TestClock` service for this test.\n *\n * @since 2.0.0\n */\nexport const testClock = () => testClockWith(core.succeed);\n/**\n * Retrieves the `TestClock` service for this test and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n */\nexport const testClockWith = f => core.fiberRefGetWith(defaultServices.currentServices, services => f(pipe(services, Context.get(clock.clockTag))));\n/**\n * Accesses the current time of a `TestClock` instance in the context in\n * milliseconds.\n *\n * @since 2.0.0\n */\nexport const currentTimeMillis = /*#__PURE__*/testClockWith(testClock => testClock.currentTimeMillis);\n//# sourceMappingURL=TestClock.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628419,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
