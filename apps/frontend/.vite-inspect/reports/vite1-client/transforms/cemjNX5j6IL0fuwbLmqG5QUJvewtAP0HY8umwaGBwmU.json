{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/MsgPack.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as Channel from \"effect/Channel\";\nimport * as Chunk from \"effect/Chunk\";\nimport * as Data from \"effect/Data\";\nimport * as Effect from \"effect/Effect\";\nimport { dual } from \"effect/Function\";\nimport * as ParseResult from \"effect/ParseResult\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as Schema from \"effect/Schema\";\nimport { Packr, Unpackr } from \"msgpackr\";\nimport * as Msgpackr from \"msgpackr\";\nimport * as ChannelSchema from \"./ChannelSchema.js\";\n/**\n * @since 1.0.0\n * @category errors\n */\nexport const ErrorTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/MsgPack/MsgPackError\");\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class MsgPackError extends /*#__PURE__*/Data.TaggedError(\"MsgPackError\") {\n  /**\n   * @since 1.0.0\n   */\n  [ErrorTypeId] = ErrorTypeId;\n  /**\n   * @since 1.0.0\n   */\n  get message() {\n    return this.reason;\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const pack = () => Channel.suspend(() => {\n  const packr = new Packr();\n  const loop = Channel.readWithCause({\n    onInput: input => Channel.zipRight(Channel.flatMap(Effect.try({\n      try: () => Chunk.of(packr.pack(Chunk.toReadonlyArray(input))),\n      catch: cause => new MsgPackError({\n        reason: \"Pack\",\n        cause\n      })\n    }), Channel.write), loop),\n    onFailure: cause => Channel.failCause(cause),\n    onDone: Channel.succeed\n  });\n  return loop;\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const packSchema = schema => () => Channel.pipeTo(ChannelSchema.encode(schema)(), pack());\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unpack = () => Channel.flatMap(Channel.sync(() => new Unpackr()), packr => {\n  let incomplete = undefined;\n  const unpack = value => Effect.try({\n    try: () => Chunk.flatMap(value, buf => {\n      if (incomplete !== undefined) {\n        const chunk = new Uint8Array(incomplete.length + buf.length);\n        chunk.set(incomplete);\n        chunk.set(buf, incomplete.length);\n        buf = chunk;\n        incomplete = undefined;\n      }\n      try {\n        return Chunk.unsafeFromArray(packr.unpackMultiple(buf).flat());\n      } catch (error_) {\n        const error = error_;\n        if (error.incomplete) {\n          incomplete = buf.subarray(error.lastPosition);\n          return Chunk.unsafeFromArray(error.values ?? []);\n        }\n        throw error;\n      }\n    }),\n    catch: cause => new MsgPackError({\n      reason: \"Unpack\",\n      cause\n    })\n  });\n  const loop = Channel.readWithCause({\n    onInput: input => Channel.zipRight(Channel.flatMap(unpack(input), Channel.write), loop),\n    onFailure: cause => Channel.failCause(cause),\n    onDone: Channel.succeed\n  });\n  return loop;\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unpackSchema = schema => () => Channel.pipeTo(unpack(), ChannelSchema.decodeUnknown(schema)());\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplex = self => Channel.pipeTo(Channel.pipeTo(pack(), self), unpack());\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplexSchema = /*#__PURE__*/dual(2, (self, options) => ChannelSchema.duplexUnknown(duplex(self), options));\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schema = schema => Schema.transformOrFail(Schema.Uint8ArrayFromSelf, schema, {\n  decode(fromA, _, ast) {\n    return ParseResult.try({\n      try: () => Msgpackr.decode(fromA),\n      catch: cause => new ParseResult.Type(ast, fromA, Predicate.hasProperty(cause, \"message\") ? String(cause.message) : String(cause))\n    });\n  },\n  encode(toI, _, ast) {\n    return ParseResult.try({\n      try: () => Msgpackr.encode(toI),\n      catch: cause => new ParseResult.Type(ast, toI, Predicate.hasProperty(cause, \"message\") ? String(cause.message) : String(cause))\n    });\n  }\n});\n//# sourceMappingURL=MsgPack.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
