{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/trie.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Equal from \"../Equal.js\";\nimport { dual, identity, pipe } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nconst TrieSymbolKey = \"effect/Trie\";\n/** @internal */\nexport const TrieTypeId = /*#__PURE__*/Symbol.for(TrieSymbolKey);\nconst trieVariance = {\n  /* c8 ignore next */\n  _Value: _ => _\n};\nconst TrieProto = {\n  [TrieTypeId]: trieVariance,\n  [Symbol.iterator]() {\n    return new TrieIterator(this, (k, v) => [k, v], () => true);\n  },\n  [Hash.symbol]() {\n    let hash = Hash.hash(TrieSymbolKey);\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])));\n    }\n    return Hash.cached(this, hash);\n  },\n  [Equal.symbol](that) {\n    if (isTrie(that)) {\n      const entries = Array.from(that);\n      return Array.from(this).every((itemSelf, i) => {\n        const itemThat = entries[i];\n        return Equal.equals(itemSelf[0], itemThat[0]) && Equal.equals(itemSelf[1], itemThat[1]);\n      });\n    }\n    return false;\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Trie\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeImpl = root => {\n  const trie = Object.create(TrieProto);\n  trie._root = root;\n  trie._count = root?.count ?? 0;\n  return trie;\n};\nclass TrieIterator {\n  trie;\n  f;\n  filter;\n  stack = [];\n  constructor(trie, f, filter) {\n    this.trie = trie;\n    this.f = f;\n    this.filter = filter;\n    const root = trie._root !== undefined ? trie._root : undefined;\n    if (root !== undefined) {\n      this.stack.push([root, \"\", false]);\n    }\n  }\n  next() {\n    while (this.stack.length > 0) {\n      const [node, keyString, isAdded] = this.stack.pop();\n      if (isAdded) {\n        const value = node.value;\n        if (value !== undefined) {\n          const key = keyString + node.key;\n          if (this.filter(key, value)) {\n            return {\n              done: false,\n              value: this.f(key, value)\n            };\n          }\n        }\n      } else {\n        this.addToStack(node, keyString);\n      }\n    }\n    return {\n      done: true,\n      value: undefined\n    };\n  }\n  addToStack(node, keyString) {\n    if (node.right !== undefined) {\n      this.stack.push([node.right, keyString, false]);\n    }\n    if (node.mid !== undefined) {\n      this.stack.push([node.mid, keyString + node.key, false]);\n    }\n    this.stack.push([node, keyString, true]);\n    if (node.left !== undefined) {\n      this.stack.push([node.left, keyString, false]);\n    }\n  }\n  [Symbol.iterator]() {\n    return new TrieIterator(this.trie, this.f, this.filter);\n  }\n}\n/** @internal */\nexport const isTrie = u => hasProperty(u, TrieTypeId);\n/** @internal */\nexport const empty = () => makeImpl(undefined);\n/** @internal */\nexport const fromIterable = entries => {\n  let trie = empty();\n  for (const [key, value] of entries) {\n    trie = insert(trie, key, value);\n  }\n  return trie;\n};\n/** @internal */\nexport const make = (...entries) => {\n  return fromIterable(entries);\n};\n/** @internal */\nexport const insert = /*#__PURE__*/dual(3, (self, key, value) => {\n  if (key.length === 0) return self;\n  // -1:left | 0:mid | 1:right\n  const dStack = [];\n  const nStack = [];\n  let n = self._root ?? {\n    key: key[0],\n    count: 0\n  };\n  const count = n.count + 1;\n  let cIndex = 0;\n  while (cIndex < key.length) {\n    const c = key[cIndex];\n    nStack.push(n);\n    if (c > n.key) {\n      dStack.push(1);\n      if (n.right === undefined) {\n        n = {\n          key: c,\n          count\n        };\n      } else {\n        n = n.right;\n      }\n    } else if (c < n.key) {\n      dStack.push(-1);\n      if (n.left === undefined) {\n        n = {\n          key: c,\n          count\n        };\n      } else {\n        n = n.left;\n      }\n    } else {\n      if (cIndex === key.length - 1) {\n        n.value = value;\n      } else if (n.mid === undefined) {\n        dStack.push(0);\n        n = {\n          key: key[cIndex + 1],\n          count\n        };\n      } else {\n        dStack.push(0);\n        n = n.mid;\n      }\n      cIndex += 1;\n    }\n  }\n  // Rebuild path to leaf node (Path-copying immutability)\n  for (let s = nStack.length - 2; s >= 0; --s) {\n    const n2 = nStack[s];\n    const d = dStack[s];\n    if (d === -1) {\n      // left\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: nStack[s + 1],\n        mid: n2.mid,\n        right: n2.right\n      };\n    } else if (d === 1) {\n      // right\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: n2.mid,\n        right: nStack[s + 1]\n      };\n    } else {\n      // mid\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: nStack[s + 1],\n        right: n2.right\n      };\n    }\n  }\n  nStack[0].count = count;\n  return makeImpl(nStack[0]);\n});\n/** @internal */\nexport const size = self => self._root?.count ?? 0;\n/** @internal */\nexport const isEmpty = self => size(self) === 0;\n/** @internal */\nexport const keys = self => new TrieIterator(self, key => key, () => true);\n/** @internal */\nexport const values = self => new TrieIterator(self, (_, value) => value, () => true);\n/** @internal */\nexport const entries = self => new TrieIterator(self, (key, value) => [key, value], () => true);\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let accumulator = zero;\n  for (const entry of self) {\n    accumulator = f(accumulator, entry[1], entry[0]);\n  }\n  return accumulator;\n});\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => reduce(self, empty(), (trie, value, key) => insert(trie, key, f(value, key))));\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, f) => reduce(self, empty(), (trie, value, key) => f(value, key) ? insert(trie, key, value) : trie));\n/** @internal */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => reduce(self, empty(), (trie, value, key) => {\n  const option = f(value, key);\n  return Option.isSome(option) ? insert(trie, key, option.value) : trie;\n}));\n/** @internal */\nexport const compact = self => filterMap(self, identity);\n/** @internal */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => reduce(self, void 0, (_, value, key) => f(value, key)));\n/** @internal */\nexport const keysWithPrefix = /*#__PURE__*/dual(2, (self, prefix) => new TrieIterator(self, key => key, key => key.startsWith(prefix)));\n/** @internal */\nexport const valuesWithPrefix = /*#__PURE__*/dual(2, (self, prefix) => new TrieIterator(self, (_, value) => value, key => key.startsWith(prefix)));\n/** @internal */\nexport const entriesWithPrefix = /*#__PURE__*/dual(2, (self, prefix) => new TrieIterator(self, (key, value) => [key, value], key => key.startsWith(prefix)));\n/** @internal */\nexport const toEntriesWithPrefix = /*#__PURE__*/dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));\n/** @internal */\nexport const get = /*#__PURE__*/dual(2, (self, key) => {\n  let n = self._root;\n  if (n === undefined || key.length === 0) return Option.none();\n  let cIndex = 0;\n  while (cIndex < key.length) {\n    const c = key[cIndex];\n    if (c > n.key) {\n      if (n.right === undefined) {\n        return Option.none();\n      } else {\n        n = n.right;\n      }\n    } else if (c < n.key) {\n      if (n.left === undefined) {\n        return Option.none();\n      } else {\n        n = n.left;\n      }\n    } else {\n      if (cIndex === key.length - 1) {\n        return Option.fromNullable(n.value);\n      } else {\n        if (n.mid === undefined) {\n          return Option.none();\n        } else {\n          n = n.mid;\n          cIndex += 1;\n        }\n      }\n    }\n  }\n  return Option.none();\n});\n/** @internal */\nexport const has = /*#__PURE__*/dual(2, (self, key) => Option.isSome(get(self, key)));\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, key) => {\n  const element = get(self, key);\n  if (Option.isNone(element)) {\n    throw new Error(\"Expected trie to contain key\");\n  }\n  return element.value;\n});\n/** @internal */\nexport const remove = /*#__PURE__*/dual(2, (self, key) => {\n  let n = self._root;\n  if (n === undefined || key.length === 0) return self;\n  const count = n.count - 1;\n  // -1:left | 0:mid | 1:right\n  const dStack = [];\n  const nStack = [];\n  let cIndex = 0;\n  while (cIndex < key.length) {\n    const c = key[cIndex];\n    if (c > n.key) {\n      if (n.right === undefined) {\n        return self;\n      } else {\n        nStack.push(n);\n        dStack.push(1);\n        n = n.right;\n      }\n    } else if (c < n.key) {\n      if (n.left === undefined) {\n        return self;\n      } else {\n        nStack.push(n);\n        dStack.push(-1);\n        n = n.left;\n      }\n    } else {\n      if (cIndex === key.length - 1) {\n        if (n.value !== undefined) {\n          nStack.push(n);\n          dStack.push(0);\n          cIndex += 1;\n        } else {\n          return self;\n        }\n      } else {\n        if (n.mid === undefined) {\n          return self;\n        } else {\n          nStack.push(n);\n          dStack.push(0);\n          n = n.mid;\n          cIndex += 1;\n        }\n      }\n    }\n  }\n  const removeNode = nStack[nStack.length - 1];\n  nStack[nStack.length - 1] = {\n    key: removeNode.key,\n    count,\n    left: removeNode.left,\n    mid: removeNode.mid,\n    right: removeNode.right\n  };\n  // Rebuild path to leaf node (Path-copying immutability)\n  for (let s = nStack.length - 2; s >= 0; --s) {\n    const n2 = nStack[s];\n    const d = dStack[s];\n    const child = nStack[s + 1];\n    const nc = child.left === undefined && child.mid === undefined && child.right === undefined ? undefined : child;\n    if (d === -1) {\n      // left\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: nc,\n        mid: n2.mid,\n        right: n2.right\n      };\n    } else if (d === 1) {\n      // right\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: n2.mid,\n        right: nc\n      };\n    } else {\n      // mid\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: nc,\n        right: n2.right\n      };\n    }\n  }\n  nStack[0].count = count;\n  return makeImpl(nStack[0]);\n});\n/** @internal */\nexport const removeMany = /*#__PURE__*/dual(2, (self, keys) => {\n  let trie = self;\n  for (const key of keys) {\n    trie = remove(key)(trie);\n  }\n  return trie;\n});\n/** @internal */\nexport const insertMany = /*#__PURE__*/dual(2, (self, iter) => {\n  let trie = self;\n  for (const [key, value] of iter) {\n    trie = insert(key, value)(trie);\n  }\n  return trie;\n});\n/** @internal */\nexport const modify = /*#__PURE__*/dual(3, (self, key, f) => {\n  let n = self._root;\n  if (n === undefined || key.length === 0) return self;\n  // -1:left | 0:mid | 1:right\n  const dStack = [];\n  const nStack = [];\n  let cIndex = 0;\n  while (cIndex < key.length) {\n    const c = key[cIndex];\n    if (c > n.key) {\n      if (n.right === undefined) {\n        return self;\n      } else {\n        nStack.push(n);\n        dStack.push(1);\n        n = n.right;\n      }\n    } else if (c < n.key) {\n      if (n.left === undefined) {\n        return self;\n      } else {\n        nStack.push(n);\n        dStack.push(-1);\n        n = n.left;\n      }\n    } else {\n      if (cIndex === key.length - 1) {\n        if (n.value !== undefined) {\n          nStack.push(n);\n          dStack.push(0);\n          cIndex += 1;\n        } else {\n          return self;\n        }\n      } else {\n        if (n.mid === undefined) {\n          return self;\n        } else {\n          nStack.push(n);\n          dStack.push(0);\n          n = n.mid;\n          cIndex += 1;\n        }\n      }\n    }\n  }\n  const updateNode = nStack[nStack.length - 1];\n  if (updateNode.value === undefined) {\n    return self;\n  }\n  nStack[nStack.length - 1] = {\n    key: updateNode.key,\n    count: updateNode.count,\n    value: f(updateNode.value),\n    // Update\n    left: updateNode.left,\n    mid: updateNode.mid,\n    right: updateNode.right\n  };\n  // Rebuild path to leaf node (Path-copying immutability)\n  for (let s = nStack.length - 2; s >= 0; --s) {\n    const n2 = nStack[s];\n    const d = dStack[s];\n    const child = nStack[s + 1];\n    if (d === -1) {\n      // left\n      nStack[s] = {\n        key: n2.key,\n        count: n2.count,\n        value: n2.value,\n        left: child,\n        mid: n2.mid,\n        right: n2.right\n      };\n    } else if (d === 1) {\n      // right\n      nStack[s] = {\n        key: n2.key,\n        count: n2.count,\n        value: n2.value,\n        left: n2.left,\n        mid: n2.mid,\n        right: child\n      };\n    } else {\n      // mid\n      nStack[s] = {\n        key: n2.key,\n        count: n2.count,\n        value: n2.value,\n        left: n2.left,\n        mid: child,\n        right: n2.right\n      };\n    }\n  }\n  return makeImpl(nStack[0]);\n});\n/** @internal */\nexport const longestPrefixOf = /*#__PURE__*/dual(2, (self, key) => {\n  let n = self._root;\n  if (n === undefined || key.length === 0) return Option.none();\n  let longestPrefixNode = undefined;\n  let cIndex = 0;\n  while (cIndex < key.length) {\n    const c = key[cIndex];\n    if (n.value !== undefined) {\n      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];\n    }\n    if (c > n.key) {\n      if (n.right === undefined) {\n        break;\n      } else {\n        n = n.right;\n      }\n    } else if (c < n.key) {\n      if (n.left === undefined) {\n        break;\n      } else {\n        n = n.left;\n      }\n    } else {\n      if (n.mid === undefined) {\n        break;\n      } else {\n        n = n.mid;\n        cIndex += 1;\n      }\n    }\n  }\n  return Option.fromNullable(longestPrefixNode);\n});\n//# sourceMappingURL=trie.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
