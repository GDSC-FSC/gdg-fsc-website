{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stream/handoff.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Deferred from \"../../Deferred.js\";\nimport * as Effect from \"../../Effect.js\";\nimport { dual, pipe } from \"../../Function.js\";\nimport * as Option from \"../../Option.js\";\nimport * as Ref from \"../../Ref.js\";\n/** @internal */\nexport const HandoffTypeId = /*#__PURE__*/Symbol.for(\"effect/Stream/Handoff\");\n/** @internal */\nexport const OP_HANDOFF_STATE_EMPTY = \"Empty\";\n/** @internal */\nexport const OP_HANDOFF_STATE_FULL = \"Full\";\n/** @internal */\nconst handoffStateEmpty = notifyConsumer => ({\n  _tag: OP_HANDOFF_STATE_EMPTY,\n  notifyConsumer\n});\n/** @internal */\nconst handoffStateFull = (value, notifyProducer) => ({\n  _tag: OP_HANDOFF_STATE_FULL,\n  value,\n  notifyProducer\n});\n/** @internal */\nconst handoffStateMatch = (onEmpty, onFull) => {\n  return self => {\n    switch (self._tag) {\n      case OP_HANDOFF_STATE_EMPTY:\n        {\n          return onEmpty(self.notifyConsumer);\n        }\n      case OP_HANDOFF_STATE_FULL:\n        {\n          return onFull(self.value, self.notifyProducer);\n        }\n    }\n  };\n};\nconst handoffVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport const make = () => pipe(Deferred.make(), Effect.flatMap(deferred => Ref.make(handoffStateEmpty(deferred))), Effect.map(ref => ({\n  [HandoffTypeId]: handoffVariance,\n  ref\n})));\n/** @internal */\nexport const offer = /*#__PURE__*/dual(2, (self, value) => {\n  return Effect.flatMap(Deferred.make(), deferred => Effect.flatten(Ref.modify(self.ref, state => pipe(state, handoffStateMatch(notifyConsumer => [Effect.zipRight(Deferred.succeed(notifyConsumer, void 0), Deferred.await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [Effect.flatMap(Deferred.await(notifyProducer), () => pipe(self, offer(value))), state])))));\n});\n/** @internal */\nexport const take = self => Effect.flatMap(Deferred.make(), deferred => Effect.flatten(Ref.modify(self.ref, state => pipe(state, handoffStateMatch(notifyConsumer => [Effect.flatMap(Deferred.await(notifyConsumer), () => take(self)), state], (value, notifyProducer) => [Effect.as(Deferred.succeed(notifyProducer, void 0), value), handoffStateEmpty(deferred)])))));\n/** @internal */\nexport const poll = self => Effect.flatMap(Deferred.make(), deferred => Effect.flatten(Ref.modify(self.ref, state => pipe(state, handoffStateMatch(() => [Effect.succeed(Option.none()), state], (value, notifyProducer) => [Effect.as(Deferred.succeed(notifyProducer, void 0), Option.some(value)), handoffStateEmpty(deferred)])))));\n//# sourceMappingURL=handoff.js.map",
      "start": 1768772628788,
      "end": 1768772628788
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628788,
      "end": 1768772628788,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628805,
      "end": 1768772628805,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628815,
      "end": 1768772628815,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628820,
      "end": 1768772628820,
      "order": "post-post"
    }
  ]
}
