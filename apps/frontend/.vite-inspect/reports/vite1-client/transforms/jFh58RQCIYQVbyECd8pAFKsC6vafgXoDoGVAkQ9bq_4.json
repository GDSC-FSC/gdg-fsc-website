{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stm/tArray.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Equal from \"../../Equal.js\";\nimport { dual, pipe } from \"../../Function.js\";\nimport * as Option from \"../../Option.js\";\nimport * as Order from \"../../Order.js\";\nimport * as core from \"./core.js\";\nimport * as stm from \"./stm.js\";\nimport * as tRef from \"./tRef.js\";\n/** @internal */\nconst TArraySymbolKey = \"effect/TArray\";\n/** @internal */\nexport const TArrayTypeId = /*#__PURE__*/Symbol.for(TArraySymbolKey);\nconst tArrayVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport class TArrayImpl {\n  chunk;\n  [TArrayTypeId] = tArrayVariance;\n  constructor(chunk) {\n    this.chunk = chunk;\n  }\n}\n/** @internal */\nexport const collectFirst = /*#__PURE__*/dual(2, (self, pf) => collectFirstSTM(self, a => pipe(pf(a), Option.map(core.succeed))));\n/** @internal */\nexport const collectFirstSTM = /*#__PURE__*/dual(2, (self, pf) => core.withSTMRuntime(runtime => {\n  let index = 0;\n  let result = Option.none();\n  while (Option.isNone(result) && index < self.chunk.length) {\n    const element = pipe(self.chunk[index], tRef.unsafeGet(runtime.journal));\n    const option = pf(element);\n    if (Option.isSome(option)) {\n      result = option;\n    }\n    index = index + 1;\n  }\n  return pipe(result, Option.match({\n    onNone: () => stm.succeedNone,\n    onSome: core.map(Option.some)\n  }));\n}));\n/** @internal */\nexport const contains = /*#__PURE__*/dual(2, (self, value) => some(self, a => Equal.equals(a)(value)));\n/** @internal */\nexport const count = /*#__PURE__*/dual(2, (self, predicate) => reduce(self, 0, (n, a) => predicate(a) ? n + 1 : n));\n/** @internal */\nexport const countSTM = /*#__PURE__*/dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => core.map(predicate(a), bool => bool ? n + 1 : n)));\n/** @internal */\nexport const empty = () => fromIterable([]);\n/** @internal */\nexport const every = /*#__PURE__*/dual(2, (self, predicate) => stm.negate(some(self, a => !predicate(a))));\n/** @internal */\nexport const everySTM = /*#__PURE__*/dual(2, (self, predicate) => core.map(countSTM(self, predicate), count => count === self.chunk.length));\n/** @internal */\nexport const findFirst = /*#__PURE__*/dual(2, (self, predicate) => collectFirst(self, a => predicate(a) ? Option.some(a) : Option.none()));\n/** @internal */\nexport const findFirstIndex = /*#__PURE__*/dual(2, (self, value) => findFirstIndexFrom(self, value, 0));\n/** @internal */\nexport const findFirstIndexFrom = /*#__PURE__*/dual(3, (self, value, from) => findFirstIndexWhereFrom(self, a => Equal.equals(a)(value), from));\n/** @internal */\nexport const findFirstIndexWhere = /*#__PURE__*/dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));\n/** @internal */\nexport const findFirstIndexWhereFrom = /*#__PURE__*/dual(3, (self, predicate, from) => {\n  if (from < 0) {\n    return stm.succeedNone;\n  }\n  return core.effect(journal => {\n    let index = from;\n    let found = false;\n    while (!found && index < self.chunk.length) {\n      const element = tRef.unsafeGet(self.chunk[index], journal);\n      found = predicate(element);\n      index = index + 1;\n    }\n    if (found) {\n      return Option.some(index - 1);\n    }\n    return Option.none();\n  });\n});\n/** @internal */\nexport const findFirstIndexWhereSTM = /*#__PURE__*/dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));\n/** @internal */\nexport const findFirstIndexWhereFromSTM = /*#__PURE__*/dual(3, (self, predicate, from) => {\n  const forIndex = index => index < self.chunk.length ? pipe(tRef.get(self.chunk[index]), core.flatMap(predicate), core.flatMap(bool => bool ? core.succeed(Option.some(index)) : forIndex(index + 1))) : stm.succeedNone;\n  return from < 0 ? stm.succeedNone : forIndex(from);\n});\n/** @internal */\nexport const findFirstSTM = /*#__PURE__*/dual(2, (self, predicate) => {\n  const init = [Option.none(), 0];\n  const cont = state => Option.isNone(state[0]) && state[1] < self.chunk.length - 1;\n  return core.map(stm.iterate(init, {\n    while: cont,\n    body: state => {\n      const index = state[1];\n      return pipe(tRef.get(self.chunk[index]), core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index + 1])));\n    }\n  }), state => state[0]);\n});\n/** @internal */\nexport const findLast = /*#__PURE__*/dual(2, (self, predicate) => core.effect(journal => {\n  let index = self.chunk.length - 1;\n  let result = Option.none();\n  while (Option.isNone(result) && index >= 0) {\n    const element = tRef.unsafeGet(self.chunk[index], journal);\n    if (predicate(element)) {\n      result = Option.some(element);\n    }\n    index = index - 1;\n  }\n  return result;\n}));\n/** @internal */\nexport const findLastIndex = /*#__PURE__*/dual(2, (self, value) => findLastIndexFrom(self, value, self.chunk.length - 1));\n/** @internal */\nexport const findLastIndexFrom = /*#__PURE__*/dual(3, (self, value, end) => {\n  if (end >= self.chunk.length) {\n    return stm.succeedNone;\n  }\n  return core.effect(journal => {\n    let index = end;\n    let found = false;\n    while (!found && index >= 0) {\n      const element = tRef.unsafeGet(self.chunk[index], journal);\n      found = Equal.equals(element)(value);\n      index = index - 1;\n    }\n    if (found) {\n      return Option.some(index + 1);\n    }\n    return Option.none();\n  });\n});\n/** @internal */\nexport const findLastSTM = /*#__PURE__*/dual(2, (self, predicate) => {\n  const init = [Option.none(), self.chunk.length - 1];\n  const cont = state => Option.isNone(state[0]) && state[1] >= 0;\n  return core.map(stm.iterate(init, {\n    while: cont,\n    body: state => {\n      const index = state[1];\n      return pipe(tRef.get(self.chunk[index]), core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index - 1])));\n    }\n  }), state => state[0]);\n});\n/** @internal */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));\n/** @internal */\nexport const fromIterable = iterable => core.map(stm.forEach(iterable, tRef.make), chunk => new TArrayImpl(chunk));\n/** @internal */\nexport const get = /*#__PURE__*/dual(2, (self, index) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\");\n  }\n  return tRef.get(self.chunk[index]);\n});\n/** @internal */\nexport const headOption = self => self.chunk.length === 0 ? core.succeed(Option.none()) : core.map(tRef.get(self.chunk[0]), Option.some);\n/** @internal */\nexport const lastOption = self => self.chunk.length === 0 ? stm.succeedNone : core.map(tRef.get(self.chunk[self.chunk.length - 1]), Option.some);\n/** @internal */\nexport const make = (...elements) => fromIterable(elements);\n/** @internal */\nexport const maxOption = /*#__PURE__*/dual(2, (self, order) => {\n  const greaterThan = Order.greaterThan(order);\n  return reduceOption(self, (acc, curr) => greaterThan(acc)(curr) ? curr : acc);\n});\n/** @internal */\nexport const minOption = /*#__PURE__*/dual(2, (self, order) => {\n  const lessThan = Order.lessThan(order);\n  return reduceOption(self, (acc, curr) => lessThan(acc)(curr) ? curr : acc);\n});\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => core.effect(journal => {\n  let index = 0;\n  let result = zero;\n  while (index < self.chunk.length) {\n    const element = tRef.unsafeGet(self.chunk[index], journal);\n    result = f(result, element);\n    index = index + 1;\n  }\n  return result;\n}));\n/** @internal */\nexport const reduceOption = /*#__PURE__*/dual(2, (self, f) => core.effect(journal => {\n  let index = 0;\n  let result = undefined;\n  while (index < self.chunk.length) {\n    const element = tRef.unsafeGet(self.chunk[index], journal);\n    result = result === undefined ? element : f(result, element);\n    index = index + 1;\n  }\n  return Option.fromNullable(result);\n}));\n/** @internal */\nexport const reduceOptionSTM = /*#__PURE__*/dual(2, (self, f) => reduceSTM(self, Option.none(), (acc, curr) => Option.isSome(acc) ? core.map(f(acc.value, curr), Option.some) : stm.succeedSome(curr)));\n/** @internal */\nexport const reduceSTM = /*#__PURE__*/dual(3, (self, zero, f) => core.flatMap(toArray(self), stm.reduce(zero, f)));\n/** @internal */\nexport const size = self => self.chunk.length;\n/** @internal */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => core.map(findFirst(self, predicate), Option.isSome));\n/** @internal */\nexport const someSTM = /*#__PURE__*/dual(2, (self, predicate) => core.map(countSTM(self, predicate), n => n > 0));\n/** @internal */\nexport const toArray = self => stm.forEach(self.chunk, tRef.get);\n/** @internal */\nexport const transform = /*#__PURE__*/dual(2, (self, f) => core.effect(journal => {\n  let index = 0;\n  while (index < self.chunk.length) {\n    const ref = self.chunk[index];\n    tRef.unsafeSet(ref, f(tRef.unsafeGet(ref, journal)), journal);\n    index = index + 1;\n  }\n  return void 0;\n}));\n/** @internal */\nexport const transformSTM = /*#__PURE__*/dual(2, (self, f) => core.flatMap(stm.forEach(self.chunk, ref => core.flatMap(tRef.get(ref), f)), chunk => core.effect(journal => {\n  const iterator = chunk[Symbol.iterator]();\n  let index = 0;\n  let next;\n  while ((next = iterator.next()) && !next.done) {\n    tRef.unsafeSet(self.chunk[index], next.value, journal);\n    index = index + 1;\n  }\n  return void 0;\n})));\n/** @internal */\nexport const update = /*#__PURE__*/dual(3, (self, index, f) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\");\n  }\n  return tRef.update(self.chunk[index], f);\n});\n/** @internal */\nexport const updateSTM = /*#__PURE__*/dual(3, (self, index, f) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\");\n  }\n  return pipe(tRef.get(self.chunk[index]), core.flatMap(f), core.flatMap(updated => tRef.set(self.chunk[index], updated)));\n});\n//# sourceMappingURL=tArray.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
