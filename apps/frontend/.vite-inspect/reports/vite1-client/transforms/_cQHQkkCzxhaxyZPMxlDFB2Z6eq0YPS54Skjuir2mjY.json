{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/FiberHandle.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"./Cause.js\";\nimport * as Deferred from \"./Deferred.js\";\nimport * as Effect from \"./Effect.js\";\nimport * as Exit from \"./Exit.js\";\nimport * as Fiber from \"./Fiber.js\";\nimport * as FiberId from \"./FiberId.js\";\nimport { constFalse, dual } from \"./Function.js\";\nimport * as HashSet from \"./HashSet.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport * as Predicate from \"./Predicate.js\";\nimport * as Runtime from \"./Runtime.js\";\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/FiberHandle\");\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberHandle = u => Predicate.hasProperty(u, TypeId);\nconst Proto = {\n  [TypeId]: TypeId,\n  toString() {\n    return Inspectable.format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"FiberHandle\",\n      state: this.state\n    };\n  },\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst unsafeMake = deferred => {\n  const self = Object.create(Proto);\n  self.state = {\n    _tag: \"Open\",\n    fiber: undefined\n  };\n  self.deferred = deferred;\n  return self;\n};\n/**\n * A FiberHandle can be used to store a single fiber.\n * When the associated Scope is closed, the contained fiber will be interrupted.\n *\n * You can add a fiber to the handle using `FiberHandle.run`, and the fiber will\n * be automatically removed from the FiberHandle when it completes.\n *\n * @example\n * ```ts\n * import { Effect, FiberHandle } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const handle = yield* FiberHandle.make()\n *\n *   // run some effects\n *   yield* FiberHandle.run(handle, Effect.never)\n *   // this will interrupt the previous fiber\n *   yield* FiberHandle.run(handle, Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fiber will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(deferred)), handle => Effect.withFiberRuntime(parent => {\n  const state = handle.state;\n  if (state._tag === \"Closed\") return Effect.void;\n  handle.state = {\n    _tag: \"Closed\"\n  };\n  return state.fiber ? Effect.intoDeferred(Effect.asVoid(Fiber.interruptAs(state.fiber, FiberId.combine(parent.id(), internalFiberId))), handle.deferred) : Deferred.done(handle.deferred, Exit.void);\n}));\n/**\n * Create an Effect run function that is backed by a FiberHandle.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = () => Effect.flatMap(make(), self => runtime(self)());\n/**\n * Create an Effect run function that is backed by a FiberHandle.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = () => Effect.flatMap(make(), self => runtimePromise(self)());\nconst internalFiberIdId = -1;\nconst internalFiberId = /*#__PURE__*/FiberId.make(internalFiberIdId, 0);\nconst isInternalInterruption = /*#__PURE__*/Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n});\n/**\n * Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n * If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeSet = /*#__PURE__*/dual(args => isFiberHandle(args[0]), (self, fiber, options) => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n    return;\n  } else if (self.state.fiber !== undefined) {\n    if (options?.onlyIfMissing === true) {\n      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n      return;\n    } else if (self.state.fiber === fiber) {\n      return;\n    }\n    self.state.fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n    self.state.fiber = undefined;\n  }\n  self.state.fiber = fiber;\n  fiber.addObserver(exit => {\n    if (self.state._tag === \"Open\" && fiber === self.state.fiber) {\n      self.state.fiber = undefined;\n    }\n    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {\n      Deferred.unsafeDone(self.deferred, exit);\n    }\n  });\n});\n/**\n * Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n * If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const set = /*#__PURE__*/dual(args => isFiberHandle(args[0]), (self, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeSet(self, fiber, {\n  interruptAs: fiberId,\n  onlyIfMissing: options?.onlyIfMissing,\n  propagateInterruption: options?.propagateInterruption\n}))));\n/**\n * Retrieve the fiber from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeGet = self => self.state._tag === \"Closed\" ? Option.none() : Option.fromNullable(self.state.fiber);\n/**\n * Retrieve the fiber from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const get = self => Effect.suspend(() => unsafeGet(self));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = self => Effect.uninterruptibleMask(restore => Effect.withFiberRuntime(fiber => {\n  if (self.state._tag === \"Closed\" || self.state.fiber === undefined) {\n    return Effect.void;\n  }\n  return Effect.zipRight(restore(Fiber.interruptAs(self.state.fiber, FiberId.combine(fiber.id(), internalFiberId))), Effect.sync(() => {\n    if (self.state._tag === \"Open\") {\n      self.state.fiber = undefined;\n    }\n  }));\n}));\nconst constInterruptedFiber = /*#__PURE__*/function () {\n  let fiber = undefined;\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt);\n    }\n    return fiber;\n  };\n}();\n/**\n * Run an Effect and add the forked fiber to the FiberHandle.\n * When the fiber completes, it will be removed from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run = function () {\n  const self = arguments[0];\n  if (Effect.isEffect(arguments[1])) {\n    return runImpl(self, arguments[1], arguments[2]);\n  }\n  const options = arguments[1];\n  return effect => runImpl(self, effect, options);\n};\nconst runImpl = (self, effect, options) => Effect.withFiberRuntime(parent => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.interrupt;\n  } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {\n    return Effect.sync(constInterruptedFiber);\n  }\n  const runtime = Runtime.make({\n    context: parent.currentContext,\n    fiberRefs: parent.getFiberRefs(),\n    runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n  });\n  const fiber = Runtime.runFork(runtime)(effect);\n  unsafeSet(self, fiber, {\n    ...options,\n    interruptAs: parent.id()\n  });\n  return Effect.succeed(fiber);\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberHandle } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const handle = yield* FiberHandle.make()\n *   const run = yield* FiberHandle.runtime(handle)<Users>()\n *\n *   // run an effect and set the fiber in the handle\n *   run(Effect.andThen(Users, _ => _.getAll))\n *\n *   // this will interrupt the previous fiber\n *   run(Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fiber will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime = self => () => Effect.map(Effect.runtime(), runtime => {\n  const runFork = Runtime.runFork(runtime);\n  return (effect, options) => {\n    if (self.state._tag === \"Closed\") {\n      return constInterruptedFiber();\n    } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {\n      return constInterruptedFiber();\n    }\n    const fiber = runFork(effect, options);\n    unsafeSet(self, fiber, options);\n    return fiber;\n  };\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n *\n * The returned run function will return Promise's that will resolve when the\n * fiber completes.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = self => () => Effect.map(runtime(self)(), runFork => (effect, options) => new Promise((resolve, reject) => runFork(effect, options).addObserver(exit => {\n  if (Exit.isSuccess(exit)) {\n    resolve(exit.value);\n  } else {\n    reject(Cause.squash(exit.cause));\n  }\n})));\n/**\n * If any of the Fiber's in the handle terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberHandle } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const handle = yield* _(FiberHandle.make());\n *   yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberHandle.join(handle));\n * });\n * ```\n */\nexport const join = self => Deferred.await(self.deferred);\n/**\n * Wait for the fiber in the FiberHandle to complete.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = self => Effect.suspend(() => {\n  if (self.state._tag === \"Closed\" || self.state.fiber === undefined) {\n    return Effect.void;\n  }\n  return Fiber.await(self.state.fiber);\n});\n//# sourceMappingURL=FiberHandle.js.map",
      "start": 1768772628414,
      "end": 1768772628414
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628414,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
