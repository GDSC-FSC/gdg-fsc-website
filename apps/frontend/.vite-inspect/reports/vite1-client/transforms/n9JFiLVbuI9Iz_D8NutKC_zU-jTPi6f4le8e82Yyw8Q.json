{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/metric.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport * as Clock from \"../Clock.js\";\nimport * as Duration from \"../Duration.js\";\nimport { constVoid, dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Cause from \"./cause.js\";\nimport * as effect_ from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport * as metricBoundaries from \"./metric/boundaries.js\";\nimport * as metricKey from \"./metric/key.js\";\nimport * as metricKeyType from \"./metric/keyType.js\";\nimport * as metricLabel from \"./metric/label.js\";\nimport * as metricRegistry from \"./metric/registry.js\";\n/** @internal */\nconst MetricSymbolKey = \"effect/Metric\";\n/** @internal */\nexport const MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);\nconst metricVariance = {\n  /* c8 ignore next */\n  _Type: _ => _,\n  /* c8 ignore next */\n  _In: _ => _,\n  /* c8 ignore next */\n  _Out: _ => _\n};\n/** @internal */\nexport const globalMetricRegistry = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for(\"effect/Metric/globalMetricRegistry\"), () => metricRegistry.make());\n/** @internal */\nexport const make = function (keyType, unsafeUpdate, unsafeValue, unsafeModify) {\n  const metric = Object.assign(effect => core.tap(effect, a => update(metric, a)), {\n    [MetricTypeId]: metricVariance,\n    keyType,\n    unsafeUpdate,\n    unsafeValue,\n    unsafeModify,\n    register() {\n      this.unsafeValue([]);\n      return this;\n    },\n    pipe() {\n      return pipeArguments(this, arguments);\n    }\n  });\n  return metric;\n};\n/** @internal */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => make(self.keyType, (input, extraTags) => self.unsafeUpdate(f(input), extraTags), self.unsafeValue, (input, extraTags) => self.unsafeModify(f(input), extraTags)));\n/** @internal */\nexport const counter = (name, options) => fromMetricKey(metricKey.counter(name, options));\n/** @internal */\nexport const frequency = (name, options) => fromMetricKey(metricKey.frequency(name, options));\n/** @internal */\nexport const withConstantInput = /*#__PURE__*/dual(2, (self, input) => mapInput(self, () => input));\n/** @internal */\nexport const fromMetricKey = key => {\n  let untaggedHook;\n  const hookCache = new WeakMap();\n  const hook = extraTags => {\n    if (extraTags.length === 0) {\n      if (untaggedHook !== undefined) {\n        return untaggedHook;\n      }\n      untaggedHook = globalMetricRegistry.get(key);\n      return untaggedHook;\n    }\n    let hook = hookCache.get(extraTags);\n    if (hook !== undefined) {\n      return hook;\n    }\n    hook = globalMetricRegistry.get(metricKey.taggedWithLabels(key, extraTags));\n    hookCache.set(extraTags, hook);\n    return hook;\n  };\n  return make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));\n};\n/** @internal */\nexport const gauge = (name, options) => fromMetricKey(metricKey.gauge(name, options));\n/** @internal */\nexport const histogram = (name, boundaries, description) => fromMetricKey(metricKey.histogram(name, boundaries, description));\n/* @internal */\nexport const increment = self => metricKeyType.isCounterKey(self.keyType) ? update(self, self.keyType.bigint ? BigInt(1) : 1) : modify(self, self.keyType.bigint ? BigInt(1) : 1);\n/* @internal */\nexport const incrementBy = /*#__PURE__*/dual(2, (self, amount) => metricKeyType.isCounterKey(self.keyType) ? update(self, amount) : modify(self, amount));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => make(self.keyType, self.unsafeUpdate, extraTags => f(self.unsafeValue(extraTags)), self.unsafeModify));\n/** @internal */\nexport const mapType = /*#__PURE__*/dual(2, (self, f) => make(f(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));\n/** @internal */\nexport const modify = /*#__PURE__*/dual(2, (self, input) => core.fiberRefGetWith(core.currentMetricLabels, tags => core.sync(() => self.unsafeModify(input, tags))));\n/* @internal */\nexport const set = /*#__PURE__*/dual(2, (self, value) => update(self, value));\n/** @internal */\nexport const succeed = out => make(void 0, constVoid, () => out, constVoid);\n/** @internal */\nexport const sync = evaluate => make(void 0, constVoid, evaluate, constVoid);\n/** @internal */\nexport const summary = options => withNow(summaryTimestamp(options));\n/** @internal */\nexport const summaryTimestamp = options => fromMetricKey(metricKey.summary(options));\n/** @internal */\nexport const tagged = /*#__PURE__*/dual(3, (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]));\n/** @internal */\nexport const taggedWithLabelsInput = /*#__PURE__*/dual(2, (self, f) => map(make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, Arr.union(f(input), extraTags)), self.unsafeValue, (input, extraTags) => self.unsafeModify(input, Arr.union(f(input), extraTags))), constVoid));\n/** @internal */\nexport const taggedWithLabels = /*#__PURE__*/dual(2, (self, extraTags) => {\n  return make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, Arr.union(extraTags, extraTags1)), extraTags1 => self.unsafeValue(Arr.union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, Arr.union(extraTags, extraTags1)));\n});\n/** @internal */\nexport const timer = (name, description) => {\n  const boundaries = metricBoundaries.exponential({\n    start: 0.5,\n    factor: 2,\n    count: 35\n  });\n  const base = pipe(histogram(name, boundaries, description), tagged(\"time_unit\", \"milliseconds\"));\n  return mapInput(base, Duration.toMillis);\n};\n/** @internal */\nexport const timerWithBoundaries = (name, boundaries, description) => {\n  const base = pipe(histogram(name, metricBoundaries.fromIterable(boundaries), description), tagged(\"time_unit\", \"milliseconds\"));\n  return mapInput(base, Duration.toMillis);\n};\n/* @internal */\nexport const trackAll = /*#__PURE__*/dual(2, (self, input) => effect => core.matchCauseEffect(effect, {\n  onFailure: cause => core.zipRight(update(self, input), core.failCause(cause)),\n  onSuccess: value => core.zipRight(update(self, input), core.succeed(value))\n}));\n/* @internal */\nexport const trackDefect = /*#__PURE__*/dual(2, (self, metric) => trackDefectWith(self, metric, identity));\n/* @internal */\nexport const trackDefectWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = defect => update(metric, f(defect));\n  return effect_.tapDefect(self, cause => core.forEachSequentialDiscard(Cause.defects(cause), updater));\n});\n/* @internal */\nexport const trackDuration = /*#__PURE__*/dual(2, (self, metric) => trackDurationWith(self, metric, identity));\n/* @internal */\nexport const trackDurationWith = /*#__PURE__*/dual(3, (self, metric, f) => Clock.clockWith(clock => {\n  const startTime = clock.unsafeCurrentTimeNanos();\n  return core.tap(self, _ => {\n    const endTime = clock.unsafeCurrentTimeNanos();\n    const duration = Duration.nanos(endTime - startTime);\n    return update(metric, f(duration));\n  });\n}));\n/* @internal */\nexport const trackError = /*#__PURE__*/dual(2, (self, metric) => trackErrorWith(self, metric, a => a));\n/* @internal */\nexport const trackErrorWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = error => update(metric, f(error));\n  return effect_.tapError(self, updater);\n});\n/* @internal */\nexport const trackSuccess = /*#__PURE__*/dual(2, (self, metric) => trackSuccessWith(self, metric, a => a));\n/* @internal */\nexport const trackSuccessWith = /*#__PURE__*/dual(3, (self, metric, f) => {\n  const updater = value => update(metric, f(value));\n  return core.tap(self, updater);\n});\n/* @internal */\nexport const update = /*#__PURE__*/dual(2, (self, input) => core.fiberRefGetWith(core.currentMetricLabels, tags => core.sync(() => self.unsafeUpdate(input, tags))));\n/* @internal */\nexport const value = self => core.fiberRefGetWith(core.currentMetricLabels, tags => core.sync(() => self.unsafeValue(tags)));\n/** @internal */\nexport const withNow = self => mapInput(self, input => [input, Date.now()]);\n/** @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => make([self.keyType, that.keyType], (input, extraTags) => {\n  const [l, r] = input;\n  self.unsafeUpdate(l, extraTags);\n  that.unsafeUpdate(r, extraTags);\n}, extraTags => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)], (input, extraTags) => {\n  const [l, r] = input;\n  self.unsafeModify(l, extraTags);\n  that.unsafeModify(r, extraTags);\n}));\n/** @internal */\nexport const unsafeSnapshot = () => globalMetricRegistry.snapshot();\n/** @internal */\nexport const snapshot = /*#__PURE__*/core.sync(unsafeSnapshot);\n//# sourceMappingURL=metric.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
