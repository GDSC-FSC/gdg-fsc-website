{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/context.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Equal from \"../Equal.js\";\nimport { dual } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { EffectPrototype, effectVariance } from \"./effectable.js\";\nimport * as option from \"./option.js\";\n/** @internal */\nexport const TagTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Tag\");\n/** @internal */\nexport const ReferenceTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Reference\");\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n/** @internal */\nexport const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\n/** @internal */\nexport const TagProto = {\n  ...EffectPrototype,\n  _op: \"Tag\",\n  [STMTypeId]: effectVariance,\n  [TagTypeId]: {\n    _Service: _ => _,\n    _Identifier: _ => _\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Tag\",\n      key: this.key,\n      stack: this.stack\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  of(self) {\n    return self;\n  },\n  context(self) {\n    return make(this, self);\n  }\n};\nexport const ReferenceProto = {\n  ...TagProto,\n  [ReferenceTypeId]: ReferenceTypeId\n};\n/** @internal */\nexport const makeGenericTag = key => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  const tag = Object.create(TagProto);\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  tag.key = key;\n  return tag;\n};\n/** @internal */\nexport const Tag = id => () => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function TagClass() {}\n  Object.setPrototypeOf(TagClass, TagProto);\n  TagClass.key = id;\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return TagClass;\n};\n/** @internal */\nexport const Reference = () => (id, options) => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function ReferenceClass() {}\n  Object.setPrototypeOf(ReferenceClass, ReferenceProto);\n  ReferenceClass.key = id;\n  ReferenceClass.defaultValue = options.defaultValue;\n  Object.defineProperty(ReferenceClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return ReferenceClass;\n};\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Context\");\n/** @internal */\nexport const ContextProto = {\n  [TypeId]: {\n    _Services: _ => _\n  },\n  [Equal.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.number(this.unsafeMap.size));\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n/** @internal */\nexport const makeContext = unsafeMap => {\n  const context = Object.create(ContextProto);\n  context.unsafeMap = unsafeMap;\n  return context;\n};\nconst serviceNotFoundError = tag => {\n  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`);\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\");\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/);\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`;\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\");\n    lines.splice(1, 3);\n    error.stack = lines.join(\"\\n\");\n  }\n  return error;\n};\n/** @internal */\nexport const isContext = u => hasProperty(u, TypeId);\n/** @internal */\nexport const isTag = u => hasProperty(u, TagTypeId);\n/** @internal */\nexport const isReference = u => hasProperty(u, ReferenceTypeId);\nconst _empty = /*#__PURE__*/makeContext(/*#__PURE__*/new Map());\n/** @internal */\nexport const empty = () => _empty;\n/** @internal */\nexport const make = (tag, service) => makeContext(new Map([[tag.key, service]]));\n/** @internal */\nexport const add = /*#__PURE__*/dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag.key, service);\n  return makeContext(map);\n});\nconst defaultValueCache = /*#__PURE__*/globalValue(\"effect/Context/defaultValueCache\", () => new Map());\nconst getDefaultValue = tag => {\n  if (defaultValueCache.has(tag.key)) {\n    return defaultValueCache.get(tag.key);\n  }\n  const value = tag.defaultValue();\n  defaultValueCache.set(tag.key, value);\n  return value;\n};\n/** @internal */\nexport const unsafeGetReference = (self, tag) => {\n  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);\n};\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    if (ReferenceTypeId in tag) return getDefaultValue(tag);\n    throw serviceNotFoundError(tag);\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nexport const get = unsafeGet;\n/** @internal */\nexport const getOrElse = /*#__PURE__*/dual(3, (self, tag, orElse) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? getDefaultValue(tag) : orElse();\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nexport const getOption = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? option.some(getDefaultValue(tag)) : option.none;\n  }\n  return option.some(self.unsafeMap.get(tag.key));\n});\n/** @internal */\nexport const merge = /*#__PURE__*/dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n/** @internal */\nexport const mergeAll = (...ctxs) => {\n  const map = new Map();\n  for (let i = 0; i < ctxs.length; i++) {\n    ctxs[i].unsafeMap.forEach((value, key) => {\n      map.set(key, value);\n    });\n  }\n  return makeContext(map);\n};\n/** @internal */\nexport const pick = (...tags) => self => {\n  const tagSet = new Set(tags.map(_ => _.key));\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return makeContext(newEnv);\n};\n/** @internal */\nexport const omit = (...tags) => self => {\n  const newEnv = new Map(self.unsafeMap);\n  for (const tag of tags) {\n    newEnv.delete(tag.key);\n  }\n  return makeContext(newEnv);\n};\n//# sourceMappingURL=context.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
