{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { Stream } from '../../stream/Stream.js';\nimport { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nimport { depthBiasFromSizeForArbitrary } from './helpers/MaxLengthFromMinLength.js';\nimport { safePush } from '../../utils/globals.js';\nconst safePositiveInfinity = Number.POSITIVE_INFINITY;\nconst safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst safeNumberIsInteger = Number.isInteger;\nconst safeMathFloor = Math.floor;\nconst safeMathPow = Math.pow;\nconst safeMathMin = Math.min;\nexport class FrequencyArbitrary extends Arbitrary {\n    static from(warbs, constraints, label) {\n        if (warbs.length === 0) {\n            throw new Error(`${label} expects at least one weighted arbitrary`);\n        }\n        let totalWeight = 0;\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            const currentArbitrary = warbs[idx].arbitrary;\n            if (currentArbitrary === undefined) {\n                throw new Error(`${label} expects arbitraries to be specified`);\n            }\n            const currentWeight = warbs[idx].weight;\n            totalWeight += currentWeight;\n            if (!safeNumberIsInteger(currentWeight)) {\n                throw new Error(`${label} expects weights to be integer values`);\n            }\n            if (currentWeight < 0) {\n                throw new Error(`${label} expects weights to be superior or equal to 0`);\n            }\n        }\n        if (totalWeight <= 0) {\n            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n        }\n        const sanitizedConstraints = {\n            depthBias: depthBiasFromSizeForArbitrary(constraints.depthSize, constraints.maxDepth !== undefined),\n            maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : safePositiveInfinity,\n            withCrossShrink: !!constraints.withCrossShrink,\n        };\n        return new FrequencyArbitrary(warbs, sanitizedConstraints, getDepthContextFor(constraints.depthIdentifier));\n    }\n    constructor(warbs, constraints, context) {\n        super();\n        this.warbs = warbs;\n        this.constraints = constraints;\n        this.context = context;\n        let currentWeight = 0;\n        this.cumulatedWeights = [];\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            currentWeight += warbs[idx].weight;\n            safePush(this.cumulatedWeights, currentWeight);\n        }\n        this.totalWeight = currentWeight;\n    }\n    generate(mrng, biasFactor) {\n        if (this.mustGenerateFirst()) {\n            return this.safeGenerateForIndex(mrng, 0, biasFactor);\n        }\n        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n            if (selected < this.cumulatedWeights[idx]) {\n                return this.safeGenerateForIndex(mrng, idx, biasFactor);\n            }\n        }\n        throw new Error(`Unable to generate from fc.frequency`);\n    }\n    canShrinkWithoutContext(value) {\n        return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n    shrink(value, context) {\n        if (context !== undefined) {\n            const safeContext = context;\n            const selectedIndex = safeContext.selectedIndex;\n            const originalBias = safeContext.originalBias;\n            const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n            const originalShrinks = originalArbitrary\n                .shrink(value, safeContext.originalContext)\n                .map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));\n            if (safeContext.clonedMrngForFallbackFirst !== null) {\n                if (safeContext.cachedGeneratedForFirst === undefined) {\n                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n                }\n                const valueFromFirst = safeContext.cachedGeneratedForFirst;\n                return Stream.of(valueFromFirst).join(originalShrinks);\n            }\n            return originalShrinks;\n        }\n        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n        if (potentialSelectedIndex === -1) {\n            return Stream.nil();\n        }\n        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary\n            .shrink(value, undefined)\n            .map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));\n    }\n    defaultShrinkForFirst(selectedIndex) {\n        ++this.context.depth;\n        try {\n            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n                return Stream.nil();\n            }\n        }\n        finally {\n            --this.context.depth;\n        }\n        const rawShrinkValue = new Value(this.warbs[0].fallbackValue.default, undefined);\n        return Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));\n    }\n    canShrinkWithoutContextIndex(value) {\n        if (this.mustGenerateFirst()) {\n            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n        }\n        try {\n            ++this.context.depth;\n            for (let idx = 0; idx !== this.warbs.length; ++idx) {\n                const warb = this.warbs[idx];\n                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n        const context = {\n            selectedIndex: idx,\n            originalBias: biasFactor,\n            originalContext: value.context,\n            clonedMrngForFallbackFirst,\n        };\n        return new Value(value.value, context);\n    }\n    safeGenerateForIndex(mrng, idx, biasFactor) {\n        ++this.context.depth;\n        try {\n            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n            return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mustGenerateFirst() {\n        return this.constraints.maxDepth <= this.context.depth;\n    }\n    mustFallbackToFirstInShrink(idx) {\n        return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n    computeNegDepthBenefit() {\n        const depthBias = this.constraints.depthBias;\n        if (depthBias <= 0 || this.warbs[0].weight === 0) {\n            return 0;\n        }\n        const depthBenefit = safeMathFloor(safeMathPow(1 + depthBias, this.context.depth)) - 1;\n        return -safeMathMin(this.totalWeight * depthBenefit, safeMaxSafeInteger) || 0;\n    }\n}\n",
      "start": 1768772628893,
      "end": 1768772628893
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628893,
      "end": 1768772628894,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628895,
      "end": 1768772628896,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628896,
      "end": 1768772628897,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628899,
      "end": 1768772628899,
      "order": "post-post"
    }
  ]
}
