{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/queue.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Effectable from \"../Effectable.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport * as MutableQueue from \"../MutableQueue.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as core from \"./core.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\n/** @internal */\nconst EnqueueSymbolKey = \"effect/QueueEnqueue\";\n/** @internal */\nexport const EnqueueTypeId = /*#__PURE__*/Symbol.for(EnqueueSymbolKey);\n/** @internal */\nconst DequeueSymbolKey = \"effect/QueueDequeue\";\n/** @internal */\nexport const DequeueTypeId = /*#__PURE__*/Symbol.for(DequeueSymbolKey);\n/** @internal */\nconst QueueStrategySymbolKey = \"effect/QueueStrategy\";\n/** @internal */\nexport const QueueStrategyTypeId = /*#__PURE__*/Symbol.for(QueueStrategySymbolKey);\n/** @internal */\nconst BackingQueueSymbolKey = \"effect/BackingQueue\";\n/** @internal */\nexport const BackingQueueTypeId = /*#__PURE__*/Symbol.for(BackingQueueSymbolKey);\nconst queueStrategyVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\nconst backingQueueVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nexport const enqueueVariance = {\n  /* c8 ignore next */\n  _In: _ => _\n};\n/** @internal */\nexport const dequeueVariance = {\n  /* c8 ignore next */\n  _Out: _ => _\n};\n/** @internal */\nclass QueueImpl extends Effectable.Class {\n  queue;\n  takers;\n  shutdownHook;\n  shutdownFlag;\n  strategy;\n  [EnqueueTypeId] = enqueueVariance;\n  [DequeueTypeId] = dequeueVariance;\n  constructor(/** @internal */\n  queue, /** @internal */\n  takers, /** @internal */\n  shutdownHook, /** @internal */\n  shutdownFlag, /** @internal */\n  strategy) {\n    super();\n    this.queue = queue;\n    this.takers = takers;\n    this.shutdownHook = shutdownHook;\n    this.shutdownFlag = shutdownFlag;\n    this.strategy = strategy;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  commit() {\n    return this.take;\n  }\n  capacity() {\n    return this.queue.capacity();\n  }\n  get size() {\n    return core.suspend(() => core.catchAll(this.unsafeSize(), () => core.interrupt));\n  }\n  unsafeSize() {\n    if (MutableRef.get(this.shutdownFlag)) {\n      return Option.none();\n    }\n    return Option.some(this.queue.length() - MutableQueue.length(this.takers) + this.strategy.surplusSize());\n  }\n  get isEmpty() {\n    return core.map(this.size, size => size <= 0);\n  }\n  get isFull() {\n    return core.map(this.size, size => size >= this.capacity());\n  }\n  get shutdown() {\n    return core.uninterruptible(core.withFiberRuntime(state => {\n      pipe(this.shutdownFlag, MutableRef.set(true));\n      return pipe(fiberRuntime.forEachConcurrentDiscard(unsafePollAll(this.takers), d => core.deferredInterruptWith(d, state.id()), false, false), core.zipRight(this.strategy.shutdown), core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0)), core.asVoid);\n    }));\n  }\n  get isShutdown() {\n    return core.sync(() => MutableRef.get(this.shutdownFlag));\n  }\n  get awaitShutdown() {\n    return core.deferredAwait(this.shutdownHook);\n  }\n  isActive() {\n    return !MutableRef.get(this.shutdownFlag);\n  }\n  unsafeOffer(value) {\n    if (MutableRef.get(this.shutdownFlag)) {\n      return false;\n    }\n    let noRemaining;\n    if (this.queue.length() === 0) {\n      const taker = pipe(this.takers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));\n      if (taker !== MutableQueue.EmptyMutableQueue) {\n        unsafeCompleteDeferred(taker, value);\n        noRemaining = true;\n      } else {\n        noRemaining = false;\n      }\n    } else {\n      noRemaining = false;\n    }\n    if (noRemaining) {\n      return true;\n    }\n    // Not enough takers, offer to the queue\n    const succeeded = this.queue.offer(value);\n    unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n    return succeeded;\n  }\n  offer(value) {\n    return core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt;\n      }\n      let noRemaining;\n      if (this.queue.length() === 0) {\n        const taker = pipe(this.takers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));\n        if (taker !== MutableQueue.EmptyMutableQueue) {\n          unsafeCompleteDeferred(taker, value);\n          noRemaining = true;\n        } else {\n          noRemaining = false;\n        }\n      } else {\n        noRemaining = false;\n      }\n      if (noRemaining) {\n        return core.succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const succeeded = this.queue.offer(value);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return succeeded ? core.succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);\n    });\n  }\n  offerAll(iterable) {\n    return core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt;\n      }\n      const values = Arr.fromIterable(iterable);\n      const pTakers = this.queue.length() === 0 ? Arr.fromIterable(unsafePollN(this.takers, values.length)) : Arr.empty;\n      const [forTakers, remaining] = pipe(values, Arr.splitAt(pTakers.length));\n      for (let i = 0; i < pTakers.length; i++) {\n        const taker = pTakers[i];\n        const item = forTakers[i];\n        unsafeCompleteDeferred(taker, item);\n      }\n      if (remaining.length === 0) {\n        return core.succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const surplus = this.queue.offerAll(remaining);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return Chunk.isEmpty(surplus) ? core.succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);\n    });\n  }\n  get take() {\n    return core.withFiberRuntime(state => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt;\n      }\n      const item = this.queue.poll(MutableQueue.EmptyMutableQueue);\n      if (item !== MutableQueue.EmptyMutableQueue) {\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return core.succeed(item);\n      } else {\n        // Add the deferred to takers, then:\n        // - Try to take again in case a value was added since\n        // - Wait for the deferred to be completed\n        // - Clean up resources in case of interruption\n        const deferred = core.deferredUnsafeMake(state.id());\n        return pipe(core.suspend(() => {\n          pipe(this.takers, MutableQueue.offer(deferred));\n          unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n          return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.deferredAwait(deferred);\n        }), core.onInterrupt(() => {\n          return core.sync(() => unsafeRemove(this.takers, deferred));\n        }));\n      }\n    });\n  }\n  get takeAll() {\n    return core.suspend(() => {\n      return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {\n        const values = this.queue.pollUpTo(Number.POSITIVE_INFINITY);\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return Chunk.fromIterable(values);\n      });\n    });\n  }\n  takeUpTo(max) {\n    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {\n      const values = this.queue.pollUpTo(max);\n      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n      return Chunk.fromIterable(values);\n    }));\n  }\n  takeBetween(min, max) {\n    return core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty()));\n  }\n}\n/** @internal */\nconst takeRemainderLoop = (self, min, max, acc) => {\n  if (max < min) {\n    return core.succeed(acc);\n  }\n  return pipe(takeUpTo(self, max), core.flatMap(bs => {\n    const remaining = min - bs.length;\n    if (remaining === 1) {\n      return pipe(take(self), core.map(b => pipe(acc, Chunk.appendAll(bs), Chunk.append(b))));\n    }\n    if (remaining > 1) {\n      return pipe(take(self), core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, pipe(acc, Chunk.appendAll(bs), Chunk.append(b)))));\n    }\n    return core.succeed(pipe(acc, Chunk.appendAll(bs)));\n  }));\n};\n/** @internal */\nexport const isQueue = u => isEnqueue(u) && isDequeue(u);\n/** @internal */\nexport const isEnqueue = u => hasProperty(u, EnqueueTypeId);\n/** @internal */\nexport const isDequeue = u => hasProperty(u, DequeueTypeId);\n/** @internal */\nexport const bounded = requestedCapacity => pipe(core.sync(() => MutableQueue.bounded(requestedCapacity)), core.flatMap(queue => make(backingQueueFromMutableQueue(queue), backPressureStrategy())));\n/** @internal */\nexport const dropping = requestedCapacity => pipe(core.sync(() => MutableQueue.bounded(requestedCapacity)), core.flatMap(queue => make(backingQueueFromMutableQueue(queue), droppingStrategy())));\n/** @internal */\nexport const sliding = requestedCapacity => pipe(core.sync(() => MutableQueue.bounded(requestedCapacity)), core.flatMap(queue => make(backingQueueFromMutableQueue(queue), slidingStrategy())));\n/** @internal */\nexport const unbounded = () => pipe(core.sync(() => MutableQueue.unbounded()), core.flatMap(queue => make(backingQueueFromMutableQueue(queue), droppingStrategy())));\n/** @internal */\nconst unsafeMake = (queue, takers, shutdownHook, shutdownFlag, strategy) => {\n  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);\n};\n/** @internal */\nexport const make = (queue, strategy) => pipe(core.deferredMake(), core.map(deferred => unsafeMake(queue, MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy)));\n/** @internal */\nexport class BackingQueueFromMutableQueue {\n  mutable;\n  [BackingQueueTypeId] = backingQueueVariance;\n  constructor(mutable) {\n    this.mutable = mutable;\n  }\n  poll(def) {\n    return MutableQueue.poll(this.mutable, def);\n  }\n  pollUpTo(limit) {\n    return MutableQueue.pollUpTo(this.mutable, limit);\n  }\n  offerAll(elements) {\n    return MutableQueue.offerAll(this.mutable, elements);\n  }\n  offer(element) {\n    return MutableQueue.offer(this.mutable, element);\n  }\n  capacity() {\n    return MutableQueue.capacity(this.mutable);\n  }\n  length() {\n    return MutableQueue.length(this.mutable);\n  }\n}\n/** @internal */\nexport const backingQueueFromMutableQueue = mutable => new BackingQueueFromMutableQueue(mutable);\n/** @internal */\nexport const capacity = self => self.capacity();\n/** @internal */\nexport const size = self => self.size;\n/** @internal */\nexport const isFull = self => self.isFull;\n/** @internal */\nexport const isEmpty = self => self.isEmpty;\n/** @internal */\nexport const isShutdown = self => self.isShutdown;\n/** @internal */\nexport const awaitShutdown = self => self.awaitShutdown;\n/** @internal */\nexport const shutdown = self => self.shutdown;\n/** @internal */\nexport const offer = /*#__PURE__*/dual(2, (self, value) => self.offer(value));\n/** @internal */\nexport const unsafeOffer = /*#__PURE__*/dual(2, (self, value) => self.unsafeOffer(value));\n/** @internal */\nexport const offerAll = /*#__PURE__*/dual(2, (self, iterable) => self.offerAll(iterable));\n/** @internal */\nexport const poll = self => core.map(self.takeUpTo(1), Chunk.head);\n/** @internal */\nexport const take = self => self.take;\n/** @internal */\nexport const takeAll = self => self.takeAll;\n/** @internal */\nexport const takeUpTo = /*#__PURE__*/dual(2, (self, max) => self.takeUpTo(max));\n/** @internal */\nexport const takeBetween = /*#__PURE__*/dual(3, (self, min, max) => self.takeBetween(min, max));\n/** @internal */\nexport const takeN = /*#__PURE__*/dual(2, (self, n) => self.takeBetween(n, n));\n// -----------------------------------------------------------------------------\n// Strategy\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const backPressureStrategy = () => new BackPressureStrategy();\n/** @internal */\nexport const droppingStrategy = () => new DroppingStrategy();\n/** @internal */\nexport const slidingStrategy = () => new SlidingStrategy();\n/** @internal */\nclass BackPressureStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  putters = /*#__PURE__*/MutableQueue.unbounded();\n  surplusSize() {\n    return MutableQueue.length(this.putters);\n  }\n  onCompleteTakersWithEmptyQueue(takers) {\n    while (!MutableQueue.isEmpty(this.putters) && !MutableQueue.isEmpty(takers)) {\n      const taker = MutableQueue.poll(takers, void 0);\n      const putter = MutableQueue.poll(this.putters, void 0);\n      if (putter[2]) {\n        unsafeCompleteDeferred(putter[1], true);\n      }\n      unsafeCompleteDeferred(taker, putter[0]);\n    }\n  }\n  get shutdown() {\n    return pipe(core.fiberId, core.flatMap(fiberId => pipe(core.sync(() => unsafePollAll(this.putters)), core.flatMap(putters => fiberRuntime.forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(core.deferredInterruptWith(deferred, fiberId), core.asVoid) : core.void, false, false)))));\n  }\n  handleSurplus(iterable, queue, takers, isShutdown) {\n    return core.withFiberRuntime(state => {\n      const deferred = core.deferredUnsafeMake(state.id());\n      return pipe(core.suspend(() => {\n        this.unsafeOffer(iterable, deferred);\n        this.unsafeOnQueueEmptySpace(queue, takers);\n        unsafeCompleteTakers(this, queue, takers);\n        return MutableRef.get(isShutdown) ? core.interrupt : core.deferredAwait(deferred);\n      }), core.onInterrupt(() => core.sync(() => this.unsafeRemove(deferred))));\n    });\n  }\n  unsafeOnQueueEmptySpace(queue, takers) {\n    let keepPolling = true;\n    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {\n      const putter = pipe(this.putters, MutableQueue.poll(MutableQueue.EmptyMutableQueue));\n      if (putter === MutableQueue.EmptyMutableQueue) {\n        keepPolling = false;\n      } else {\n        const offered = queue.offer(putter[0]);\n        if (offered && putter[2]) {\n          unsafeCompleteDeferred(putter[1], true);\n        } else if (!offered) {\n          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), Chunk.prepend(putter)));\n        }\n        unsafeCompleteTakers(this, queue, takers);\n      }\n    }\n  }\n  unsafeOffer(iterable, deferred) {\n    const stuff = Arr.fromIterable(iterable);\n    for (let i = 0; i < stuff.length; i++) {\n      const value = stuff[i];\n      if (i === stuff.length - 1) {\n        pipe(this.putters, MutableQueue.offer([value, deferred, true]));\n      } else {\n        pipe(this.putters, MutableQueue.offer([value, deferred, false]));\n      }\n    }\n  }\n  unsafeRemove(deferred) {\n    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), Chunk.filter(([, _]) => _ !== deferred)));\n  }\n}\n/** @internal */\nclass DroppingStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  surplusSize() {\n    return 0;\n  }\n  get shutdown() {\n    return core.void;\n  }\n  onCompleteTakersWithEmptyQueue() {}\n  handleSurplus(_iterable, _queue, _takers, _isShutdown) {\n    return core.succeed(false);\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n}\n/** @internal */\nclass SlidingStrategy {\n  [QueueStrategyTypeId] = queueStrategyVariance;\n  surplusSize() {\n    return 0;\n  }\n  get shutdown() {\n    return core.void;\n  }\n  onCompleteTakersWithEmptyQueue() {}\n  handleSurplus(iterable, queue, takers, _isShutdown) {\n    return core.sync(() => {\n      this.unsafeOffer(queue, iterable);\n      unsafeCompleteTakers(this, queue, takers);\n      return true;\n    });\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n  unsafeOffer(queue, iterable) {\n    const iterator = iterable[Symbol.iterator]();\n    let next;\n    let offering = true;\n    while (!(next = iterator.next()).done && offering) {\n      if (queue.capacity() === 0) {\n        return;\n      }\n      // Poll 1 and retry\n      queue.poll(MutableQueue.EmptyMutableQueue);\n      offering = queue.offer(next.value);\n    }\n  }\n}\n/** @internal */\nconst unsafeCompleteDeferred = (deferred, a) => {\n  return core.deferredUnsafeDone(deferred, core.succeed(a));\n};\n/** @internal */\nconst unsafeOfferAll = (queue, as) => {\n  return pipe(queue, MutableQueue.offerAll(as));\n};\n/** @internal */\nconst unsafePollAll = queue => {\n  return pipe(queue, MutableQueue.pollUpTo(Number.POSITIVE_INFINITY));\n};\n/** @internal */\nconst unsafePollN = (queue, max) => {\n  return pipe(queue, MutableQueue.pollUpTo(max));\n};\n/** @internal */\nexport const unsafeRemove = (queue, a) => {\n  unsafeOfferAll(queue, pipe(unsafePollAll(queue), Chunk.filter(b => a !== b)));\n};\n/** @internal */\nexport const unsafeCompleteTakers = (strategy, queue, takers) => {\n  // Check both a taker and an item are in the queue, starting with the taker\n  let keepPolling = true;\n  while (keepPolling && queue.length() !== 0) {\n    const taker = pipe(takers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));\n    if (taker !== MutableQueue.EmptyMutableQueue) {\n      const element = queue.poll(MutableQueue.EmptyMutableQueue);\n      if (element !== MutableQueue.EmptyMutableQueue) {\n        unsafeCompleteDeferred(taker, element);\n        strategy.unsafeOnQueueEmptySpace(queue, takers);\n      } else {\n        unsafeOfferAll(takers, pipe(unsafePollAll(takers), Chunk.prepend(taker)));\n      }\n      keepPolling = true;\n    } else {\n      keepPolling = false;\n    }\n  }\n  if (keepPolling && queue.length() === 0 && !MutableQueue.isEmpty(takers)) {\n    strategy.onCompleteTakersWithEmptyQueue(takers);\n  }\n};\n//# sourceMappingURL=queue.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
