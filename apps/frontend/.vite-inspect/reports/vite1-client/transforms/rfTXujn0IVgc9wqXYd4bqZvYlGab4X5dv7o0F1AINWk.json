{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Metric.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as fiberRuntime from \"./internal/fiberRuntime.js\";\nimport * as internal from \"./internal/metric.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricTypeId = internal.MetricTypeId;\n/**\n * @since 2.0.0\n * @category globals\n */\nexport const globalMetricRegistry = internal.globalMetricRegistry;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of the specified new type, which must be transformable to the input type of\n * this metric.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput = internal.mapInput;\n/**\n * Represents a Counter metric that tracks cumulative numerical values over time.\n * Counters can be incremented and decremented and provide a running total of changes.\n *\n * **Options**\n *\n * - description - A description of the counter.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberCounter = Metric.counter(\"count\", {\n *   description: \"A number counter\"\n * });\n *\n * const bigintCounter = Metric.counter(\"count\", {\n *   description: \"A bigint counter\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const counter = internal.counter;\n/**\n * Creates a Frequency metric to count occurrences of events.\n * Frequency metrics are used to count the number of times specific events or incidents occur.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const errorFrequency = Metric.frequency(\"error_frequency\", {\n *    description: \"Counts the occurrences of errors.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency = internal.frequency;\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of any type, and translates them to updates with the specified constant\n * update value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const withConstantInput = internal.withConstantInput;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const fromMetricKey = internal.fromMetricKey;\n/**\n * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n *\n * **Options**\n *\n * - description - A description of the gauge metric.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberGauge = Metric.gauge(\"memory_usage\", {\n *   description: \"A gauge for memory usage\"\n * });\n *\n * const bigintGauge = Metric.gauge(\"cpu_load\", {\n *   description: \"A gauge for CPU load\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge = internal.gauge;\n/**\n * Represents a Histogram metric that records observations in specified value boundaries.\n * Histogram metrics are useful for measuring the distribution of values within a range.\n *\n * @example\n * ```ts\n * import { Metric, MetricBoundaries } from \"effect\"\n *\n * const latencyHistogram = Metric.histogram(\"latency_histogram\",\n *   MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n *   \"Measures the distribution of request latency.\"\n * );\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram = internal.histogram;\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const increment = internal.increment;\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const incrementBy = internal.incrementBy;\n/**\n * Returns a new metric that is powered by this one, but which outputs a new\n * state type, determined by transforming the state type of this metric by the\n * specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = internal.map;\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapType = internal.mapType;\n/**\n * Modifies the metric with the specified update message. For example, if the\n * metric were a gauge, the update would increment the method by the provided\n * amount.\n *\n * @since 3.6.5\n * @category utils\n */\nexport const modify = internal.modify;\n/**\n * @since 2.0.0\n * @category aspects\n */\nexport const set = internal.set;\n/**\n * Captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const snapshot = internal.snapshot;\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed = internal.succeed;\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync = internal.sync;\n/**\n * Creates a Summary metric that records observations and calculates quantiles.\n * Summary metrics provide statistical information about a set of values, including quantiles.\n *\n * **Options**\n *\n * - name - The name of the Summary metric.\n * - maxAge - The maximum age of observations to retain.\n * - maxSize - The maximum number of observations to keep.\n * - error - The error percentage when calculating quantiles.\n * - quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n * - description - An optional description of the Summary metric.\n *\n * @example\n * ```ts\n * import { Metric, Chunk } from \"effect\"\n *\n * const responseTimesSummary = Metric.summary({\n *   name: \"response_times_summary\",\n *   maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n *   maxSize: 1000, // Keep a maximum of 1000 observations.\n *   error: 0.01, // Allow a 1% error when calculating quantiles.\n *   quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n *   description: \"Measures the distribution of response times.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const summary = internal.summary;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summaryTimestamp // readonly because contravariant\n= internal.summaryTimestamp;\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const tagged = internal.tagged;\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * dynamic tags are added based on the update values. Note that the metric\n * returned by this method does not return any useful information, due to the\n * dynamic nature of the added tags.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabelsInput = internal.taggedWithLabelsInput;\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabels = internal.taggedWithLabels;\n/**\n * Creates a timer metric, based on a histogram, which keeps track of\n * durations in milliseconds. The unit of time will automatically be added to\n * the metric as a tag (i.e. `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timer = internal.timer;\n/**\n * Creates a timer metric, based on a histogram created from the provided\n * boundaries, which keeps track of durations in milliseconds. The unit of time\n * will automatically be added to the metric as a tag (i.e.\n * `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timerWithBoundaries = internal.timerWithBoundaries;\n/**\n * Returns an aspect that will update this metric with the specified constant\n * value every time the aspect is applied to an effect, regardless of whether\n * that effect fails or succeeds.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackAll = internal.trackAll;\n/**\n * Returns an aspect that will update this metric with the defects of the\n * effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefect = internal.trackDefect;\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the defect throwables of the effects that the\n * aspect is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefectWith = internal.trackDefectWith;\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, the input type of the metric\n * must be `Duration`.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDuration = internal.trackDuration;\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, you must supply a function\n * that can convert the `Duration` to the input type of this metric.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDurationWith = internal.trackDurationWith;\n/**\n * Returns an aspect that will update this metric with the failure value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackError = internal.trackError;\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the error value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackErrorWith = internal.trackErrorWith;\n/**\n * Returns an aspect that will update this metric with the success value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccess = internal.trackSuccess;\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the success value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccessWith = internal.trackSuccessWith;\n/**\n * Updates the metric with the specified update message. For example, if the\n * metric were a counter, the update would increment the method by the\n * provided amount.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const update = internal.update;\n/**\n * Retrieves a snapshot of the value of the metric at this moment in time.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const value = internal.value;\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const withNow = internal.withNow;\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zip = internal.zip;\n/**\n * Unsafely captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeSnapshot = internal.unsafeSnapshot;\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberStarted = fiberRuntime.fiberStarted;\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberSuccesses = fiberRuntime.fiberSuccesses;\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberFailures = fiberRuntime.fiberFailures;\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberLifetimes = fiberRuntime.fiberLifetimes;\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberActive = fiberRuntime.fiberActive;\n//# sourceMappingURL=Metric.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
