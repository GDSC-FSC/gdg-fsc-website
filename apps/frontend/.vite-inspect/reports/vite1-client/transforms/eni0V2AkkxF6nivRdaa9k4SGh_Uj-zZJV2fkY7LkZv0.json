{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/MutableQueue.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Chunk from \"./Chunk.js\";\nimport * as Dual from \"./Function.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as MutableList from \"./MutableList.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableQueue\");\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const EmptyMutableQueue = /*#__PURE__*/Symbol.for(\"effect/mutable/MutableQueue/Empty\");\nconst MutableQueueProto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    return Array.from(this.queue)[Symbol.iterator]();\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableQueue\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst make = capacity => {\n  const queue = Object.create(MutableQueueProto);\n  queue.queue = MutableList.empty();\n  queue.capacity = capacity;\n  return queue;\n};\n/**\n * Creates a new bounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const bounded = capacity => make(capacity);\n/**\n * Creates a new unbounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unbounded = () => make(undefined);\n/**\n * Returns the current number of elements in the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const length = self => MutableList.length(self.queue);\n/**\n * Returns `true` if the queue is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = self => MutableList.isEmpty(self.queue);\n/**\n * Returns `true` if the queue is full, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFull = self => self.capacity === undefined ? false : MutableList.length(self.queue) === self.capacity;\n/**\n * The **maximum** number of elements that a queue can hold.\n *\n * **Note**: unbounded queues can still implement this interface with\n * `capacity = Infinity`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const capacity = self => self.capacity === undefined ? Infinity : self.capacity;\n/**\n * Offers an element to the queue.\n *\n * Returns whether the enqueue was successful or not.\n *\n * @since 2.0.0\n */\nexport const offer = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const queueLength = MutableList.length(self.queue);\n  if (self.capacity !== undefined && queueLength === self.capacity) {\n    return false;\n  }\n  MutableList.append(value)(self.queue);\n  return true;\n});\n/**\n * Enqueues a collection of values into the queue.\n *\n * Returns a `Chunk` of the values that were **not** able to be enqueued.\n *\n * @since 2.0.0\n */\nexport const offerAll = /*#__PURE__*/Dual.dual(2, (self, values) => {\n  const iterator = values[Symbol.iterator]();\n  let next;\n  let remainder = Chunk.empty();\n  let offering = true;\n  while (offering && (next = iterator.next()) && !next.done) {\n    offering = offer(next.value)(self);\n  }\n  while (next != null && !next.done) {\n    remainder = Chunk.prepend(next.value)(remainder);\n    next = iterator.next();\n  }\n  return Chunk.reverse(remainder);\n});\n/**\n * Dequeues an element from the queue.\n *\n * Returns either an element from the queue, or the `def` param.\n *\n * **Note**: if there is no meaningful default for your type, you can always\n * use `poll(MutableQueue.EmptyMutableQueue)`.\n *\n * @since 2.0.0\n */\nexport const poll = /*#__PURE__*/Dual.dual(2, (self, def) => {\n  if (MutableList.isEmpty(self.queue)) {\n    return def;\n  }\n  return MutableList.shift(self.queue);\n});\n/**\n * Dequeues up to `n` elements from the queue.\n *\n * Returns a `List` of up to `n` elements.\n *\n * @since 2.0.0\n */\nexport const pollUpTo = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  let result = Chunk.empty();\n  let count = 0;\n  while (count < n) {\n    const element = poll(EmptyMutableQueue)(self);\n    if (element === EmptyMutableQueue) {\n      break;\n    }\n    result = Chunk.prepend(element)(result);\n    count += 1;\n  }\n  return Chunk.reverse(result);\n});\n//# sourceMappingURL=MutableQueue.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
