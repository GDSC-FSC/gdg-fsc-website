{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/groupBy.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"../Cause.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Deferred from \"../Deferred.js\";\nimport * as Effect from \"../Effect.js\";\nimport * as Effectable from \"../Effectable.js\";\nimport * as Exit from \"../Exit.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as Queue from \"../Queue.js\";\nimport * as Ref from \"../Ref.js\";\nimport * as Scope from \"../Scope.js\";\nimport * as channel from \"./channel.js\";\nimport * as channelExecutor from \"./channel/channelExecutor.js\";\nimport * as core from \"./core-stream.js\";\nimport * as stream from \"./stream.js\";\nimport * as take from \"./take.js\";\n/** @internal */\nconst GroupBySymbolKey = \"effect/GroupBy\";\n/** @internal */\nexport const GroupByTypeId = /*#__PURE__*/Symbol.for(GroupBySymbolKey);\nconst groupByVariance = {\n  /* c8 ignore next */\n  _R: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _K: _ => _,\n  /* c8 ignore next */\n  _V: _ => _\n};\n/** @internal */\nexport const isGroupBy = u => hasProperty(u, GroupByTypeId);\n/** @internal */\nexport const evaluate = /*#__PURE__*/dual(args => isGroupBy(args[0]), (self, f, options) => stream.flatMap(self.grouped, ([key, queue]) => f(key, stream.flattenTake(stream.fromQueue(queue, {\n  shutdown: true\n}))), {\n  concurrency: \"unbounded\",\n  bufferSize: options?.bufferSize ?? 16\n}));\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => make(pipe(self.grouped, stream.filterEffect(tuple => {\n  if (predicate(tuple[0])) {\n    return pipe(Effect.succeed(tuple), Effect.as(true));\n  }\n  return pipe(Queue.shutdown(tuple[1]), Effect.as(false));\n}))));\n/** @internal */\nexport const first = /*#__PURE__*/dual(2, (self, n) => make(pipe(stream.zipWithIndex(self.grouped), stream.filterEffect(tuple => {\n  const index = tuple[1];\n  const queue = tuple[0][1];\n  if (index < n) {\n    return pipe(Effect.succeed(tuple), Effect.as(true));\n  }\n  return pipe(Queue.shutdown(queue), Effect.as(false));\n}), stream.map(tuple => tuple[0]))));\n/** @internal */\nexport const make = grouped => ({\n  [GroupByTypeId]: groupByVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  grouped\n});\n// Circular with Stream\n/** @internal */\nexport const groupBy = /*#__PURE__*/dual(args => stream.isStream(args[0]), (self, f, options) => make(stream.unwrapScoped(Effect.gen(function* () {\n  const decider = yield* Deferred.make();\n  const output = yield* Effect.acquireRelease(Queue.bounded(options?.bufferSize ?? 16), queue => Queue.shutdown(queue));\n  const ref = yield* Ref.make(new Map());\n  const add = yield* pipe(stream.mapEffectSequential(self, f), stream.distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => Effect.flatMap(Deferred.await(decider), f => f(key, value)), exit => Queue.offer(output, exit)));\n  yield* Deferred.succeed(decider, (key, _) => pipe(Ref.get(ref), Effect.map(map => Option.fromNullable(map.get(key))), Effect.flatMap(Option.match({\n    onNone: () => Effect.flatMap(add, ([index, queue]) => Effect.zipRight(Ref.update(ref, map => map.set(key, index)), pipe(Queue.offer(output, Exit.succeed([key, mapDequeue(queue, exit => new take.TakeImpl(pipe(exit, Exit.map(tuple => Chunk.of(tuple[1])))))])), Effect.as(n => n === index)))),\n    onSome: index => Effect.succeed(n => n === index)\n  }))));\n  return stream.flattenExitOption(stream.fromQueue(output, {\n    shutdown: true\n  }));\n}))));\n/** @internal */\nexport const mapEffectOptions = /*#__PURE__*/dual(args => typeof args[0] !== \"function\", (self, f, options) => {\n  if (options?.key) {\n    return evaluate(groupByKey(self, options.key, {\n      bufferSize: options.bufferSize\n    }), (_, s) => stream.mapEffectSequential(s, f));\n  }\n  return stream.matchConcurrency(options?.concurrency, () => stream.mapEffectSequential(self, f), n => options?.unordered ? stream.flatMap(self, a => stream.fromEffect(f(a)), {\n    concurrency: n\n  }) : stream.mapEffectPar(self, n, f));\n});\n/** @internal */\nexport const bindEffect = /*#__PURE__*/dual(args => typeof args[0] !== \"string\", (self, tag, f, options) => mapEffectOptions(self, k => Effect.map(f(k), a => ({\n  ...k,\n  [tag]: a\n})), options));\nconst mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);\nclass MapDequeue extends Effectable.Class {\n  dequeue;\n  f;\n  [Queue.DequeueTypeId] = {\n    _Out: _ => _\n  };\n  constructor(dequeue, f) {\n    super();\n    this.dequeue = dequeue;\n    this.f = f;\n  }\n  capacity() {\n    return Queue.capacity(this.dequeue);\n  }\n  get size() {\n    return Queue.size(this.dequeue);\n  }\n  unsafeSize() {\n    return this.dequeue.unsafeSize();\n  }\n  get awaitShutdown() {\n    return Queue.awaitShutdown(this.dequeue);\n  }\n  isActive() {\n    return this.dequeue.isActive();\n  }\n  get isShutdown() {\n    return Queue.isShutdown(this.dequeue);\n  }\n  get shutdown() {\n    return Queue.shutdown(this.dequeue);\n  }\n  get isFull() {\n    return Queue.isFull(this.dequeue);\n  }\n  get isEmpty() {\n    return Queue.isEmpty(this.dequeue);\n  }\n  get take() {\n    return pipe(Queue.take(this.dequeue), Effect.map(a => this.f(a)));\n  }\n  get takeAll() {\n    return pipe(Queue.takeAll(this.dequeue), Effect.map(Chunk.map(a => this.f(a))));\n  }\n  takeUpTo(max) {\n    return pipe(Queue.takeUpTo(this.dequeue, max), Effect.map(Chunk.map(a => this.f(a))));\n  }\n  takeBetween(min, max) {\n    return pipe(Queue.takeBetween(this.dequeue, min, max), Effect.map(Chunk.map(a => this.f(a))));\n  }\n  takeN(n) {\n    return pipe(Queue.takeN(this.dequeue, n), Effect.map(Chunk.map(a => this.f(a))));\n  }\n  poll() {\n    return pipe(Queue.poll(this.dequeue), Effect.map(Option.map(a => this.f(a))));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  commit() {\n    return this.take;\n  }\n}\n/** @internal */\nexport const groupByKey = /*#__PURE__*/dual(args => typeof args[0] !== \"function\", (self, f, options) => {\n  const loop = (map, outerQueue) => core.readWithCause({\n    onInput: input => core.flatMap(core.fromEffect(Effect.forEach(groupByIterable(input, f), ([key, values]) => {\n      const innerQueue = map.get(key);\n      if (innerQueue === undefined) {\n        return pipe(Queue.bounded(options?.bufferSize ?? 16), Effect.flatMap(innerQueue => pipe(Effect.sync(() => {\n          map.set(key, innerQueue);\n        }), Effect.zipRight(Queue.offer(outerQueue, take.of([key, innerQueue]))), Effect.zipRight(pipe(Queue.offer(innerQueue, take.chunk(values)), Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.void) : Option.none()))))));\n      }\n      return Effect.catchSomeCause(Queue.offer(innerQueue, take.chunk(values)), cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.void) : Option.none());\n    }, {\n      discard: true\n    })), () => loop(map, outerQueue)),\n    onFailure: cause => core.fromEffect(Queue.offer(outerQueue, take.failCause(cause))),\n    onDone: () => core.fromEffect(pipe(Effect.forEach(map.entries(), ([_, innerQueue]) => pipe(Queue.offer(innerQueue, take.end), Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.void) : Option.none())), {\n      discard: true\n    }), Effect.zipRight(Queue.offer(outerQueue, take.end))))\n  });\n  return make(stream.unwrapScopedWith(scope => Effect.gen(function* () {\n    const map = new Map();\n    const queue = yield* Queue.unbounded();\n    yield* Scope.addFinalizer(scope, Queue.shutdown(queue));\n    return yield* stream.toChannel(self).pipe(core.pipeTo(loop(map, queue)), channel.drain, channelExecutor.runIn(scope), Effect.forkIn(scope), Effect.as(stream.flattenTake(stream.fromQueue(queue, {\n      shutdown: true\n    }))));\n  })));\n});\n/**\n * A variant of `groupBy` that retains the insertion order of keys.\n *\n * @internal\n */\nconst groupByIterable = /*#__PURE__*/dual(2, (iterable, f) => {\n  const builder = [];\n  const iterator = iterable[Symbol.iterator]();\n  const map = new Map();\n  let next;\n  while ((next = iterator.next()) && !next.done) {\n    const value = next.value;\n    const key = f(value);\n    if (map.has(key)) {\n      const innerBuilder = map.get(key);\n      innerBuilder.push(value);\n    } else {\n      const innerBuilder = [value];\n      builder.push([key, innerBuilder]);\n      map.set(key, innerBuilder);\n    }\n  }\n  return Chunk.unsafeFromArray(builder.map(tuple => [tuple[0], Chunk.unsafeFromArray(tuple[1])]));\n});\n//# sourceMappingURL=groupBy.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
