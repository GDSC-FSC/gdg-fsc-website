{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/cause.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport { constFalse, constTrue, dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport { NodeInspectSymbol, stringifyCircular, toJSON } from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty, isFunction } from \"../Predicate.js\";\nimport { getBugErrorMessage } from \"./errors.js\";\nimport * as OpCodes from \"./opCodes/cause.js\";\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\";\n/** @internal */\nexport const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\nconst variance = {\n  /* c8 ignore next */\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol]() {\n    return pipe(Hash.hash(CauseSymbolKey), Hash.combine(Hash.hash(flattenCause(this))), Hash.cached(this));\n  },\n  [Equal.symbol](that) {\n    return isCause(that) && causeEquals(this, that);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toJSON() {\n    switch (this._tag) {\n      case \"Empty\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag\n        };\n      case \"Die\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          defect: toJSON(this.defect)\n        };\n      case \"Interrupt\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          fiberId: this.fiberId.toJSON()\n        };\n      case \"Fail\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          failure: toJSON(this.error)\n        };\n      case \"Sequential\":\n      case \"Parallel\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          left: toJSON(this.left),\n          right: toJSON(this.right)\n        };\n    }\n  },\n  toString() {\n    return pretty(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OpCodes.OP_EMPTY;\n  return o;\n})();\n/** @internal */\nexport const fail = error => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_FAIL;\n  o.error = error;\n  return o;\n};\n/** @internal */\nexport const die = defect => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_DIE;\n  o.defect = defect;\n  return o;\n};\n/** @internal */\nexport const interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n/** @internal */\nexport const parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n/** @internal */\nexport const sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const isCause = u => hasProperty(u, CauseTypeId);\n/** @internal */\nexport const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;\n/** @internal */\nexport const isFailType = self => self._tag === OpCodes.OP_FAIL;\n/** @internal */\nexport const isDieType = self => self._tag === OpCodes.OP_DIE;\n/** @internal */\nexport const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;\n/** @internal */\nexport const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;\n/** @internal */\nexport const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n/** @internal */\nexport const isEmpty = self => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          return Option.some(acc);\n        }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT:\n        {\n          return Option.some(false);\n        }\n      default:\n        {\n          return Option.none();\n        }\n    }\n  });\n};\n/** @internal */\nexport const isFailure = self => Option.isSome(failureOption(self));\n/** @internal */\nexport const isDie = self => Option.isSome(dieOption(self));\n/** @internal */\nexport const isInterrupted = self => Option.isSome(interruptOption(self));\n/** @internal */\nexport const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n/** @internal */\nexport const failures = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_FAIL ? Option.some(pipe(list, Chunk.prepend(cause.error))) : Option.none()));\n/** @internal */\nexport const defects = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_DIE ? Option.some(pipe(list, Chunk.prepend(cause.defect))) : Option.none()));\n/** @internal */\nexport const interruptors = self => reduce(self, HashSet.empty(), (set, cause) => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(pipe(set, HashSet.add(cause.fiberId))) : Option.none());\n/** @internal */\nexport const failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error) : Option.none());\n/** @internal */\nexport const failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return Either.right(self);\n      }\n    case \"Some\":\n      {\n        return Either.left(option.value);\n      }\n  }\n};\n/** @internal */\nexport const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());\n/** @internal */\nexport const flipCauseOption = self => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: Option.map(fail),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId) : Option.none());\n/** @internal */\nexport const keepDefects = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: () => Option.none(),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const keepDefectsAndElectFailures = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: failure => Option.some(die(failure)),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const linearize = self => match(self, {\n  onEmpty: HashSet.empty(),\n  onFail: error => HashSet.make(fail(error)),\n  onDie: defect => HashSet.make(die(defect)),\n  onInterrupt: fiberId => HashSet.make(interrupt(fiberId)),\n  onSequential: (leftSet, rightSet) => HashSet.flatMap(leftSet, leftCause => HashSet.map(rightSet, rightCause => sequential(leftCause, rightCause))),\n  onParallel: (leftSet, rightSet) => HashSet.flatMap(leftSet, leftCause => HashSet.map(rightSet, rightCause => parallel(leftCause, rightCause)))\n});\n/** @internal */\nexport const stripFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: () => empty,\n  onDie: die,\n  onInterrupt: interrupt,\n  onSequential: sequential,\n  onParallel: parallel\n});\n/** @internal */\nexport const electFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: die,\n  onDie: die,\n  onInterrupt: interrupt,\n  onSequential: sequential,\n  onParallel: parallel\n});\n/** @internal */\nexport const stripSomeDefects = /*#__PURE__*/dual(2, (self, pf) => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: error => Option.some(fail(error)),\n  onDie: defect => {\n    const option = pf(defect);\n    return Option.isSome(option) ? Option.none() : Option.some(die(defect));\n  },\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n}));\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, error) => map(self, () => error));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, e => fail(f(e))));\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onEmpty: empty,\n  onFail: error => f(error),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n}));\n/** @internal */\nexport const flatten = self => flatMap(self, identity);\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => isFunction(f) ? flatMap(self, f) : flatMap(self, () => f));\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const contains = /*#__PURE__*/dual(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that));\n  });\n});\n/** @internal */\nconst causeEquals = (left, right) => {\n  let leftStack = Chunk.of(left);\n  let rightStack = Chunk.of(right);\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(Chunk.headNonEmpty(leftStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    const [rightParallel, rightSequential] = pipe(Chunk.headNonEmpty(rightStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());\n};\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(causes, Arr.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))];\n    }));\n    const updated = HashSet.size(parallel) > 0 ? pipe(flattened, Chunk.prepend(parallel)) : flattened;\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(getBugErrorMessage(\"Cause.flattenCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const find = /*#__PURE__*/dual(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OpCodes.OP_SEQUENTIAL:\n            case OpCodes.OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return Option.none();\n});\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = HashSet.empty();\n  let _sequential = Chunk.empty();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OpCodes.OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OpCodes.OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            default:\n              {\n                _sequential = Chunk.prepend(_sequential, cause.right);\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(getBugErrorMessage(\"Cause.evaluateCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\n/** @internal */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onDie,\n  onEmpty,\n  onFail,\n  onInterrupt,\n  onParallel,\n  onSequential\n}) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  });\n});\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = Option.isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          output.push(Either.right(reducer.emptyCase(context)));\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          output.push(Either.right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          output.push(Either.right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  return accumulator.pop();\n});\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const pretty = (cause, options) => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\";\n  }\n  return prettyErrors(cause).map(function (e) {\n    if (options?.renderErrorCause !== true || e.cause === undefined) {\n      return e.stack;\n    }\n    return `${e.stack} {\\n${renderErrorCause(e.cause, \"  \")}\\n}`;\n  }).join(\"\\n\");\n};\nconst renderErrorCause = (cause, prefix) => {\n  const lines = cause.stack.split(\"\\n\");\n  let stack = `${prefix}[cause]: ${lines[0]}`;\n  for (let i = 1, len = lines.length; i < len; i++) {\n    stack += `\\n${prefix}${lines[i]}`;\n  }\n  if (cause.cause) {\n    stack += ` {\\n${renderErrorCause(cause.cause, `${prefix}  `)}\\n${prefix}}`;\n  }\n  return stack;\n};\n/** @internal */\nexport class PrettyError extends globalThis.Error {\n  span = undefined;\n  constructor(originalError) {\n    const originalErrorIsObject = typeof originalError === \"object\" && originalError !== null;\n    const prevLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 1;\n    super(prettyErrorMessage(originalError), originalErrorIsObject && \"cause\" in originalError && typeof originalError.cause !== \"undefined\" ? {\n      cause: new PrettyError(originalError.cause)\n    } : undefined);\n    if (this.message === \"\") {\n      this.message = \"An error has occurred\";\n    }\n    Error.stackTraceLimit = prevLimit;\n    this.name = originalError instanceof Error ? originalError.name : \"Error\";\n    if (originalErrorIsObject) {\n      if (spanSymbol in originalError) {\n        this.span = originalError[spanSymbol];\n      }\n      Object.keys(originalError).forEach(key => {\n        if (!(key in this)) {\n          // @ts-expect-error\n          this[key] = originalError[key];\n        }\n      });\n    }\n    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : \"\", this.span);\n  }\n}\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message.\n * 2) If `u` is an Error instance with a message defined, it uses the message.\n * 3) If `u` has a user-defined `toString()` method, it uses that method.\n * 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nexport const prettyErrorMessage = u => {\n  // 1)\n  if (typeof u === \"string\") {\n    return u;\n  }\n  // 2)\n  if (typeof u === \"object\" && u !== null && u instanceof Error) {\n    return u.message;\n  }\n  // 3)\n  try {\n    if (hasProperty(u, \"toString\") && isFunction(u[\"toString\"]) && u[\"toString\"] !== Object.prototype.toString && u[\"toString\"] !== globalThis.Array.prototype.toString) {\n      return u[\"toString\"]();\n    }\n  } catch {\n    // something's off, rollback to json\n  }\n  // 4)\n  return stringifyCircular(u);\n};\nconst locationRegex = /\\((.*)\\)/g;\n/** @internal */\nexport const spanToTrace = /*#__PURE__*/globalValue(\"effect/Tracer/spanToTrace\", () => new WeakMap());\nconst prettyErrorStack = (message, stack, span) => {\n  const out = [message];\n  const lines = stack.startsWith(message) ? stack.slice(message.length).split(\"\\n\") : stack.split(\"\\n\");\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].includes(\" at new BaseEffectError\") || lines[i].includes(\" at new YieldableError\")) {\n      i++;\n      continue;\n    }\n    if (lines[i].includes(\"Generator.next\")) {\n      break;\n    }\n    if (lines[i].includes(\"effect_internal_function\")) {\n      break;\n    }\n    out.push(lines[i].replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\").replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\"));\n  }\n  if (span) {\n    let current = span;\n    let i = 0;\n    while (current && current._tag === \"Span\" && i < 10) {\n      const stackFn = spanToTrace.get(current);\n      if (typeof stackFn === \"function\") {\n        const stack = stackFn();\n        if (typeof stack === \"string\") {\n          const locationMatchAll = stack.matchAll(locationRegex);\n          let match = false;\n          for (const [, location] of locationMatchAll) {\n            match = true;\n            out.push(`    at ${current.name} (${location})`);\n          }\n          if (!match) {\n            out.push(`    at ${current.name} (${stack.replace(/^at /, \"\")})`);\n          }\n        } else {\n          out.push(`    at ${current.name}`);\n        }\n      } else {\n        out.push(`    at ${current.name}`);\n      }\n      current = Option.getOrUndefined(current.parent);\n      i++;\n    }\n  }\n  return out.join(\"\\n\");\n};\n/** @internal */\nexport const spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\n/** @internal */\nexport const prettyErrors = cause => reduceWithContext(cause, void 0, {\n  emptyCase: () => [],\n  dieCase: (_, unknownError) => {\n    return [new PrettyError(unknownError)];\n  },\n  failCase: (_, error) => {\n    return [new PrettyError(error)];\n  },\n  interruptCase: () => [],\n  parallelCase: (_, l, r) => [...l, ...r],\n  sequentialCase: (_, l, r) => [...l, ...r]\n});\n//# sourceMappingURL=cause.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628703,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
