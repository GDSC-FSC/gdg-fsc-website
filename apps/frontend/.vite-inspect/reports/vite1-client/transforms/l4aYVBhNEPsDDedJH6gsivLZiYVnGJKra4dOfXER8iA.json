{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/OpenApi.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Context from \"effect/Context\";\nimport { constFalse } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport * as Option from \"effect/Option\";\nimport * as HttpApi from \"./HttpApi.js\";\nimport * as HttpApiMiddleware from \"./HttpApiMiddleware.js\";\nimport * as HttpApiSchema from \"./HttpApiSchema.js\";\nimport * as HttpMethod from \"./HttpMethod.js\";\nimport * as JsonSchema from \"./OpenApiJsonSchema.js\";\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Identifier extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Identifier\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Title extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Title\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Version extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Version\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Description extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Description\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class License extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/License\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class ExternalDocs extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/ExternalDocs\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Servers extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Servers\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Format extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Format\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Summary extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Summary\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Deprecated extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Deprecated\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Override extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Override\")() {}\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Exclude extends /*#__PURE__*/Context.Reference()(\"@effect/platform/OpenApi/Exclude\", {\n  defaultValue: constFalse\n}) {}\n/**\n * Transforms the generated OpenAPI specification\n * @since 1.0.0\n * @category annotations\n */\nexport class Transform extends /*#__PURE__*/Context.Tag(\"@effect/platform/OpenApi/Transform\")() {}\nconst contextPartial = tags => {\n  const entries = Object.entries(tags);\n  return options => {\n    let context = Context.empty();\n    for (const [key, tag] of entries) {\n      if (options[key] !== undefined) {\n        context = Context.add(context, tag, options[key]);\n      }\n    }\n    return context;\n  };\n};\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const annotations = /*#__PURE__*/contextPartial({\n  identifier: Identifier,\n  title: Title,\n  version: Version,\n  description: Description,\n  license: License,\n  summary: Summary,\n  deprecated: Deprecated,\n  externalDocs: ExternalDocs,\n  servers: Servers,\n  format: Format,\n  override: Override,\n  exclude: Exclude,\n  transform: Transform\n});\nconst apiCache = /*#__PURE__*/globalValue(\"@effect/platform/OpenApi/apiCache\", () => new WeakMap());\n/**\n * This function checks if a given tag exists within the provided context. If\n * the tag is present, it retrieves the associated value and applies the given\n * callback function to it. If the tag is not found, the function does nothing.\n */\nfunction processAnnotation(ctx, tag, f) {\n  const o = Context.getOption(ctx, tag);\n  if (Option.isSome(o)) {\n    f(o.value);\n  }\n}\n/**\n * Converts an `HttpApi` instance into an OpenAPI Specification object.\n *\n * **Details**\n *\n * This function takes an `HttpApi` instance, which defines a structured API,\n * and generates an OpenAPI Specification (`OpenAPISpec`). The resulting spec\n * adheres to the OpenAPI 3.1.0 standard and includes detailed metadata such as\n * paths, operations, security schemes, and components. The function processes\n * the API's annotations, middleware, groups, and endpoints to build a complete\n * and accurate representation of the API in OpenAPI format.\n *\n * The function also deduplicates schemas, applies transformations, and\n * integrates annotations like descriptions, summaries, external documentation,\n * and overrides. Cached results are used for better performance when the same\n * `HttpApi` instance is processed multiple times.\n *\n * **Options**\n *\n * - `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n *   - `\"strict\"`: Disallow additional properties (default behavior).\n *   - `\"allow\"`: Allow additional properties.\n *\n * **Example**\n *\n * ```ts\n * import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from \"@effect/platform\"\n * import { Schema } from \"effect\"\n *\n * const api = HttpApi.make(\"api\").add(\n *   HttpApiGroup.make(\"group\").add(\n *     HttpApiEndpoint.get(\"get\", \"/items\")\n *       .addSuccess(Schema.Array(Schema.String))\n *   )\n * )\n *\n * const spec = OpenApi.fromApi(api)\n *\n * console.log(JSON.stringify(spec, null, 2))\n * // Output: OpenAPI specification in JSON format\n * ```\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const fromApi = (api, options) => {\n  const cached = apiCache.get(api);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const jsonSchemaDefs = {};\n  let spec = {\n    openapi: \"3.1.0\",\n    info: {\n      title: Context.getOrElse(api.annotations, Title, () => \"Api\"),\n      version: Context.getOrElse(api.annotations, Version, () => \"0.0.1\")\n    },\n    paths: {},\n    components: {\n      schemas: jsonSchemaDefs,\n      securitySchemes: {}\n    },\n    security: [],\n    tags: []\n  };\n  function processAST(ast) {\n    return JsonSchema.fromAST(ast, {\n      defs: jsonSchemaDefs,\n      additionalPropertiesStrategy: options?.additionalPropertiesStrategy\n    });\n  }\n  function processHttpApiSecurity(name, security) {\n    if (spec.components.securitySchemes[name] !== undefined) {\n      return;\n    }\n    spec.components.securitySchemes[name] = makeSecurityScheme(security);\n  }\n  processAnnotation(api.annotations, HttpApi.AdditionalSchemas, componentSchemas => {\n    componentSchemas.forEach(componentSchema => processAST(componentSchema.ast));\n  });\n  processAnnotation(api.annotations, Description, description => {\n    spec.info.description = description;\n  });\n  processAnnotation(api.annotations, License, license => {\n    spec.info.license = license;\n  });\n  processAnnotation(api.annotations, Summary, summary => {\n    spec.info.summary = summary;\n  });\n  processAnnotation(api.annotations, Servers, servers => {\n    spec.servers = [...servers];\n  });\n  api.middlewares.forEach(middleware => {\n    if (!HttpApiMiddleware.isSecurity(middleware)) {\n      return;\n    }\n    for (const [name, security] of Object.entries(middleware.security)) {\n      processHttpApiSecurity(name, security);\n      spec.security.push({\n        [name]: []\n      });\n    }\n  });\n  HttpApi.reflect(api, {\n    onGroup({\n      group\n    }) {\n      if (Context.get(group.annotations, Exclude)) {\n        return;\n      }\n      let tag = {\n        name: Context.getOrElse(group.annotations, Title, () => group.identifier)\n      };\n      processAnnotation(group.annotations, Description, description => {\n        tag.description = description;\n      });\n      processAnnotation(group.annotations, ExternalDocs, externalDocs => {\n        tag.externalDocs = externalDocs;\n      });\n      processAnnotation(group.annotations, Override, override => {\n        Object.assign(tag, override);\n      });\n      processAnnotation(group.annotations, Transform, transformFn => {\n        tag = transformFn(tag);\n      });\n      spec.tags.push(tag);\n    },\n    onEndpoint({\n      endpoint,\n      errors,\n      group,\n      mergedAnnotations,\n      middleware,\n      payloads,\n      successes\n    }) {\n      if (Context.get(mergedAnnotations, Exclude)) {\n        return;\n      }\n      let op = {\n        tags: [Context.getOrElse(group.annotations, Title, () => group.identifier)],\n        operationId: Context.getOrElse(endpoint.annotations, Identifier, () => group.topLevel ? endpoint.name : `${group.identifier}.${endpoint.name}`),\n        parameters: [],\n        security: [],\n        responses: {}\n      };\n      function processResponseMap(map, defaultDescription) {\n        for (const [status, {\n          ast,\n          description\n        }] of map) {\n          if (op.responses[status]) continue;\n          op.responses[status] = {\n            description: Option.getOrElse(description, defaultDescription)\n          };\n          ast.pipe(Option.filter(ast => !HttpApiSchema.getEmptyDecodeable(ast)), Option.map(ast => {\n            const encoding = HttpApiSchema.getEncoding(ast);\n            op.responses[status].content = {\n              [encoding.contentType]: {\n                schema: processAST(ast)\n              }\n            };\n          }));\n        }\n      }\n      function processParameters(schema, i) {\n        if (Option.isSome(schema)) {\n          const jsonSchema = processAST(schema.value.ast);\n          if (\"properties\" in jsonSchema) {\n            Object.entries(jsonSchema.properties).forEach(([name, psJsonSchema]) => {\n              op.parameters.push({\n                name,\n                in: i,\n                schema: psJsonSchema,\n                required: jsonSchema.required.includes(name),\n                ...(psJsonSchema.description !== undefined ? {\n                  description: psJsonSchema.description\n                } : undefined)\n              });\n            });\n          }\n        }\n      }\n      processAnnotation(endpoint.annotations, Description, description => {\n        op.description = description;\n      });\n      processAnnotation(endpoint.annotations, Summary, summary => {\n        op.summary = summary;\n      });\n      processAnnotation(endpoint.annotations, Deprecated, deprecated => {\n        op.deprecated = deprecated;\n      });\n      processAnnotation(endpoint.annotations, ExternalDocs, externalDocs => {\n        op.externalDocs = externalDocs;\n      });\n      middleware.forEach(middleware => {\n        if (!HttpApiMiddleware.isSecurity(middleware)) {\n          return;\n        }\n        for (const [name, security] of Object.entries(middleware.security)) {\n          processHttpApiSecurity(name, security);\n          op.security.push({\n            [name]: []\n          });\n        }\n      });\n      const hasBody = HttpMethod.hasBody(endpoint.method);\n      if (hasBody && payloads.size > 0) {\n        const content = {};\n        payloads.forEach(({\n          ast\n        }, contentType) => {\n          content[contentType] = {\n            schema: processAST(ast)\n          };\n        });\n        op.requestBody = {\n          content,\n          required: true\n        };\n      }\n      processParameters(endpoint.pathSchema, \"path\");\n      if (!hasBody) {\n        processParameters(endpoint.payloadSchema, \"query\");\n      }\n      processParameters(endpoint.headersSchema, \"header\");\n      processParameters(endpoint.urlParamsSchema, \"query\");\n      processResponseMap(successes, () => \"Success\");\n      processResponseMap(errors, () => \"Error\");\n      const path = endpoint.path.replace(/:(\\w+)\\??/g, \"{$1}\");\n      const method = endpoint.method.toLowerCase();\n      if (!spec.paths[path]) {\n        spec.paths[path] = {};\n      }\n      processAnnotation(endpoint.annotations, Override, override => {\n        Object.assign(op, override);\n      });\n      processAnnotation(endpoint.annotations, Transform, transformFn => {\n        op = transformFn(op);\n      });\n      spec.paths[path][method] = op;\n    }\n  });\n  processAnnotation(api.annotations, Override, override => {\n    Object.assign(spec, override);\n  });\n  processAnnotation(api.annotations, Transform, transformFn => {\n    spec = transformFn(spec);\n  });\n  apiCache.set(api, spec);\n  return spec;\n};\nconst makeSecurityScheme = security => {\n  const meta = {};\n  processAnnotation(security.annotations, Description, description => {\n    meta.description = description;\n  });\n  switch (security._tag) {\n    case \"Basic\":\n      {\n        return {\n          ...meta,\n          type: \"http\",\n          scheme: \"basic\"\n        };\n      }\n    case \"Bearer\":\n      {\n        const format = Context.getOption(security.annotations, Format).pipe(Option.map(format => ({\n          bearerFormat: format\n        })), Option.getOrUndefined);\n        return {\n          ...meta,\n          type: \"http\",\n          scheme: \"bearer\",\n          ...format\n        };\n      }\n    case \"ApiKey\":\n      {\n        return {\n          ...meta,\n          type: \"apiKey\",\n          name: security.key,\n          in: security.in\n        };\n      }\n  }\n};\n//# sourceMappingURL=OpenApi.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
