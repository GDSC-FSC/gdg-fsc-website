{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/mailbox.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Arr from \"../Array.js\";\nimport { NoSuchElementException } from \"../Cause.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Effectable from \"../Effectable.js\";\nimport { dual } from \"../Function.js\";\nimport * as Inspectable from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as channel from \"./channel.js\";\nimport * as channelExecutor from \"./channel/channelExecutor.js\";\nimport * as coreChannel from \"./core-stream.js\";\nimport * as core from \"./core.js\";\nimport * as circular from \"./effect/circular.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\nimport * as stream from \"./stream.js\";\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Mailbox\");\n/** @internal */\nexport const ReadonlyTypeId = /*#__PURE__*/Symbol.for(\"effect/Mailbox/ReadonlyMailbox\");\n/** @internal */\nexport const isMailbox = u => hasProperty(u, TypeId);\n/** @internal */\nexport const isReadonlyMailbox = u => hasProperty(u, ReadonlyTypeId);\nconst empty = /*#__PURE__*/Chunk.empty();\nconst exitEmpty = /*#__PURE__*/core.exitSucceed(empty);\nconst exitFalse = /*#__PURE__*/core.exitSucceed(false);\nconst exitTrue = /*#__PURE__*/core.exitSucceed(true);\nconst constDone = [empty, true];\nclass MailboxImpl extends Effectable.Class {\n  scheduler;\n  capacity;\n  strategy;\n  [TypeId] = TypeId;\n  [ReadonlyTypeId] = ReadonlyTypeId;\n  state = {\n    _tag: \"Open\",\n    takers: /*#__PURE__*/new Set(),\n    offers: /*#__PURE__*/new Set(),\n    awaiters: /*#__PURE__*/new Set()\n  };\n  messages = [];\n  messagesChunk = /*#__PURE__*/Chunk.empty();\n  constructor(scheduler, capacity, strategy) {\n    super();\n    this.scheduler = scheduler;\n    this.capacity = capacity;\n    this.strategy = strategy;\n  }\n  offer(message) {\n    return core.suspend(() => {\n      if (this.state._tag !== \"Open\") {\n        return exitFalse;\n      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {\n        switch (this.strategy) {\n          case \"dropping\":\n            return exitFalse;\n          case \"suspend\":\n            if (this.capacity <= 0 && this.state.takers.size > 0) {\n              this.messages.push(message);\n              this.releaseTaker();\n              return exitTrue;\n            }\n            return this.offerRemainingSingle(message);\n          case \"sliding\":\n            this.unsafeTake();\n            this.messages.push(message);\n            return exitTrue;\n        }\n      }\n      this.messages.push(message);\n      this.scheduleReleaseTaker();\n      return exitTrue;\n    });\n  }\n  unsafeOffer(message) {\n    if (this.state._tag !== \"Open\") {\n      return false;\n    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {\n      if (this.strategy === \"sliding\") {\n        this.unsafeTake();\n        this.messages.push(message);\n        return true;\n      } else if (this.capacity <= 0 && this.state.takers.size > 0) {\n        this.messages.push(message);\n        this.releaseTaker();\n        return true;\n      }\n      return false;\n    }\n    this.messages.push(message);\n    this.scheduleReleaseTaker();\n    return true;\n  }\n  offerAll(messages) {\n    return core.suspend(() => {\n      if (this.state._tag !== \"Open\") {\n        return core.succeed(Chunk.fromIterable(messages));\n      }\n      const remaining = this.unsafeOfferAllArray(messages);\n      if (remaining.length === 0) {\n        return exitEmpty;\n      } else if (this.strategy === \"dropping\") {\n        return core.succeed(Chunk.unsafeFromArray(remaining));\n      }\n      return this.offerRemainingArray(remaining);\n    });\n  }\n  unsafeOfferAll(messages) {\n    return Chunk.unsafeFromArray(this.unsafeOfferAllArray(messages));\n  }\n  unsafeOfferAllArray(messages) {\n    if (this.state._tag !== \"Open\") {\n      return Arr.fromIterable(messages);\n    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === \"sliding\") {\n      if (this.messages.length > 0) {\n        this.messagesChunk = Chunk.appendAll(this.messagesChunk, Chunk.unsafeFromArray(this.messages));\n      }\n      if (this.strategy === \"sliding\") {\n        this.messagesChunk = this.messagesChunk.pipe(Chunk.appendAll(Chunk.fromIterable(messages)), Chunk.takeRight(this.capacity));\n      } else if (Chunk.isChunk(messages)) {\n        this.messagesChunk = Chunk.appendAll(this.messagesChunk, messages);\n      } else {\n        this.messages = Arr.fromIterable(messages);\n      }\n      this.scheduleReleaseTaker();\n      return [];\n    }\n    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;\n    if (free === 0) {\n      return Arr.fromIterable(messages);\n    }\n    const remaining = [];\n    let i = 0;\n    for (const message of messages) {\n      if (i < free) {\n        this.messages.push(message);\n      } else {\n        remaining.push(message);\n      }\n      i++;\n    }\n    this.scheduleReleaseTaker();\n    return remaining;\n  }\n  fail(error) {\n    return this.done(core.exitFail(error));\n  }\n  failCause(cause) {\n    return this.done(core.exitFailCause(cause));\n  }\n  unsafeDone(exit) {\n    if (this.state._tag !== \"Open\") {\n      return false;\n    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {\n      this.finalize(exit);\n      return true;\n    }\n    this.state = {\n      ...this.state,\n      _tag: \"Closing\",\n      exit\n    };\n    return true;\n  }\n  shutdown = /*#__PURE__*/core.sync(() => {\n    if (this.state._tag === \"Done\") {\n      return true;\n    }\n    this.messages = [];\n    this.messagesChunk = empty;\n    const offers = this.state.offers;\n    this.finalize(this.state._tag === \"Open\" ? core.exitVoid : this.state.exit);\n    if (offers.size > 0) {\n      for (const entry of offers) {\n        if (entry._tag === \"Single\") {\n          entry.resume(exitFalse);\n        } else {\n          entry.resume(core.exitSucceed(Chunk.unsafeFromArray(entry.remaining.slice(entry.offset))));\n        }\n      }\n      offers.clear();\n    }\n    return true;\n  });\n  done(exit) {\n    return core.sync(() => this.unsafeDone(exit));\n  }\n  end = /*#__PURE__*/this.done(core.exitVoid);\n  clear = /*#__PURE__*/core.suspend(() => {\n    if (this.state._tag === \"Done\") {\n      return core.exitAs(this.state.exit, empty);\n    }\n    const messages = this.unsafeTakeAll();\n    this.releaseCapacity();\n    return core.succeed(messages);\n  });\n  takeAll = /*#__PURE__*/core.suspend(() => {\n    if (this.state._tag === \"Done\") {\n      return core.exitAs(this.state.exit, constDone);\n    }\n    const messages = this.unsafeTakeAll();\n    if (messages.length === 0) {\n      return core.zipRight(this.awaitTake, this.takeAll);\n    }\n    return core.succeed([messages, this.releaseCapacity()]);\n  });\n  takeN(n) {\n    return core.suspend(() => {\n      if (this.state._tag === \"Done\") {\n        return core.exitAs(this.state.exit, constDone);\n      } else if (n <= 0) {\n        return core.succeed([empty, false]);\n      }\n      n = Math.min(n, this.capacity);\n      let messages;\n      if (n <= this.messagesChunk.length) {\n        messages = Chunk.take(this.messagesChunk, n);\n        this.messagesChunk = Chunk.drop(this.messagesChunk, n);\n      } else if (n <= this.messages.length + this.messagesChunk.length) {\n        this.messagesChunk = Chunk.appendAll(this.messagesChunk, Chunk.unsafeFromArray(this.messages));\n        this.messages = [];\n        messages = Chunk.take(this.messagesChunk, n);\n        this.messagesChunk = Chunk.drop(this.messagesChunk, n);\n      } else {\n        return core.zipRight(this.awaitTake, this.takeN(n));\n      }\n      return core.succeed([messages, this.releaseCapacity()]);\n    });\n  }\n  unsafeTake() {\n    if (this.state._tag === \"Done\") {\n      return core.exitZipRight(this.state.exit, core.exitFail(new NoSuchElementException()));\n    }\n    let message;\n    if (this.messagesChunk.length > 0) {\n      message = Chunk.unsafeHead(this.messagesChunk);\n      this.messagesChunk = Chunk.drop(this.messagesChunk, 1);\n    } else if (this.messages.length > 0) {\n      message = this.messages[0];\n      this.messagesChunk = Chunk.drop(Chunk.unsafeFromArray(this.messages), 1);\n      this.messages = [];\n    } else if (this.capacity <= 0 && this.state.offers.size > 0) {\n      this.capacity = 1;\n      this.releaseCapacity();\n      this.capacity = 0;\n      return this.messages.length > 0 ? core.exitSucceed(this.messages.pop()) : undefined;\n    } else {\n      return undefined;\n    }\n    this.releaseCapacity();\n    return core.exitSucceed(message);\n  }\n  take = /*#__PURE__*/core.suspend(() => this.unsafeTake() ?? core.zipRight(this.awaitTake, this.take));\n  await = /*#__PURE__*/core.asyncInterrupt(resume => {\n    if (this.state._tag === \"Done\") {\n      return resume(this.state.exit);\n    }\n    this.state.awaiters.add(resume);\n    return core.sync(() => {\n      if (this.state._tag !== \"Done\") {\n        this.state.awaiters.delete(resume);\n      }\n    });\n  });\n  unsafeSize() {\n    const size = this.messages.length + this.messagesChunk.length;\n    return this.state._tag === \"Done\" ? Option.none() : Option.some(size);\n  }\n  size = /*#__PURE__*/core.sync(() => this.unsafeSize());\n  commit() {\n    return this.takeAll;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"effect/Mailbox\",\n      state: this.state._tag,\n      size: this.unsafeSize().toJSON()\n    };\n  }\n  toString() {\n    return Inspectable.format(this);\n  }\n  [Inspectable.NodeInspectSymbol]() {\n    return Inspectable.format(this);\n  }\n  offerRemainingSingle(message) {\n    return core.asyncInterrupt(resume => {\n      if (this.state._tag !== \"Open\") {\n        return resume(exitFalse);\n      }\n      const entry = {\n        _tag: \"Single\",\n        message,\n        resume\n      };\n      this.state.offers.add(entry);\n      return core.sync(() => {\n        if (this.state._tag === \"Open\") {\n          this.state.offers.delete(entry);\n        }\n      });\n    });\n  }\n  offerRemainingArray(remaining) {\n    return core.asyncInterrupt(resume => {\n      if (this.state._tag !== \"Open\") {\n        return resume(core.exitSucceed(Chunk.unsafeFromArray(remaining)));\n      }\n      const entry = {\n        _tag: \"Array\",\n        remaining,\n        offset: 0,\n        resume\n      };\n      this.state.offers.add(entry);\n      return core.sync(() => {\n        if (this.state._tag === \"Open\") {\n          this.state.offers.delete(entry);\n        }\n      });\n    });\n  }\n  releaseCapacity() {\n    if (this.state._tag === \"Done\") {\n      return this.state.exit._tag === \"Success\";\n    } else if (this.state.offers.size === 0) {\n      if (this.state._tag === \"Closing\" && this.messages.length === 0 && this.messagesChunk.length === 0) {\n        this.finalize(this.state.exit);\n        return this.state.exit._tag === \"Success\";\n      }\n      return false;\n    }\n    let n = this.capacity - this.messages.length - this.messagesChunk.length;\n    for (const entry of this.state.offers) {\n      if (n === 0) return false;else if (entry._tag === \"Single\") {\n        this.messages.push(entry.message);\n        n--;\n        entry.resume(exitTrue);\n        this.state.offers.delete(entry);\n      } else {\n        for (; entry.offset < entry.remaining.length; entry.offset++) {\n          if (n === 0) return false;\n          this.messages.push(entry.remaining[entry.offset]);\n          n--;\n        }\n        entry.resume(exitEmpty);\n        this.state.offers.delete(entry);\n      }\n    }\n    return false;\n  }\n  awaitTake = /*#__PURE__*/core.asyncInterrupt(resume => {\n    if (this.state._tag === \"Done\") {\n      return resume(this.state.exit);\n    }\n    this.state.takers.add(resume);\n    return core.sync(() => {\n      if (this.state._tag !== \"Done\") {\n        this.state.takers.delete(resume);\n      }\n    });\n  });\n  scheduleRunning = false;\n  scheduleReleaseTaker() {\n    if (this.scheduleRunning) {\n      return;\n    }\n    this.scheduleRunning = true;\n    this.scheduler.scheduleTask(this.releaseTaker, 0);\n  }\n  releaseTaker = () => {\n    this.scheduleRunning = false;\n    if (this.state._tag === \"Done\") {\n      return;\n    } else if (this.state.takers.size === 0) {\n      return;\n    }\n    for (const taker of this.state.takers) {\n      this.state.takers.delete(taker);\n      taker(core.exitVoid);\n      if (this.messages.length + this.messagesChunk.length === 0) {\n        break;\n      }\n    }\n  };\n  unsafeTakeAll() {\n    if (this.messagesChunk.length > 0) {\n      const messages = this.messages.length > 0 ? Chunk.appendAll(this.messagesChunk, Chunk.unsafeFromArray(this.messages)) : this.messagesChunk;\n      this.messagesChunk = empty;\n      this.messages = [];\n      return messages;\n    } else if (this.messages.length > 0) {\n      const messages = Chunk.unsafeFromArray(this.messages);\n      this.messages = [];\n      return messages;\n    } else if (this.state._tag !== \"Done\" && this.state.offers.size > 0) {\n      this.capacity = 1;\n      this.releaseCapacity();\n      this.capacity = 0;\n      return Chunk.of(this.messages.pop());\n    }\n    return empty;\n  }\n  finalize(exit) {\n    if (this.state._tag === \"Done\") {\n      return;\n    }\n    const openState = this.state;\n    this.state = {\n      _tag: \"Done\",\n      exit\n    };\n    for (const taker of openState.takers) {\n      taker(exit);\n    }\n    openState.takers.clear();\n    for (const awaiter of openState.awaiters) {\n      awaiter(exit);\n    }\n    openState.awaiters.clear();\n  }\n}\n/** @internal */\nexport const make = capacity => core.withFiberRuntime(fiber => core.succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity === \"number\" ? capacity : capacity?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity === \"number\" ? \"suspend\" : capacity?.strategy ?? \"suspend\")));\n/** @internal */\nexport const into = /*#__PURE__*/dual(2, (effect, self) => core.uninterruptibleMask(restore => core.matchCauseEffect(restore(effect), {\n  onFailure: cause => self.failCause(cause),\n  onSuccess: _ => self.end\n})));\n/** @internal */\nexport const toChannel = self => {\n  const loop = coreChannel.flatMap(self.takeAll, ([messages, done]) => done ? messages.length === 0 ? coreChannel.void : coreChannel.write(messages) : channel.zipRight(coreChannel.write(messages), loop));\n  return loop;\n};\n/** @internal */\nexport const toStream = self => stream.fromChannel(toChannel(self));\n/** @internal */\nexport const fromStream = /*#__PURE__*/dual(args => stream.isStream(args[0]), (self, options) => core.tap(fiberRuntime.acquireRelease(make(options), mailbox => mailbox.shutdown), mailbox => {\n  const writer = coreChannel.readWithCause({\n    onInput: input => coreChannel.flatMap(mailbox.offerAll(input), () => writer),\n    onFailure: cause => mailbox.failCause(cause),\n    onDone: () => mailbox.end\n  });\n  return fiberRuntime.scopeWith(scope => stream.toChannel(self).pipe(coreChannel.pipeTo(writer), channelExecutor.runIn(scope), circular.forkIn(scope)));\n}));\n//# sourceMappingURL=mailbox.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
