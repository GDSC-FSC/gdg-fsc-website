{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/internal/httpRouter.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Chunk from \"effect/Chunk\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as Effectable from \"effect/Effectable\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport { dual } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport * as Inspectable from \"effect/Inspectable\";\nimport * as Layer from \"effect/Layer\";\nimport * as Option from \"effect/Option\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as Schema from \"effect/Schema\";\nimport * as Tracer from \"effect/Tracer\";\nimport * as FindMyWay from \"find-my-way-ts\";\nimport * as HttpServer from \"../HttpServer.js\";\nimport * as Error from \"../HttpServerError.js\";\nimport * as ServerRequest from \"../HttpServerRequest.js\";\nimport * as Respondable from \"../HttpServerRespondable.js\";\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpRouter\");\n/** @internal */\nexport const RouteTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpRouter/Route\");\n/** @internal */\nexport const RouteContextTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpRouter/RouteContext\");\n/** @internal */\nexport const RouteContext = /*#__PURE__*/Context.GenericTag(\"@effect/platform/HttpRouter/RouteContext\");\nconst isRouter = u => Predicate.hasProperty(u, TypeId);\n/** @internal */\nexport const params = /*#__PURE__*/Effect.map(RouteContext, _ => _.params);\n/** @internal */\nexport const schemaJson = (schema, options) => {\n  const parse = Schema.decodeUnknown(schema, options);\n  return Effect.flatMap(Effect.context(), context => {\n    const request = Context.get(context, ServerRequest.HttpServerRequest);\n    const searchParams = Context.get(context, ServerRequest.ParsedSearchParams);\n    const routeContext = Context.get(context, RouteContext);\n    return Effect.flatMap(request.json, body => parse({\n      method: request.method,\n      url: request.url,\n      headers: request.headers,\n      cookies: request.cookies,\n      pathParams: routeContext.params,\n      searchParams,\n      body\n    }));\n  });\n};\n/** @internal */\nexport const schemaNoBody = (schema, options) => {\n  const parse = Schema.decodeUnknown(schema, options);\n  return Effect.flatMap(Effect.context(), context => {\n    const request = Context.get(context, ServerRequest.HttpServerRequest);\n    const searchParams = Context.get(context, ServerRequest.ParsedSearchParams);\n    const routeContext = Context.get(context, RouteContext);\n    return parse({\n      method: request.method,\n      url: request.url,\n      headers: request.headers,\n      cookies: request.cookies,\n      pathParams: routeContext.params,\n      searchParams\n    });\n  });\n};\n/** @internal */\nexport const schemaParams = (schema, options) => {\n  const parse = Schema.decodeUnknown(schema, options);\n  return Effect.flatMap(Effect.context(), context => {\n    const searchParams = Context.get(context, ServerRequest.ParsedSearchParams);\n    const routeContext = Context.get(context, RouteContext);\n    return parse({\n      ...searchParams,\n      ...routeContext.params\n    });\n  });\n};\n/** @internal */\nexport const schemaPathParams = (schema, options) => {\n  const parse = Schema.decodeUnknown(schema, options);\n  return Effect.flatMap(RouteContext, _ => parse(_.params));\n};\n/** @internal */\nexport const currentRouterConfig = /*#__PURE__*/globalValue(\"@effect/platform/HttpRouter/currentRouterConfig\", () => FiberRef.unsafeMake({}));\n/** @internal */\nexport const withRouterConfig = /*#__PURE__*/dual(2, (effect, config) => Effect.locally(effect, currentRouterConfig, config));\n/** @internal */\nexport const setRouterConfig = config => Layer.locallyScoped(currentRouterConfig, config);\nclass RouterImpl extends Effectable.StructuralClass {\n  routes;\n  mounts;\n  [TypeId];\n  constructor(routes, mounts) {\n    super();\n    this.routes = routes;\n    this.mounts = mounts;\n    this[TypeId] = TypeId;\n    this.httpApp = toHttpApp(this).pipe(Effect.flatMap(app => this.httpApp = app));\n  }\n  httpApp;\n  commit() {\n    return this.httpApp;\n  }\n  toJSON() {\n    return {\n      _id: \"Router\",\n      routes: this.routes.toJSON(),\n      mounts: this.mounts.toJSON()\n    };\n  }\n  toString() {\n    return Inspectable.format(this);\n  }\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexport const toHttpApp = self => Effect.map(FiberRef.get(currentRouterConfig), config => {\n  const router = FindMyWay.make(config);\n  const mounts = Chunk.toReadonlyArray(self.mounts).map(([path, app, options]) => [path, new RouteContextImpl(new RouteImpl(\"*\", options?.includePrefix ? `${path}/*` : \"/*\", app, options?.includePrefix ? Option.none() : Option.some(path), false), {}), options]);\n  const mountsLen = mounts.length;\n  Chunk.forEach(self.routes, route => {\n    if (route.method === \"*\") {\n      router.all(route.path, route);\n    } else {\n      router.on(route.method, route.path, route);\n    }\n  });\n  return Effect.withFiberRuntime(fiber => {\n    const context = Context.unsafeMake(new Map(fiber.getFiberRef(FiberRef.currentContext).unsafeMap));\n    const request = Context.unsafeGet(context, ServerRequest.HttpServerRequest);\n    if (mountsLen > 0) {\n      const searchIndex = request.url.indexOf(\"?\");\n      const pathname = searchIndex === -1 ? request.url : request.url.slice(0, searchIndex);\n      for (let i = 0; i < mountsLen; i++) {\n        const [path, routeContext, options] = mounts[i];\n        if (pathname === path || pathname.startsWith(path + \"/\")) {\n          context.unsafeMap.set(RouteContext.key, routeContext);\n          if (options?.includePrefix !== true) {\n            context.unsafeMap.set(ServerRequest.HttpServerRequest.key, sliceRequestUrl(request, path));\n          }\n          return Effect.locally(Effect.flatMap(routeContext.route.handler, Respondable.toResponse), FiberRef.currentContext, context);\n        }\n      }\n    }\n    let result = router.find(request.method, request.url);\n    if (result === undefined && request.method === \"HEAD\") {\n      result = router.find(\"GET\", request.url);\n    }\n    if (result === undefined) {\n      return Effect.fail(new Error.RouteNotFound({\n        request\n      }));\n    }\n    const route = result.handler;\n    if (route.prefix._tag === \"Some\") {\n      context.unsafeMap.set(ServerRequest.HttpServerRequest.key, sliceRequestUrl(request, route.prefix.value));\n    }\n    context.unsafeMap.set(ServerRequest.ParsedSearchParams.key, result.searchParams);\n    context.unsafeMap.set(RouteContext.key, new RouteContextImpl(route, result.params));\n    const span = Context.getOption(context, Tracer.ParentSpan);\n    if (span._tag === \"Some\" && span.value._tag === \"Span\") {\n      span.value.attribute(\"http.route\", route.path);\n    }\n    const handlerResponse = Effect.flatMap(route.handler, Respondable.toResponse);\n    return Effect.locally(route.uninterruptible ? handlerResponse : Effect.interruptible(handlerResponse), FiberRef.currentContext, context);\n  });\n});\nfunction sliceRequestUrl(request, prefix) {\n  const prefexLen = prefix.length;\n  return request.modify({\n    url: request.url.length <= prefexLen ? \"/\" : request.url.slice(prefexLen)\n  });\n}\nclass RouteImpl extends Inspectable.Class {\n  method;\n  path;\n  handler;\n  prefix;\n  uninterruptible;\n  [RouteTypeId];\n  constructor(method, path, handler, prefix = Option.none(), uninterruptible = false) {\n    super();\n    this.method = method;\n    this.path = path;\n    this.handler = handler;\n    this.prefix = prefix;\n    this.uninterruptible = uninterruptible;\n    this[RouteTypeId] = RouteTypeId;\n  }\n  toJSON() {\n    return {\n      _id: \"@effect/platform/HttpRouter/Route\",\n      method: this.method,\n      path: this.path,\n      prefix: this.prefix.toJSON()\n    };\n  }\n}\nclass RouteContextImpl {\n  route;\n  params;\n  [RouteContextTypeId];\n  constructor(route, params) {\n    this.route = route;\n    this.params = params;\n    this[RouteContextTypeId] = RouteContextTypeId;\n  }\n}\n/** @internal */\nexport const empty = /*#__PURE__*/new RouterImpl(/*#__PURE__*/Chunk.empty(), /*#__PURE__*/Chunk.empty());\n/** @internal */\nexport const fromIterable = routes => new RouterImpl(Chunk.fromIterable(routes), Chunk.empty());\n/** @internal */\nexport const makeRoute = (method, path, handler, options) => new RouteImpl(method, path, handler, options?.prefix ? Option.some(options.prefix) : Option.none(), options?.uninterruptible ?? false);\n/** @internal */\nexport const append = /*#__PURE__*/dual(2, (self, route) => new RouterImpl(Chunk.append(self.routes, route), self.mounts));\n/** @internal */\nexport const concat = /*#__PURE__*/dual(2, (self, that) => concatAll(self, that));\n/** @internal */\nexport const concatAll = (...routers) => new RouterImpl(routers.reduce((cur, acc) => Chunk.appendAll(cur, acc.routes), Chunk.empty()), routers.reduce((cur, acc) => Chunk.appendAll(cur, acc.mounts), Chunk.empty()));\nconst removeTrailingSlash = path => path.endsWith(\"/\") ? path.slice(0, -1) : path;\n/** @internal */\nexport const prefixPath = /*#__PURE__*/dual(2, (self, prefix) => {\n  prefix = removeTrailingSlash(prefix);\n  return self === \"/\" ? prefix : prefix + self;\n});\n/** @internal */\nexport const prefixAll = /*#__PURE__*/dual(2, (self, prefix) => {\n  prefix = removeTrailingSlash(prefix);\n  return new RouterImpl(Chunk.map(self.routes, route => new RouteImpl(route.method, route.path === \"/\" ? prefix : prefix + route.path, route.handler, Option.orElse(Option.map(route.prefix, _ => prefix + _), () => Option.some(prefix)), route.uninterruptible)), Chunk.map(self.mounts, ([path, app]) => [path === \"/\" ? prefix : prefix + path, app]));\n});\n/** @internal */\nexport const mount = /*#__PURE__*/dual(3, (self, path, that) => concat(self, prefixAll(that, path)));\n/** @internal */\nexport const mountApp = /*#__PURE__*/dual(args => Predicate.hasProperty(args[0], TypeId), (self, path, that, options) => new RouterImpl(self.routes, Chunk.append(self.mounts, [removeTrailingSlash(path), that, options])));\n/** @internal */\nexport const route = method => dual(args => isRouter(args[0]), (self, path, handler, options) => new RouterImpl(Chunk.append(self.routes, new RouteImpl(method, path, handler, Option.none(), options?.uninterruptible ?? false)), self.mounts));\n/** @internal */\nexport const all = /*#__PURE__*/route(\"*\");\n/** @internal */\nexport const get = /*#__PURE__*/route(\"GET\");\n/** @internal */\nexport const post = /*#__PURE__*/route(\"POST\");\n/** @internal */\nexport const put = /*#__PURE__*/route(\"PUT\");\n/** @internal */\nexport const patch = /*#__PURE__*/route(\"PATCH\");\n/** @internal */\nexport const del = /*#__PURE__*/route(\"DELETE\");\n/** @internal */\nexport const head = /*#__PURE__*/route(\"HEAD\");\n/** @internal */\nexport const options = /*#__PURE__*/route(\"OPTIONS\");\n/** @internal */\nexport const use = /*#__PURE__*/dual(2, (self, f) => new RouterImpl(Chunk.map(self.routes, route => new RouteImpl(route.method, route.path, f(Effect.flatMap(route.handler, Respondable.toResponse)), route.prefix, route.uninterruptible)), Chunk.map(self.mounts, ([path, app]) => [path, f(app)])));\n/** @internal */\nexport const transform = /*#__PURE__*/dual(2, (self, f) => new RouterImpl(Chunk.map(self.routes, route => new RouteImpl(route.method, route.path, f(route.handler), route.prefix, route.uninterruptible)), Chunk.map(self.mounts, ([path, app]) => [path, Effect.flatMap(f(app), Respondable.toResponse)])));\n/** @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, f) => transform(self, Effect.catchAll(f)));\n/** @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, f) => transform(self, Effect.catchAllCause(f)));\n/** @internal */\nexport const catchTag = /*#__PURE__*/dual(3, (self, k, f) => transform(self, Effect.catchTag(k, f)));\n/** @internal */\nexport const catchTags = /*#__PURE__*/dual(2, (self, cases) => use(self, Effect.catchTags(cases)));\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, service) => use(self, Effect.provideService(tag, service)));\n/* @internal */\nexport const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => use(self, Effect.provideServiceEffect(tag, effect)));\nconst makeService = () => {\n  let router = empty;\n  return {\n    addRoute(route) {\n      return Effect.sync(() => {\n        router = append(router, route);\n      });\n    },\n    all(path, handler, options) {\n      return Effect.sync(() => {\n        router = all(router, path, handler, options);\n      });\n    },\n    get(path, handler, options) {\n      return Effect.sync(() => {\n        router = get(router, path, handler, options);\n      });\n    },\n    post(path, handler, options) {\n      return Effect.sync(() => {\n        router = post(router, path, handler, options);\n      });\n    },\n    put(path, handler, options) {\n      return Effect.sync(() => {\n        router = put(router, path, handler, options);\n      });\n    },\n    patch(path, handler, options) {\n      return Effect.sync(() => {\n        router = patch(router, path, handler, options);\n      });\n    },\n    del(path, handler, options) {\n      return Effect.sync(() => {\n        router = del(router, path, handler, options);\n      });\n    },\n    head(path, handler, options) {\n      return Effect.sync(() => {\n        router = head(router, path, handler, options);\n      });\n    },\n    options(path, handler, opts) {\n      return Effect.sync(() => {\n        router = options(router, path, handler, opts);\n      });\n    },\n    router: Effect.sync(() => router),\n    mount(path, that) {\n      return Effect.sync(() => {\n        router = mount(router, path, that);\n      });\n    },\n    mountApp(path, app, options) {\n      return Effect.sync(() => {\n        router = mountApp(router, path, app, options);\n      });\n    },\n    concat(that) {\n      return Effect.sync(() => {\n        router = concat(router, that);\n      });\n    }\n  };\n};\n/* @internal */\nexport const Tag = id => () => {\n  const Err = globalThis.Error;\n  const limit = Err.stackTraceLimit;\n  Err.stackTraceLimit = 2;\n  const creationError = new Err();\n  Err.stackTraceLimit = limit;\n  function TagClass() {}\n  const TagClass_ = TagClass;\n  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag(id)));\n  TagClass.key = id;\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  TagClass_.Live = Layer.sync(TagClass_, makeService);\n  TagClass_.router = Effect.flatMap(TagClass_, _ => _.router);\n  TagClass_.use = f => TagClass_.pipe(Effect.flatMap(f), Layer.scopedDiscard, Layer.provide(TagClass_.Live));\n  TagClass_.unwrap = f => TagClass_.pipe(Effect.flatMap(_ => _.router), Effect.map(f), Layer.unwrapEffect, Layer.provide(TagClass_.Live));\n  TagClass_.serve = middleware => TagClass_.unwrap(HttpServer.serve(middleware));\n  return TagClass;\n};\n//# sourceMappingURL=httpRouter.js.map",
      "start": 1768772628752,
      "end": 1768772628752
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628752,
      "end": 1768772628768,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628770,
      "end": 1768772628785,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628788,
      "end": 1768772628803,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628805,
      "end": 1768772628811,
      "order": "post-post"
    }
  ]
}
