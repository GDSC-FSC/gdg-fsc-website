{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stm/stm.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as RA from \"../../Array.js\";\nimport * as Cause from \"../../Cause.js\";\nimport * as Chunk from \"../../Chunk.js\";\nimport * as Context from \"../../Context.js\";\nimport * as Effect from \"../../Effect.js\";\nimport * as Either from \"../../Either.js\";\nimport * as Exit from \"../../Exit.js\";\nimport { constFalse, constTrue, constVoid, dual, identity, pipe } from \"../../Function.js\";\nimport * as Option from \"../../Option.js\";\nimport * as predicate from \"../../Predicate.js\";\nimport { yieldWrapGet } from \"../../Utils.js\";\nimport * as effectCore from \"../core.js\";\nimport * as core from \"./core.js\";\nimport * as Journal from \"./journal.js\";\nimport * as STMState from \"./stmState.js\";\n/** @internal */\nexport const acquireUseRelease = /*#__PURE__*/dual(3, (acquire, use, release) => Effect.uninterruptibleMask(restore => {\n  let state = STMState.running;\n  return pipe(restore(core.unsafeAtomically(acquire, exit => {\n    state = STMState.done(exit);\n  }, () => {\n    state = STMState.interrupted;\n  })), Effect.matchCauseEffect({\n    onFailure: cause => {\n      if (STMState.isDone(state) && Exit.isSuccess(state.exit)) {\n        return pipe(release(state.exit.value), Effect.matchCauseEffect({\n          onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),\n          onSuccess: () => Effect.failCause(cause)\n        }));\n      }\n      return Effect.failCause(cause);\n    },\n    onSuccess: a => pipe(restore(use(a)), Effect.matchCauseEffect({\n      onFailure: cause => pipe(release(a), Effect.matchCauseEffect({\n        onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),\n        onSuccess: () => Effect.failCause(cause)\n      })),\n      onSuccess: a2 => pipe(release(a), Effect.as(a2))\n    }))\n  }));\n}));\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, value) => pipe(self, core.map(() => value)));\n/** @internal */\nexport const asSome = self => pipe(self, core.map(Option.some));\n/** @internal */\nexport const asSomeError = self => pipe(self, mapError(Option.some));\n/** @internal */\nexport const asVoid = self => pipe(self, core.map(constVoid));\n/** @internal */\nexport const attempt = evaluate => suspend(() => {\n  try {\n    return core.succeed(evaluate());\n  } catch (defect) {\n    return core.fail(defect);\n  }\n});\nexport const bind = /*#__PURE__*/dual(3, (self, tag, f) => core.flatMap(self, k => core.map(f(k), a => ({\n  ...k,\n  [tag]: a\n}))));\n/* @internal */\nexport const bindTo = /*#__PURE__*/dual(2, (self, tag) => core.map(self, a => ({\n  [tag]: a\n})));\n/* @internal */\nexport const let_ = /*#__PURE__*/dual(3, (self, tag, f) => core.map(self, k => ({\n  ...k,\n  [tag]: f(k)\n})));\n/** @internal */\nexport const catchSome = /*#__PURE__*/dual(2, (self, pf) => core.catchAll(self, e => Option.getOrElse(pf(e), () => core.fail(e))));\n/** @internal */\nexport const catchTag = /*#__PURE__*/dual(3, (self, k, f) => core.catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return f(e);\n  }\n  return core.fail(e);\n}));\n/** @internal */\nexport const catchTags = /*#__PURE__*/dual(2, (self, cases) => core.catchAll(self, e => {\n  const keys = Object.keys(cases);\n  if (\"_tag\" in e && keys.includes(e[\"_tag\"])) {\n    return cases[e[\"_tag\"]](e);\n  }\n  return core.fail(e);\n}));\n/** @internal */\nexport const check = predicate => suspend(() => predicate() ? void_ : core.retry);\n/** @internal */\nexport const collect = /*#__PURE__*/dual(2, (self, pf) => collectSTM(self, a => Option.map(pf(a), core.succeed)));\n/** @internal */\nexport const collectSTM = /*#__PURE__*/dual(2, (self, pf) => core.matchSTM(self, {\n  onFailure: core.fail,\n  onSuccess: a => {\n    const option = pf(a);\n    return Option.isSome(option) ? option.value : core.retry;\n  }\n}));\n/** @internal */\nexport const commitEither = self => Effect.flatten(core.commit(either(self)));\n/** @internal */\nexport const cond = (predicate, error, result) => {\n  return suspend(() => predicate() ? core.sync(result) : core.failSync(error));\n};\n/** @internal */\nexport const either = self => match(self, {\n  onFailure: Either.left,\n  onSuccess: Either.right\n});\n/** @internal */\nexport const eventually = self => core.matchSTM(self, {\n  onFailure: () => eventually(self),\n  onSuccess: core.succeed\n});\n/** @internal */\nexport const every = /*#__PURE__*/dual(2, (iterable, predicate) => core.flatMap(core.sync(() => iterable[Symbol.iterator]()), iterator => {\n  const loop = suspend(() => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.succeed(true);\n    }\n    return pipe(predicate(next.value), core.flatMap(bool => bool ? loop : core.succeed(bool)));\n  });\n  return loop;\n}));\n/** @internal */\nexport const exists = /*#__PURE__*/dual(2, (iterable, predicate) => core.flatMap(core.sync(() => iterable[Symbol.iterator]()), iterator => {\n  const loop = suspend(() => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.succeed(false);\n    }\n    return core.flatMap(predicate(next.value), bool => bool ? core.succeed(bool) : loop);\n  });\n  return loop;\n}));\n/** @internal */\nexport const fiberId = /*#__PURE__*/core.effect((_, fiberId) => fiberId);\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, core.zipWith(predicate(curr), (as, p) => {\n  if (p) {\n    as.push(curr);\n    return as;\n  }\n  return as;\n})), core.succeed([])));\n/** @internal */\nexport const filterNot = /*#__PURE__*/dual(2, (iterable, predicate) => filter(iterable, a => negate(predicate(a))));\n/** @internal */\nexport const filterOrDie = /*#__PURE__*/dual(3, (self, predicate, defect) => filterOrElse(self, predicate, () => core.dieSync(defect)));\n/** @internal */\nexport const filterOrDieMessage = /*#__PURE__*/dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => core.dieMessage(message)));\n/** @internal */\nexport const filterOrElse = /*#__PURE__*/dual(3, (self, predicate, orElse) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : orElse(a)));\n/** @internal */\nexport const filterOrFail = /*#__PURE__*/dual(3, (self, predicate, orFailWith) => filterOrElse(self, predicate, a => core.failSync(() => orFailWith(a))));\n/** @internal */\nexport const flatten = self => core.flatMap(self, identity);\n/** @internal */\nexport const flip = self => core.matchSTM(self, {\n  onFailure: core.succeed,\n  onSuccess: core.fail\n});\n/** @internal */\nexport const flipWith = /*#__PURE__*/dual(2, (self, f) => flip(f(flip(self))));\n/** @internal */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => core.matchSTM(self, {\n  onFailure: e => core.succeed(onFailure(e)),\n  onSuccess: a => core.succeed(onSuccess(a))\n}));\n/** @internal */\nexport const forEach = /*#__PURE__*/dual(args => predicate.isIterable(args[0]), (iterable, f, options) => {\n  if (options?.discard) {\n    return pipe(core.sync(() => iterable[Symbol.iterator]()), core.flatMap(iterator => {\n      const loop = suspend(() => {\n        const next = iterator.next();\n        if (next.done) {\n          return void_;\n        }\n        return pipe(f(next.value), core.flatMap(() => loop));\n      });\n      return loop;\n    }));\n  }\n  return suspend(() => RA.fromIterable(iterable).reduce((acc, curr) => core.zipWith(acc, f(curr), (array, elem) => {\n    array.push(elem);\n    return array;\n  }), core.succeed([])));\n});\n/** @internal */\nexport const fromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.fail(either.left);\n      }\n    case \"Right\":\n      {\n        return core.succeed(either.right);\n      }\n  }\n};\n/** @internal */\nexport const fromOption = option => Option.match(option, {\n  onNone: () => core.fail(Option.none()),\n  onSome: core.succeed\n});\n/**\n * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)\n * @internal\n */\nexport const gen = (...args) => suspend(() => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);\n  const iterator = f(pipe);\n  const state = iterator.next();\n  const run = state => state.done ? core.succeed(state.value) : core.flatMap(yieldWrapGet(state.value), val => run(iterator.next(val)));\n  return run(state);\n});\n/** @internal */\nexport const head = self => pipe(self, core.matchSTM({\n  onFailure: e => core.fail(Option.some(e)),\n  onSuccess: a => {\n    const i = a[Symbol.iterator]();\n    const res = i.next();\n    if (res.done) {\n      return core.fail(Option.none());\n    } else {\n      return core.succeed(res.value);\n    }\n  }\n}));\n/** @internal */\nexport const if_ = /*#__PURE__*/dual(args => typeof args[0] === \"boolean\" || core.isSTM(args[0]), (self, {\n  onFalse,\n  onTrue\n}) => {\n  if (typeof self === \"boolean\") {\n    return self ? onTrue : onFalse;\n  }\n  return core.flatMap(self, bool => bool ? onTrue : onFalse);\n});\n/** @internal */\nexport const ignore = self => match(self, {\n  onFailure: () => void_,\n  onSuccess: () => void_\n});\n/** @internal */\nexport const isFailure = self => match(self, {\n  onFailure: constTrue,\n  onSuccess: constFalse\n});\n/** @internal */\nexport const isSuccess = self => match(self, {\n  onFailure: constFalse,\n  onSuccess: constTrue\n});\n/** @internal */\nexport const iterate = (initial, options) => iterateLoop(initial, options.while, options.body);\nconst iterateLoop = (initial, cont, body) => {\n  if (cont(initial)) {\n    return pipe(body(initial), core.flatMap(z => iterateLoop(z, cont, body)));\n  }\n  return core.succeed(initial);\n};\n/** @internal */\nexport const loop = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : core.map(loopLoop(initial, options.while, options.step, options.body), a => Array.from(a));\nconst loopLoop = (initial, cont, inc, body) => {\n  if (cont(initial)) {\n    return pipe(body(initial), core.flatMap(a => pipe(loopLoop(inc(initial), cont, inc, body), core.map(Chunk.append(a)))));\n  }\n  return core.succeed(Chunk.empty());\n};\nconst loopDiscardLoop = (initial, cont, inc, body) => {\n  if (cont(initial)) {\n    return pipe(body(initial), core.flatMap(() => loopDiscardLoop(inc(initial), cont, inc, body)));\n  }\n  return void_;\n};\n/** @internal */\nexport const mapAttempt = /*#__PURE__*/dual(2, (self, f) => core.matchSTM(self, {\n  onFailure: e => core.fail(e),\n  onSuccess: a => attempt(() => f(a))\n}));\n/** @internal */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => core.matchSTM(self, {\n  onFailure: e => core.fail(onFailure(e)),\n  onSuccess: a => core.succeed(onSuccess(a))\n}));\n/** @internal */\nexport const mapError = /*#__PURE__*/dual(2, (self, f) => core.matchSTM(self, {\n  onFailure: e => core.fail(f(e)),\n  onSuccess: core.succeed\n}));\n/** @internal */\nexport const merge = self => core.matchSTM(self, {\n  onFailure: e => core.succeed(e),\n  onSuccess: core.succeed\n});\n/** @internal */\nexport const mergeAll = /*#__PURE__*/dual(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, core.zipWith(curr, f)), core.succeed(zero))));\n/** @internal */\nexport const negate = self => pipe(self, core.map(b => !b));\n/** @internal */\nexport const none = self => core.matchSTM(self, {\n  onFailure: e => core.fail(Option.some(e)),\n  onSuccess: Option.match({\n    onNone: () => void_,\n    onSome: () => core.fail(Option.none())\n  })\n});\n/** @internal */\nexport const option = self => match(self, {\n  onFailure: () => Option.none(),\n  onSuccess: Option.some\n});\n/** @internal */\nexport const orDie = self => pipe(self, orDieWith(identity));\n/** @internal */\nexport const orDieWith = /*#__PURE__*/dual(2, (self, f) => pipe(self, mapError(f), core.catchAll(core.die)));\n/** @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => core.flatMap(core.effect(journal => Journal.prepareResetJournal(journal)), reset => pipe(core.orTry(self, () => core.flatMap(core.sync(reset), that)), core.catchAll(() => core.flatMap(core.sync(reset), that)))));\n/** @internal */\nexport const orElseEither = /*#__PURE__*/dual(2, (self, that) => orElse(core.map(self, Either.left), () => core.map(that(), Either.right)));\n/** @internal */\nexport const orElseFail = /*#__PURE__*/dual(2, (self, error) => orElse(self, () => core.failSync(error)));\n/** @internal */\nexport const orElseOptional = /*#__PURE__*/dual(2, (self, that) => core.catchAll(self, Option.match({\n  onNone: that,\n  onSome: e => core.fail(Option.some(e))\n})));\n/** @internal */\nexport const orElseSucceed = /*#__PURE__*/dual(2, (self, value) => orElse(self, () => core.sync(value)));\n/** @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, env) => core.mapInputContext(self, _ => env));\n/** @internal */\nexport const provideSomeContext = /*#__PURE__*/dual(2, (self, context) => core.mapInputContext(self, parent => Context.merge(parent, context)));\n/** @internal */\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, resource) => provideServiceSTM(self, tag, core.succeed(resource)));\n/** @internal */\nexport const provideServiceSTM = /*#__PURE__*/dual(3, (self, tag, stm) => core.contextWithSTM(env => core.flatMap(stm, service => provideContext(self, Context.add(env, tag, service)))));\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, core.flatMap(s => f(s, curr))), core.succeed(zero))));\n/** @internal */\nexport const reduceAll = /*#__PURE__*/dual(3, (iterable, initial, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, core.zipWith(curr, f)), initial)));\n/** @internal */\nexport const reduceRight = /*#__PURE__*/dual(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, core.flatMap(s => f(s, curr))), core.succeed(zero))));\n/** @internal */\nexport const refineOrDie = /*#__PURE__*/dual(2, (self, pf) => refineOrDieWith(self, pf, identity));\n/** @internal */\nexport const refineOrDieWith = /*#__PURE__*/dual(3, (self, pf, f) => core.catchAll(self, e => Option.match(pf(e), {\n  onNone: () => core.die(f(e)),\n  onSome: core.fail\n})));\n/** @internal */\nexport const reject = /*#__PURE__*/dual(2, (self, pf) => rejectSTM(self, a => Option.map(pf(a), core.fail)));\n/** @internal */\nexport const rejectSTM = /*#__PURE__*/dual(2, (self, pf) => core.flatMap(self, a => Option.match(pf(a), {\n  onNone: () => core.succeed(a),\n  onSome: core.flatMap(core.fail)\n})));\n/** @internal */\nexport const repeatUntil = /*#__PURE__*/dual(2, (self, predicate) => repeatUntilLoop(self, predicate));\nconst repeatUntilLoop = (self, predicate) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : repeatUntilLoop(self, predicate));\n/** @internal */\nexport const repeatWhile = /*#__PURE__*/dual(2, (self, predicate) => repeatWhileLoop(self, predicate));\nconst repeatWhileLoop = (self, predicate) => core.flatMap(self, a => predicate(a) ? repeatWhileLoop(self, predicate) : core.succeed(a));\n/** @internal */\nexport const replicate = /*#__PURE__*/dual(2, (self, n) => Array.from({\n  length: n\n}, () => self));\n/** @internal */\nexport const replicateSTM = /*#__PURE__*/dual(2, (self, n) => all(replicate(self, n)));\n/** @internal */\nexport const replicateSTMDiscard = /*#__PURE__*/dual(2, (self, n) => all(replicate(self, n), {\n  discard: true\n}));\n/** @internal */\nexport const retryUntil = /*#__PURE__*/dual(2, (self, predicate) => core.matchSTM(self, {\n  onFailure: core.fail,\n  onSuccess: a => predicate(a) ? core.succeed(a) : core.retry\n}));\n/** @internal */\nexport const retryWhile = /*#__PURE__*/dual(2, (self, predicate) => core.matchSTM(self, {\n  onFailure: core.fail,\n  onSuccess: a => !predicate(a) ? core.succeed(a) : core.retry\n}));\n/** @internal */\nexport const partition = /*#__PURE__*/dual(2, (elements, f) => pipe(forEach(elements, a => either(f(a))), core.map(as => effectCore.partitionMap(as, identity))));\n/** @internal */\nexport const some = self => core.matchSTM(self, {\n  onFailure: e => core.fail(Option.some(e)),\n  onSuccess: Option.match({\n    onNone: () => core.fail(Option.none()),\n    onSome: core.succeed\n  })\n});\n/* @internal */\nexport const all = (input, options) => {\n  if (Symbol.iterator in input) {\n    return forEach(input, identity, options);\n  } else if (options?.discard) {\n    return forEach(Object.values(input), identity, options);\n  }\n  return core.map(forEach(Object.entries(input), ([_, e]) => core.map(e, a => [_, a])), values => {\n    const res = {};\n    for (const [k, v] of values) {\n      ;\n      res[k] = v;\n    }\n    return res;\n  });\n};\n/** @internal */\nexport const succeedNone = /*#__PURE__*/core.succeed(/*#__PURE__*/Option.none());\n/** @internal */\nexport const succeedSome = value => core.succeed(Option.some(value));\n/** @internal */\nexport const summarized = /*#__PURE__*/dual(3, (self, summary, f) => core.flatMap(summary, start => core.flatMap(self, value => core.map(summary, end => [f(start, end), value]))));\n/** @internal */\nexport const suspend = evaluate => flatten(core.sync(evaluate));\n/** @internal */\nexport const tap = /*#__PURE__*/dual(2, (self, f) => core.flatMap(self, a => as(f(a), a)));\n/** @internal */\nexport const tapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => core.matchSTM(self, {\n  onFailure: e => pipe(onFailure(e), core.zipRight(core.fail(e))),\n  onSuccess: a => pipe(onSuccess(a), as(a))\n}));\n/** @internal */\nexport const tapError = /*#__PURE__*/dual(2, (self, f) => core.matchSTM(self, {\n  onFailure: e => core.zipRight(f(e), core.fail(e)),\n  onSuccess: core.succeed\n}));\n/** @internal */\nexport const try_ = arg => {\n  const evaluate = typeof arg === \"function\" ? arg : arg.try;\n  return suspend(() => {\n    try {\n      return core.succeed(evaluate());\n    } catch (error) {\n      return core.fail(\"catch\" in arg ? arg.catch(error) : error);\n    }\n  });\n};\n/** @internal */\nconst void_ = /*#__PURE__*/core.succeed(void 0);\nexport { /** @internal */\nvoid_ as void };\n/** @internal */\nexport const unless = /*#__PURE__*/dual(2, (self, predicate) => suspend(() => predicate() ? succeedNone : asSome(self)));\n/** @internal */\nexport const unlessSTM = /*#__PURE__*/dual(2, (self, predicate) => core.flatMap(predicate, bool => bool ? succeedNone : asSome(self)));\n/** @internal */\nexport const unsome = self => core.matchSTM(self, {\n  onFailure: Option.match({\n    onNone: () => core.succeed(Option.none()),\n    onSome: core.fail\n  }),\n  onSuccess: a => core.succeed(Option.some(a))\n});\n/** @internal */\nexport const validateAll = /*#__PURE__*/dual(2, (elements, f) => core.flatMap(partition(elements, f), ([errors, values]) => RA.isNonEmptyArray(errors) ? core.fail(errors) : core.succeed(values)));\n/** @internal */\nexport const validateFirst = /*#__PURE__*/dual(2, (elements, f) => flip(forEach(elements, a => flip(f(a)))));\n/** @internal */\nexport const when = /*#__PURE__*/dual(2, (self, predicate) => suspend(() => predicate() ? asSome(self) : succeedNone));\n/** @internal */\nexport const whenSTM = /*#__PURE__*/dual(2, (self, predicate) => core.flatMap(predicate, bool => bool ? asSome(self) : succeedNone));\n//# sourceMappingURL=stm.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
