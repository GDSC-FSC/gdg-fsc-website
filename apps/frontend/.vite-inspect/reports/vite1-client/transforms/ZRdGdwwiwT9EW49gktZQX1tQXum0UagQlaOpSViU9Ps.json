{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Pretty.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 3.10.0\n */\nimport * as Arr from \"./Array.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as errors_ from \"./internal/schema/errors.js\";\nimport * as util_ from \"./internal/schema/util.js\";\nimport * as Option from \"./Option.js\";\nimport * as ParseResult from \"./ParseResult.js\";\nimport * as AST from \"./SchemaAST.js\";\n/**\n * @category prettify\n * @since 3.10.0\n */\nexport const make = schema => compile(schema.ast, []);\nconst getPrettyAnnotation = /*#__PURE__*/AST.getAnnotation(AST.PrettyAnnotationId);\nconst getMatcher = defaultPretty => ast => Option.match(getPrettyAnnotation(ast), {\n  onNone: () => defaultPretty,\n  onSome: handler => handler()\n});\nconst toString = /*#__PURE__*/getMatcher(a => String(a));\nconst stringify = /*#__PURE__*/getMatcher(a => JSON.stringify(a));\nconst formatUnknown = /*#__PURE__*/getMatcher(Inspectable.formatUnknown);\n/**\n * @since 3.10.0\n */\nexport const match = {\n  \"Declaration\": (ast, go, path) => {\n    const annotation = getPrettyAnnotation(ast);\n    if (Option.isSome(annotation)) {\n      return annotation.value(...ast.typeParameters.map(tp => go(tp, path)));\n    }\n    throw new Error(errors_.getPrettyMissingAnnotationErrorMessage(path, ast));\n  },\n  \"VoidKeyword\": /*#__PURE__*/getMatcher(() => \"void(0)\"),\n  \"NeverKeyword\": /*#__PURE__*/getMatcher(() => {\n    throw new Error(errors_.getPrettyNeverErrorMessage);\n  }),\n  \"Literal\": /*#__PURE__*/getMatcher(literal => typeof literal === \"bigint\" ? `${String(literal)}n` : JSON.stringify(literal)),\n  \"SymbolKeyword\": toString,\n  \"UniqueSymbol\": toString,\n  \"TemplateLiteral\": stringify,\n  \"UndefinedKeyword\": toString,\n  \"UnknownKeyword\": formatUnknown,\n  \"AnyKeyword\": formatUnknown,\n  \"ObjectKeyword\": formatUnknown,\n  \"StringKeyword\": stringify,\n  \"NumberKeyword\": toString,\n  \"BooleanKeyword\": toString,\n  \"BigIntKeyword\": /*#__PURE__*/getMatcher(a => `${String(a)}n`),\n  \"Enums\": stringify,\n  \"TupleType\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast);\n    if (Option.isSome(hook)) {\n      return hook.value();\n    }\n    const elements = ast.elements.map((e, i) => go(e.type, path.concat(i)));\n    const rest = ast.rest.map(annotatedAST => go(annotatedAST.type, path));\n    return input => {\n      const output = [];\n      let i = 0;\n      // ---------------------------------------------\n      // handle elements\n      // ---------------------------------------------\n      for (; i < elements.length; i++) {\n        if (input.length < i + 1) {\n          if (ast.elements[i].isOptional) {\n            continue;\n          }\n        } else {\n          output.push(elements[i](input[i]));\n        }\n      }\n      // ---------------------------------------------\n      // handle rest element\n      // ---------------------------------------------\n      if (Arr.isNonEmptyReadonlyArray(rest)) {\n        const [head, ...tail] = rest;\n        for (; i < input.length - tail.length; i++) {\n          output.push(head(input[i]));\n        }\n        // ---------------------------------------------\n        // handle post rest elements\n        // ---------------------------------------------\n        for (let j = 0; j < tail.length; j++) {\n          i += j;\n          output.push(tail[j](input[i]));\n        }\n      }\n      return \"[\" + output.join(\", \") + \"]\";\n    };\n  },\n  \"TypeLiteral\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast);\n    if (Option.isSome(hook)) {\n      return hook.value();\n    }\n    const propertySignaturesTypes = ast.propertySignatures.map(ps => go(ps.type, path.concat(ps.name)));\n    const indexSignatureTypes = ast.indexSignatures.map(is => go(is.type, path));\n    const expectedKeys = {};\n    for (let i = 0; i < propertySignaturesTypes.length; i++) {\n      expectedKeys[ast.propertySignatures[i].name] = null;\n    }\n    return input => {\n      const output = [];\n      // ---------------------------------------------\n      // handle property signatures\n      // ---------------------------------------------\n      for (let i = 0; i < propertySignaturesTypes.length; i++) {\n        const ps = ast.propertySignatures[i];\n        const name = ps.name;\n        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {\n          continue;\n        }\n        output.push(`${Inspectable.formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`);\n      }\n      // ---------------------------------------------\n      // handle index signatures\n      // ---------------------------------------------\n      if (indexSignatureTypes.length > 0) {\n        for (let i = 0; i < indexSignatureTypes.length; i++) {\n          const type = indexSignatureTypes[i];\n          const keys = util_.getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);\n          for (const key of keys) {\n            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n              continue;\n            }\n            output.push(`${Inspectable.formatPropertyKey(key)}: ${type(input[key])}`);\n          }\n        }\n      }\n      return Arr.isNonEmptyReadonlyArray(output) ? \"{ \" + output.join(\", \") + \" }\" : \"{}\";\n    };\n  },\n  \"Union\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast);\n    if (Option.isSome(hook)) {\n      return hook.value();\n    }\n    const types = ast.types.map(ast => [ParseResult.is({\n      ast\n    }), go(ast, path)]);\n    return a => {\n      const index = types.findIndex(([is]) => is(a));\n      if (index === -1) {\n        throw new Error(errors_.getPrettyNoMatchingSchemaErrorMessage(a, path, ast));\n      }\n      return types[index][1](a);\n    };\n  },\n  \"Suspend\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => {\n        const get = util_.memoizeThunk(() => go(ast.f(), path));\n        return a => get()(a);\n      },\n      onSome: handler => handler()\n    });\n  },\n  \"Refinement\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => go(ast.from, path),\n      onSome: handler => handler()\n    });\n  },\n  \"Transformation\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => go(ast.to, path),\n      onSome: handler => handler()\n    });\n  }\n};\nconst compile = /*#__PURE__*/AST.getCompiler(match);\n//# sourceMappingURL=Pretty.js.map",
      "start": 1768772628414,
      "end": 1768772628414
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628414,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
