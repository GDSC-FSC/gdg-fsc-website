{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/superjson/dist/plainer.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { isArray, isEmptyObject, isError, isMap, isPlainObject, isPrimitive, isSet, } from './is.js';\nimport { escapeKey, stringifyPath } from './pathstringifier.js';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue, } from './transformer.js';\nimport { includes, forEach } from './util.js';\nimport { parsePath } from './pathstringifier.js';\nimport { getDeep, setDeep } from './accessDeep.js';\nconst enableLegacyPaths = (version) => version < 1;\nfunction traverse(tree, walker, version, origin = []) {\n    if (!tree) {\n        return;\n    }\n    const legacyPaths = enableLegacyPaths(version);\n    if (!isArray(tree)) {\n        forEach(tree, (subtree, key) => traverse(subtree, walker, version, [\n            ...origin,\n            ...parsePath(key, legacyPaths),\n        ]));\n        return;\n    }\n    const [nodeValue, children] = tree;\n    if (children) {\n        forEach(children, (child, key) => {\n            traverse(child, walker, version, [\n                ...origin,\n                ...parsePath(key, legacyPaths),\n            ]);\n        });\n    }\n    walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, version, superJson) {\n    traverse(annotations, (type, path) => {\n        plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n    }, version);\n    return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations, version) {\n    const legacyPaths = enableLegacyPaths(version);\n    function apply(identicalPaths, path) {\n        const object = getDeep(plain, parsePath(path, legacyPaths));\n        identicalPaths\n            .map(path => parsePath(path, legacyPaths))\n            .forEach(identicalObjectPath => {\n            plain = setDeep(plain, identicalObjectPath, () => object);\n        });\n    }\n    if (isArray(annotations)) {\n        const [root, other] = annotations;\n        root.forEach(identicalPath => {\n            plain = setDeep(plain, parsePath(identicalPath, legacyPaths), () => plain);\n        });\n        if (other) {\n            forEach(other, apply);\n        }\n    }\n    else {\n        forEach(annotations, apply);\n    }\n    return plain;\n}\nconst isDeep = (object, superJson) => isPlainObject(object) ||\n    isArray(object) ||\n    isMap(object) ||\n    isSet(object) ||\n    isError(object) ||\n    isInstanceOfRegisteredClass(object, superJson);\nfunction addIdentity(object, path, identities) {\n    const existingSet = identities.get(object);\n    if (existingSet) {\n        existingSet.push(path);\n    }\n    else {\n        identities.set(object, [path]);\n    }\n}\nexport function generateReferentialEqualityAnnotations(identitites, dedupe) {\n    const result = {};\n    let rootEqualityPaths = undefined;\n    identitites.forEach(paths => {\n        if (paths.length <= 1) {\n            return;\n        }\n        // if we're not deduping, all of these objects continue existing.\n        // putting the shortest path first makes it easier to parse for humans\n        // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n        if (!dedupe) {\n            paths = paths\n                .map(path => path.map(String))\n                .sort((a, b) => a.length - b.length);\n        }\n        const [representativePath, ...identicalPaths] = paths;\n        if (representativePath.length === 0) {\n            rootEqualityPaths = identicalPaths.map(stringifyPath);\n        }\n        else {\n            result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);\n        }\n    });\n    if (rootEqualityPaths) {\n        if (isEmptyObject(result)) {\n            return [rootEqualityPaths];\n        }\n        else {\n            return [rootEqualityPaths, result];\n        }\n    }\n    else {\n        return isEmptyObject(result) ? undefined : result;\n    }\n}\nexport const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map()) => {\n    const primitive = isPrimitive(object);\n    if (!primitive) {\n        addIdentity(object, path, identities);\n        const seen = seenObjects.get(object);\n        if (seen) {\n            // short-circuit result if we've seen this object before\n            return dedupe\n                ? {\n                    transformedValue: null,\n                }\n                : seen;\n        }\n    }\n    if (!isDeep(object, superJson)) {\n        const transformed = transformValue(object, superJson);\n        const result = transformed\n            ? {\n                transformedValue: transformed.value,\n                annotations: [transformed.type],\n            }\n            : {\n                transformedValue: object,\n            };\n        if (!primitive) {\n            seenObjects.set(object, result);\n        }\n        return result;\n    }\n    if (includes(objectsInThisPath, object)) {\n        // prevent circular references\n        return {\n            transformedValue: null,\n        };\n    }\n    const transformationResult = transformValue(object, superJson);\n    const transformed = transformationResult?.value ?? object;\n    const transformedValue = isArray(transformed) ? [] : {};\n    const innerAnnotations = {};\n    forEach(transformed, (value, index) => {\n        if (index === '__proto__' ||\n            index === 'constructor' ||\n            index === 'prototype') {\n            throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);\n        }\n        const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);\n        transformedValue[index] = recursiveResult.transformedValue;\n        if (isArray(recursiveResult.annotations)) {\n            innerAnnotations[escapeKey(index)] = recursiveResult.annotations;\n        }\n        else if (isPlainObject(recursiveResult.annotations)) {\n            forEach(recursiveResult.annotations, (tree, key) => {\n                innerAnnotations[escapeKey(index) + '.' + key] = tree;\n            });\n        }\n    });\n    const result = isEmptyObject(innerAnnotations)\n        ? {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type]\n                : undefined,\n        }\n        : {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type, innerAnnotations]\n                : innerAnnotations,\n        };\n    if (!primitive) {\n        seenObjects.set(object, result);\n    }\n    return result;\n};\n//# sourceMappingURL=plainer.js.map",
      "start": 1768772628550,
      "end": 1768772628550
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628550,
      "end": 1768772628554,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628578,
      "end": 1768772628581,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628608,
      "end": 1768772628612,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628634,
      "end": 1768772628638,
      "order": "post-post"
    }
  ]
}
