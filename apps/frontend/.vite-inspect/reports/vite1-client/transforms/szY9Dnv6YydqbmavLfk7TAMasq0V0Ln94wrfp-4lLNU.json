{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/effect/circular.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Duration from \"../../Duration.js\";\nimport * as Effectable from \"../../Effectable.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Exit from \"../../Exit.js\";\nimport * as FiberId from \"../../FiberId.js\";\nimport { dual, pipe } from \"../../Function.js\";\nimport * as Hash from \"../../Hash.js\";\nimport * as MutableHashMap from \"../../MutableHashMap.js\";\nimport * as Option from \"../../Option.js\";\nimport { pipeArguments } from \"../../Pipeable.js\";\nimport * as Predicate from \"../../Predicate.js\";\nimport * as Readable from \"../../Readable.js\";\nimport { currentScheduler } from \"../../Scheduler.js\";\nimport * as internalCause from \"../cause.js\";\nimport * as effect from \"../core-effect.js\";\nimport * as core from \"../core.js\";\nimport * as internalFiber from \"../fiber.js\";\nimport * as fiberRuntime from \"../fiberRuntime.js\";\nimport { globalScope } from \"../fiberScope.js\";\nimport * as internalRef from \"../ref.js\";\nimport * as supervisor from \"../supervisor.js\";\n/** @internal */\nclass Semaphore {\n  permits;\n  waiters = /*#__PURE__*/new Set();\n  taken = 0;\n  constructor(permits) {\n    this.permits = permits;\n  }\n  get free() {\n    return this.permits - this.taken;\n  }\n  take = n => core.asyncInterrupt(resume => {\n    if (this.free < n) {\n      const observer = () => {\n        if (this.free < n) {\n          return;\n        }\n        this.waiters.delete(observer);\n        this.taken += n;\n        resume(core.succeed(n));\n      };\n      this.waiters.add(observer);\n      return core.sync(() => {\n        this.waiters.delete(observer);\n      });\n    }\n    this.taken += n;\n    return resume(core.succeed(n));\n  });\n  updateTakenUnsafe(fiber, f) {\n    this.taken = f(this.taken);\n    if (this.waiters.size > 0) {\n      fiber.getFiberRef(currentScheduler).scheduleTask(() => {\n        const iter = this.waiters.values();\n        let item = iter.next();\n        while (item.done === false && this.free > 0) {\n          item.value();\n          item = iter.next();\n        }\n      }, fiber.getFiberRef(core.currentSchedulingPriority));\n    }\n    return core.succeed(this.free);\n  }\n  updateTaken(f) {\n    return core.withFiberRuntime(fiber => this.updateTakenUnsafe(fiber, f));\n  }\n  resize = permits => core.asVoid(core.withFiberRuntime(fiber => {\n    this.permits = permits;\n    if (this.free < 0) {\n      return core.void;\n    }\n    return this.updateTakenUnsafe(fiber, taken => taken);\n  }));\n  release = n => this.updateTaken(taken => taken - n);\n  releaseAll = /*#__PURE__*/this.updateTaken(_ => 0);\n  withPermits = n => self => core.uninterruptibleMask(restore => core.flatMap(restore(this.take(n)), permits => fiberRuntime.ensuring(restore(self), this.release(permits))));\n  withPermitsIfAvailable = n => self => core.uninterruptibleMask(restore => core.suspend(() => {\n    if (this.free < n) {\n      return effect.succeedNone;\n    }\n    this.taken += n;\n    return fiberRuntime.ensuring(restore(effect.asSome(self)), this.release(n));\n  }));\n}\n/** @internal */\nexport const unsafeMakeSemaphore = permits => new Semaphore(permits);\n/** @internal */\nexport const makeSemaphore = permits => core.sync(() => unsafeMakeSemaphore(permits));\nclass Latch extends Effectable.Class {\n  isOpen;\n  waiters = [];\n  scheduled = false;\n  constructor(isOpen) {\n    super();\n    this.isOpen = isOpen;\n  }\n  commit() {\n    return this.await;\n  }\n  unsafeSchedule(fiber) {\n    if (this.scheduled || this.waiters.length === 0) {\n      return core.void;\n    }\n    this.scheduled = true;\n    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(core.currentSchedulingPriority));\n    return core.void;\n  }\n  flushWaiters = () => {\n    this.scheduled = false;\n    const waiters = this.waiters;\n    this.waiters = [];\n    for (let i = 0; i < waiters.length; i++) {\n      waiters[i](core.exitVoid);\n    }\n  };\n  open = /*#__PURE__*/core.withFiberRuntime(fiber => {\n    if (this.isOpen) {\n      return core.void;\n    }\n    this.isOpen = true;\n    return this.unsafeSchedule(fiber);\n  });\n  unsafeOpen() {\n    if (this.isOpen) return;\n    this.isOpen = true;\n    this.flushWaiters();\n  }\n  release = /*#__PURE__*/core.withFiberRuntime(fiber => {\n    if (this.isOpen) {\n      return core.void;\n    }\n    return this.unsafeSchedule(fiber);\n  });\n  await = /*#__PURE__*/core.asyncInterrupt(resume => {\n    if (this.isOpen) {\n      return resume(core.void);\n    }\n    this.waiters.push(resume);\n    return core.sync(() => {\n      const index = this.waiters.indexOf(resume);\n      if (index !== -1) {\n        this.waiters.splice(index, 1);\n      }\n    });\n  });\n  unsafeClose() {\n    this.isOpen = false;\n  }\n  close = /*#__PURE__*/core.sync(() => {\n    this.isOpen = false;\n  });\n  whenOpen = self => {\n    return core.zipRight(this.await, self);\n  };\n}\n/** @internal */\nexport const unsafeMakeLatch = open => new Latch(open ?? false);\n/** @internal */\nexport const makeLatch = open => core.sync(() => unsafeMakeLatch(open));\n/** @internal */\nexport const awaitAllChildren = self => ensuringChildren(self, fiberRuntime.fiberAwaitAll);\n/** @internal */\nexport const cached = /*#__PURE__*/dual(2, (self, timeToLive) => core.map(cachedInvalidateWithTTL(self, timeToLive), tuple => tuple[0]));\n/** @internal */\nexport const cachedInvalidateWithTTL = /*#__PURE__*/dual(2, (self, timeToLive) => {\n  const duration = Duration.decode(timeToLive);\n  return core.flatMap(core.context(), env => core.map(makeSynchronized(Option.none()), cache => [core.provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));\n});\n/** @internal */\nconst computeCachedValue = (self, timeToLive, start) => {\n  const timeToLiveMillis = Duration.toMillis(Duration.decode(timeToLive));\n  return pipe(core.deferredMake(), core.tap(deferred => core.intoDeferred(self, deferred)), core.map(deferred => Option.some([start + timeToLiveMillis, deferred])));\n};\n/** @internal */\nconst getCachedValue = (self, timeToLive, cache) => core.uninterruptibleMask(restore => pipe(effect.clockWith(clock => clock.currentTimeMillis), core.flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Option.some(computeCachedValue(self, timeToLive, time));\n      }\n    case \"Some\":\n      {\n        const [end] = option.value;\n        return end - time <= 0 ? Option.some(computeCachedValue(self, timeToLive, time)) : Option.none();\n      }\n  }\n})), core.flatMap(option => Option.isNone(option) ? core.dieMessage(\"BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues\") : restore(core.deferredAwait(option.value[1])))));\n/** @internal */\nconst invalidateCache = cache => internalRef.set(cache, Option.none());\n/** @internal */\nexport const ensuringChild = /*#__PURE__*/dual(2, (self, f) => ensuringChildren(self, children => f(fiberRuntime.fiberAll(children))));\n/** @internal */\nexport const ensuringChildren = /*#__PURE__*/dual(2, (self, children) => core.flatMap(supervisor.track, supervisor => pipe(supervised(self, supervisor), fiberRuntime.ensuring(core.flatMap(supervisor.value, children)))));\n/** @internal */\nexport const forkAll = /*#__PURE__*/dual(args => Predicate.isIterable(args[0]), (effects, options) => options?.discard ? core.forEachSequentialDiscard(effects, fiberRuntime.fork) : core.map(core.forEachSequential(effects, fiberRuntime.fork), fiberRuntime.fiberAll));\n/** @internal */\nexport const forkIn = /*#__PURE__*/dual(2, (self, scope) => core.withFiberRuntime((parent, parentStatus) => {\n  const scopeImpl = scope;\n  const fiber = fiberRuntime.unsafeFork(self, parent, parentStatus.runtimeFlags, globalScope);\n  if (scopeImpl.state._tag === \"Open\") {\n    const finalizer = () => core.fiberIdWith(fiberId => Equal.equals(fiberId, fiber.id()) ? core.void : core.asVoid(core.interruptFiber(fiber)));\n    const key = {};\n    scopeImpl.state.finalizers.set(key, finalizer);\n    fiber.addObserver(() => {\n      if (scopeImpl.state._tag === \"Closed\") return;\n      scopeImpl.state.finalizers.delete(key);\n    });\n  } else {\n    fiber.unsafeInterruptAsFork(parent.id());\n  }\n  return core.succeed(fiber);\n}));\n/** @internal */\nexport const forkScoped = self => fiberRuntime.scopeWith(scope => forkIn(self, scope));\n/** @internal */\nexport const fromFiber = fiber => internalFiber.join(fiber);\n/** @internal */\nexport const fromFiberEffect = fiber => core.suspend(() => core.flatMap(fiber, internalFiber.join));\nconst memoKeySymbol = /*#__PURE__*/Symbol.for(\"effect/Effect/memoizeFunction.key\");\nclass Key {\n  a;\n  eq;\n  [memoKeySymbol] = memoKeySymbol;\n  constructor(a, eq) {\n    this.a = a;\n    this.eq = eq;\n  }\n  [Equal.symbol](that) {\n    if (Predicate.hasProperty(that, memoKeySymbol)) {\n      if (this.eq) {\n        return this.eq(this.a, that.a);\n      } else {\n        return Equal.equals(this.a, that.a);\n      }\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return this.eq ? 0 : Hash.cached(this, Hash.hash(this.a));\n  }\n}\n/** @internal */\nexport const cachedFunction = (f, eq) => {\n  return pipe(core.sync(() => MutableHashMap.empty()), core.flatMap(makeSynchronized), core.map(ref => a => pipe(ref.modifyEffect(map => {\n    const result = pipe(map, MutableHashMap.get(new Key(a, eq)));\n    if (Option.isNone(result)) {\n      return pipe(core.deferredMake(), core.tap(deferred => pipe(effect.diffFiberRefs(f(a)), core.intoDeferred(deferred), fiberRuntime.fork)), core.map(deferred => [deferred, pipe(map, MutableHashMap.set(new Key(a, eq), deferred))]));\n    }\n    return core.succeed([result.value, map]);\n  }), core.flatMap(core.deferredAwait), core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b))))));\n};\n/** @internal */\nexport const raceFirst = /*#__PURE__*/dual(2, (self, that) => pipe(core.exit(self), fiberRuntime.race(core.exit(that)), effect => core.flatten(effect)));\n/** @internal */\nexport const supervised = /*#__PURE__*/dual(2, (self, supervisor) => {\n  const supervise = core.fiberRefLocallyWith(fiberRuntime.currentSupervisor, s => s.zip(supervisor));\n  return supervise(self);\n});\n/** @internal */\nexport const timeout = /*#__PURE__*/dual(2, (self, duration) => timeoutFail(self, {\n  onTimeout: () => core.timeoutExceptionFromDuration(duration),\n  duration\n}));\n/** @internal */\nexport const timeoutFail = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onTimeout\n}) => core.flatten(timeoutTo(self, {\n  onTimeout: () => core.failSync(onTimeout),\n  onSuccess: core.succeed,\n  duration\n})));\n/** @internal */\nexport const timeoutFailCause = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onTimeout\n}) => core.flatten(timeoutTo(self, {\n  onTimeout: () => core.failCauseSync(onTimeout),\n  onSuccess: core.succeed,\n  duration\n})));\n/** @internal */\nexport const timeoutOption = /*#__PURE__*/dual(2, (self, duration) => timeoutTo(self, {\n  duration,\n  onSuccess: Option.some,\n  onTimeout: Option.none\n}));\n/** @internal */\nexport const timeoutTo = /*#__PURE__*/dual(2, (self, {\n  duration,\n  onSuccess,\n  onTimeout\n}) => core.fiberIdWith(parentFiberId => core.uninterruptibleMask(restore => fiberRuntime.raceFibersWith(restore(self), core.interruptible(effect.sleep(duration)), {\n  onSelfWin: (winner, loser) => core.flatMap(winner.await, exit => {\n    if (exit._tag === \"Success\") {\n      return core.flatMap(winner.inheritAll, () => core.as(core.interruptAsFiber(loser, parentFiberId), onSuccess(exit.value)));\n    } else {\n      return core.flatMap(core.interruptAsFiber(loser, parentFiberId), () => core.exitFailCause(exit.cause));\n    }\n  }),\n  onOtherWin: (winner, loser) => core.flatMap(winner.await, exit => {\n    if (exit._tag === \"Success\") {\n      return core.flatMap(winner.inheritAll, () => core.as(core.interruptAsFiber(loser, parentFiberId), onTimeout()));\n    } else {\n      return core.flatMap(core.interruptAsFiber(loser, parentFiberId), () => core.exitFailCause(exit.cause));\n    }\n  }),\n  otherScope: globalScope\n}))));\n// circular with Synchronized\n/** @internal */\nconst SynchronizedSymbolKey = \"effect/Ref/SynchronizedRef\";\n/** @internal */\nexport const SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);\n/** @internal */\nexport const synchronizedVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nclass SynchronizedImpl extends Effectable.Class {\n  ref;\n  withLock;\n  [SynchronizedTypeId] = synchronizedVariance;\n  [internalRef.RefTypeId] = internalRef.refVariance;\n  [Readable.TypeId] = Readable.TypeId;\n  constructor(ref, withLock) {\n    super();\n    this.ref = ref;\n    this.withLock = withLock;\n    this.get = internalRef.get(this.ref);\n  }\n  get;\n  commit() {\n    return this.get;\n  }\n  modify(f) {\n    return this.modifyEffect(a => core.succeed(f(a)));\n  }\n  modifyEffect(f) {\n    return this.withLock(pipe(core.flatMap(internalRef.get(this.ref), f), core.flatMap(([b, a]) => core.as(internalRef.set(this.ref, a), b))));\n  }\n}\n/** @internal */\nexport const makeSynchronized = value => core.sync(() => unsafeMakeSynchronized(value));\n/** @internal */\nexport const unsafeMakeSynchronized = value => {\n  const ref = internalRef.unsafeMake(value);\n  const sem = unsafeMakeSemaphore(1);\n  return new SynchronizedImpl(ref, sem.withPermits(1));\n};\n/** @internal */\nexport const updateSomeAndGetEffectSynchronized = /*#__PURE__*/dual(2, (self, pf) => self.modifyEffect(value => {\n  const result = pf(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, a => [a, a]);\n      }\n  }\n}));\n// circular with Fiber\n/** @internal */\nexport const zipFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));\n/** @internal */\nexport const zipLeftFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));\n/** @internal */\nexport const zipRightFiber = /*#__PURE__*/dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));\n/** @internal */\nexport const zipWithFiber = /*#__PURE__*/dual(3, (self, that, f) => ({\n  ...Effectable.CommitPrototype,\n  commit() {\n    return internalFiber.join(this);\n  },\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => pipe(self.id(), FiberId.getOrElse(that.id())),\n  await: pipe(self.await, core.flatten, fiberRuntime.zipWithOptions(core.flatten(that.await), f, {\n    concurrent: true\n  }), core.exit),\n  children: self.children,\n  inheritAll: core.zipRight(that.inheritAll, self.inheritAll),\n  poll: core.zipWith(self.poll, that.poll, (optionA, optionB) => pipe(optionA, Option.flatMap(exitA => pipe(optionB, Option.map(exitB => Exit.zipWith(exitA, exitB, {\n    onSuccess: f,\n    onFailure: internalCause.parallel\n  })))))),\n  interruptAsFork: id => core.zipRight(self.interruptAsFork(id), that.interruptAsFork(id)),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}));\n/* @internal */\nexport const bindAll = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, f, options) => core.flatMap(self, a => fiberRuntime.all(f(a), options).pipe(core.map(record => Object.assign({}, a, record)))));\n//# sourceMappingURL=circular.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
