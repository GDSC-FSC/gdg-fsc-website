{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Cron.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Arr from \"./Array.js\";\nimport * as Data from \"./Data.js\";\nimport * as Either from \"./Either.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as equivalence from \"./Equivalence.js\";\nimport { constVoid, dual, identity, pipe } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol } from \"./Inspectable.js\";\nimport * as dateTime from \"./internal/dateTime.js\";\nimport * as N from \"./Number.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nimport * as String from \"./String.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Cron\");\nconst CronProto = {\n  [TypeId]: TypeId,\n  [Equal.symbol](that) {\n    return isCron(that) && equals(this, that);\n  },\n  [Hash.symbol]() {\n    return pipe(Hash.hash(this.tz), Hash.combine(Hash.array(Arr.fromIterable(this.seconds))), Hash.combine(Hash.array(Arr.fromIterable(this.minutes))), Hash.combine(Hash.array(Arr.fromIterable(this.hours))), Hash.combine(Hash.array(Arr.fromIterable(this.days))), Hash.combine(Hash.array(Arr.fromIterable(this.months))), Hash.combine(Hash.array(Arr.fromIterable(this.weekdays))), Hash.cached(this));\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Cron\",\n      tz: this.tz,\n      seconds: Arr.fromIterable(this.seconds),\n      minutes: Arr.fromIterable(this.minutes),\n      hours: Arr.fromIterable(this.hours),\n      days: Arr.fromIterable(this.days),\n      months: Arr.fromIterable(this.months),\n      weekdays: Arr.fromIterable(this.weekdays)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/**\n * Checks if a given value is a `Cron` instance.\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isCron = u => hasProperty(u, TypeId);\n/**\n * Creates a `Cron` instance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = values => {\n  const o = Object.create(CronProto);\n  o.seconds = new Set(Arr.sort(values.seconds ?? [0], N.Order));\n  o.minutes = new Set(Arr.sort(values.minutes, N.Order));\n  o.hours = new Set(Arr.sort(values.hours, N.Order));\n  o.days = new Set(Arr.sort(values.days, N.Order));\n  o.months = new Set(Arr.sort(values.months, N.Order));\n  o.weekdays = new Set(Arr.sort(values.weekdays, N.Order));\n  o.tz = Option.fromNullable(values.tz);\n  const seconds = Array.from(o.seconds);\n  const minutes = Array.from(o.minutes);\n  const hours = Array.from(o.hours);\n  const days = Array.from(o.days);\n  const months = Array.from(o.months);\n  const weekdays = Array.from(o.weekdays);\n  o.first = {\n    second: seconds[0] ?? 0,\n    minute: minutes[0] ?? 0,\n    hour: hours[0] ?? 0,\n    day: days[0] ?? 1,\n    month: (months[0] ?? 1) - 1,\n    weekday: weekdays[0] ?? 0\n  };\n  o.next = {\n    second: nextLookupTable(seconds, 60),\n    minute: nextLookupTable(minutes, 60),\n    hour: nextLookupTable(hours, 24),\n    day: nextLookupTable(days, 32),\n    month: nextLookupTable(months, 13),\n    weekday: nextLookupTable(weekdays, 7)\n  };\n  return o;\n};\nconst nextLookupTable = (values, size) => {\n  const result = new Array(size).fill(undefined);\n  if (values.length === 0) {\n    return result;\n  }\n  let current = undefined;\n  let index = values.length - 1;\n  for (let i = size - 1; i >= 0; i--) {\n    while (index >= 0 && values[index] >= i) {\n      current = values[index--];\n    }\n    result[i] = current;\n  }\n  return result;\n};\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const ParseErrorTypeId = /*#__PURE__*/Symbol.for(\"effect/Cron/errors/ParseError\");\n/**\n * Represents a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category models\n */\nexport class ParseError extends /*#__PURE__*/Data.TaggedError(\"CronParseError\") {\n  /**\n   * @since 2.0.0\n   */\n  [ParseErrorTypeId] = ParseErrorTypeId;\n}\n/**\n * Returns `true` if the specified value is an `ParseError`, `false` otherwise.\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isParseError = u => hasProperty(u, ParseErrorTypeId);\n/**\n * Parses a cron expression into a `Cron` instance.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * // At 04:00 on every day-of-month from 8 through 14.\n * assert.deepStrictEqual(Cron.parse(\"0 0 4 8-14 * *\"), Either.right(Cron.make({\n *   seconds: [0],\n *   minutes: [0],\n *   hours: [4],\n *   days: [8, 9, 10, 11, 12, 13, 14],\n *   months: [],\n *   weekdays: []\n * })))\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const parse = (cron, tz) => {\n  const segments = cron.split(\" \").filter(String.isNonEmpty);\n  if (segments.length !== 5 && segments.length !== 6) {\n    return Either.left(new ParseError({\n      message: `Invalid number of segments in cron expression`,\n      input: cron\n    }));\n  }\n  if (segments.length === 5) {\n    segments.unshift(\"0\");\n  }\n  const [seconds, minutes, hours, days, months, weekdays] = segments;\n  const zone = tz === undefined || dateTime.isTimeZone(tz) ? Either.right(tz) : Either.fromOption(dateTime.zoneFromString(tz), () => new ParseError({\n    message: `Invalid time zone in cron expression`,\n    input: tz\n  }));\n  return Either.all({\n    tz: zone,\n    seconds: parseSegment(seconds, secondOptions),\n    minutes: parseSegment(minutes, minuteOptions),\n    hours: parseSegment(hours, hourOptions),\n    days: parseSegment(days, dayOptions),\n    months: parseSegment(months, monthOptions),\n    weekdays: parseSegment(weekdays, weekdayOptions)\n  }).pipe(Either.map(make));\n};\n/**\n * Parses a cron expression into a `Cron` instance.\n *\n * **Details**\n *\n * This function takes a cron expression as a string and attempts to parse it\n * into a `Cron` instance. If the expression is valid, the resulting `Cron`\n * instance will represent the schedule defined by the cron expression.\n *\n * If the expression is invalid, the function throws a `ParseError`.\n *\n * You can optionally provide a time zone (`tz`) to interpret the cron\n * expression in a specific time zone. If no time zone is provided, the cron\n * expression will use the default time zone.\n *\n * @example\n * ```ts\n * import { Cron } from \"effect\"\n *\n * // At 04:00 on every day-of-month from 8 through 14.\n * console.log(Cron.unsafeParse(\"0 4 8-14 * *\"))\n * // Output:\n * // {\n * //   _id: 'Cron',\n * //   tz: { _id: 'Option', _tag: 'None' },\n * //   seconds: [ 0 ],\n * //   minutes: [ 0 ],\n * //   hours: [ 4 ],\n * //   days: [\n * //      8,  9, 10, 11,\n * //     12, 13, 14\n * //   ],\n * //   months: [],\n * //   weekdays: []\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeParse = (cron, tz) => Either.getOrThrowWith(parse(cron, tz), identity);\n/**\n * Checks if a given `Date` falls within an active `Cron` time window.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * const cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\n * assert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 04:00:00\")), true)\n * assert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 05:00:00\")), false)\n * ```\n *\n * @throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.\n *\n * @since 2.0.0\n */\nexport const match = (cron, date) => {\n  const parts = dateTime.unsafeMakeZoned(date, {\n    timeZone: Option.getOrUndefined(cron.tz)\n  }).pipe(dateTime.toParts);\n  if (cron.seconds.size !== 0 && !cron.seconds.has(parts.seconds)) {\n    return false;\n  }\n  if (cron.minutes.size !== 0 && !cron.minutes.has(parts.minutes)) {\n    return false;\n  }\n  if (cron.hours.size !== 0 && !cron.hours.has(parts.hours)) {\n    return false;\n  }\n  if (cron.months.size !== 0 && !cron.months.has(parts.month)) {\n    return false;\n  }\n  if (cron.days.size === 0 && cron.weekdays.size === 0) {\n    return true;\n  }\n  if (cron.weekdays.size === 0) {\n    return cron.days.has(parts.day);\n  }\n  if (cron.days.size === 0) {\n    return cron.weekdays.has(parts.weekDay);\n  }\n  return cron.days.has(parts.day) || cron.weekdays.has(parts.weekDay);\n};\nconst daysInMonth = date => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)).getUTCDate();\n/**\n * Returns the next run `Date` for the given `Cron` instance.\n *\n * Uses the current time as a starting point if no value is provided for `now`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * const after = new Date(\"2021-01-01 00:00:00\")\n * const cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\n * assert.deepStrictEqual(Cron.next(cron, after), new Date(\"2021-01-08 04:00:00\"))\n * ```\n *\n * @throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.\n * @throws `Error` if the next run date cannot be found within 10,000 iterations.\n *\n * @since 2.0.0\n */\nexport const next = (cron, startFrom) => {\n  const tz = Option.getOrUndefined(cron.tz);\n  const zoned = dateTime.unsafeMakeZoned(startFrom ?? new Date(), {\n    timeZone: tz\n  });\n  const utc = tz !== undefined && dateTime.isTimeZoneNamed(tz) && tz.id === \"UTC\";\n  const adjustDst = utc ? constVoid : current => {\n    const adjusted = dateTime.unsafeMakeZoned(current, {\n      timeZone: zoned.zone,\n      adjustForTimeZone: true\n    }).pipe(dateTime.toDate);\n    // TODO: This implementation currently only skips forward when transitioning into daylight savings time.\n    const drift = current.getTime() - adjusted.getTime();\n    if (drift > 0) {\n      current.setTime(current.getTime() + drift);\n    }\n  };\n  const result = dateTime.mutate(zoned, current => {\n    current.setUTCSeconds(current.getUTCSeconds() + 1, 0);\n    for (let i = 0; i < 10_000; i++) {\n      if (cron.seconds.size !== 0) {\n        const currentSecond = current.getUTCSeconds();\n        const nextSecond = cron.next.second[currentSecond];\n        if (nextSecond === undefined) {\n          current.setUTCMinutes(current.getUTCMinutes() + 1, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n        if (nextSecond > currentSecond) {\n          current.setUTCSeconds(nextSecond);\n          adjustDst(current);\n          continue;\n        }\n      }\n      if (cron.minutes.size !== 0) {\n        const currentMinute = current.getUTCMinutes();\n        const nextMinute = cron.next.minute[currentMinute];\n        if (nextMinute === undefined) {\n          current.setUTCHours(current.getUTCHours() + 1, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n        if (nextMinute > currentMinute) {\n          current.setUTCMinutes(nextMinute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n      }\n      if (cron.hours.size !== 0) {\n        const currentHour = current.getUTCHours();\n        const nextHour = cron.next.hour[currentHour];\n        if (nextHour === undefined) {\n          current.setUTCDate(current.getUTCDate() + 1);\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n        if (nextHour > currentHour) {\n          current.setUTCHours(nextHour, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n      }\n      if (cron.weekdays.size !== 0 || cron.days.size !== 0) {\n        let a = Infinity;\n        let b = Infinity;\n        if (cron.weekdays.size !== 0) {\n          const currentWeekday = current.getUTCDay();\n          const nextWeekday = cron.next.weekday[currentWeekday];\n          a = nextWeekday === undefined ? 7 - currentWeekday + cron.first.weekday : nextWeekday - currentWeekday;\n        }\n        if (cron.days.size !== 0 && a !== 0) {\n          const currentDay = current.getUTCDate();\n          const nextDay = cron.next.day[currentDay];\n          b = nextDay === undefined ? daysInMonth(current) - currentDay + cron.first.day : nextDay - currentDay;\n        }\n        const addDays = Math.min(a, b);\n        if (addDays !== 0) {\n          current.setUTCDate(current.getUTCDate() + addDays);\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n      }\n      if (cron.months.size !== 0) {\n        const currentMonth = current.getUTCMonth() + 1;\n        const nextMonth = cron.next.month[currentMonth];\n        if (nextMonth === undefined) {\n          current.setUTCFullYear(current.getUTCFullYear() + 1);\n          current.setUTCMonth(cron.first.month, cron.first.day);\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n        if (nextMonth > currentMonth) {\n          current.setUTCMonth(nextMonth - 1, cron.first.day);\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);\n          adjustDst(current);\n          continue;\n        }\n      }\n      return;\n    }\n    throw new Error(\"Unable to find next cron date\");\n  });\n  return dateTime.toDateUtc(result);\n};\n/**\n * Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.\n *\n * @since 2.0.0\n */\nexport const sequence = function* (cron, startFrom) {\n  while (true) {\n    yield startFrom = next(cron, startFrom);\n  }\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence = /*#__PURE__*/equivalence.make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));\nconst restrictionsArrayEquals = /*#__PURE__*/equivalence.array(equivalence.number);\nconst restrictionsEquals = (self, that) => restrictionsArrayEquals(Arr.fromIterable(self), Arr.fromIterable(that));\n/**\n * Checks if two `Cron`s are equal.\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(self, that));\nconst secondOptions = {\n  min: 0,\n  max: 59\n};\nconst minuteOptions = {\n  min: 0,\n  max: 59\n};\nconst hourOptions = {\n  min: 0,\n  max: 23\n};\nconst dayOptions = {\n  min: 1,\n  max: 31\n};\nconst monthOptions = {\n  min: 1,\n  max: 12,\n  aliases: {\n    jan: 1,\n    feb: 2,\n    mar: 3,\n    apr: 4,\n    may: 5,\n    jun: 6,\n    jul: 7,\n    aug: 8,\n    sep: 9,\n    oct: 10,\n    nov: 11,\n    dec: 12\n  }\n};\nconst weekdayOptions = {\n  min: 0,\n  max: 6,\n  aliases: {\n    sun: 0,\n    mon: 1,\n    tue: 2,\n    wed: 3,\n    thu: 4,\n    fri: 5,\n    sat: 6\n  }\n};\nconst parseSegment = (input, options) => {\n  const capacity = options.max - options.min + 1;\n  const values = new Set();\n  const fields = input.split(\",\");\n  for (const field of fields) {\n    const [raw, step] = splitStep(field);\n    if (raw === \"*\" && step === undefined) {\n      return Either.right(new Set());\n    }\n    if (step !== undefined) {\n      if (!Number.isInteger(step)) {\n        return Either.left(new ParseError({\n          message: `Expected step value to be a positive integer`,\n          input\n        }));\n      }\n      if (step < 1) {\n        return Either.left(new ParseError({\n          message: `Expected step value to be greater than 0`,\n          input\n        }));\n      }\n      if (step > options.max) {\n        return Either.left(new ParseError({\n          message: `Expected step value to be less than ${options.max}`,\n          input\n        }));\n      }\n    }\n    if (raw === \"*\") {\n      for (let i = options.min; i <= options.max; i += step ?? 1) {\n        values.add(i);\n      }\n    } else {\n      const [left, right] = splitRange(raw, options.aliases);\n      if (!Number.isInteger(left)) {\n        return Either.left(new ParseError({\n          message: `Expected a positive integer`,\n          input\n        }));\n      }\n      if (left < options.min || left > options.max) {\n        return Either.left(new ParseError({\n          message: `Expected a value between ${options.min} and ${options.max}`,\n          input\n        }));\n      }\n      if (right === undefined) {\n        values.add(left);\n      } else {\n        if (!Number.isInteger(right)) {\n          return Either.left(new ParseError({\n            message: `Expected a positive integer`,\n            input\n          }));\n        }\n        if (right < options.min || right > options.max) {\n          return Either.left(new ParseError({\n            message: `Expected a value between ${options.min} and ${options.max}`,\n            input\n          }));\n        }\n        if (left > right) {\n          return Either.left(new ParseError({\n            message: `Invalid value range`,\n            input\n          }));\n        }\n        for (let i = left; i <= right; i += step ?? 1) {\n          values.add(i);\n        }\n      }\n    }\n    if (values.size >= capacity) {\n      return Either.right(new Set());\n    }\n  }\n  return Either.right(values);\n};\nconst splitStep = input => {\n  const seperator = input.indexOf(\"/\");\n  if (seperator !== -1) {\n    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];\n  }\n  return [input, undefined];\n};\nconst splitRange = (input, aliases) => {\n  const seperator = input.indexOf(\"-\");\n  if (seperator !== -1) {\n    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];\n  }\n  return [aliasOrValue(input, aliases), undefined];\n};\nfunction aliasOrValue(field, aliases) {\n  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);\n}\n//# sourceMappingURL=Cron.js.map",
      "start": 1768772628411,
      "end": 1768772628411
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628411,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628420,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
