{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Sink.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as internal from \"./internal/sink.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SinkTypeId = internal.SinkTypeId;\n/**\n * Replaces this sink's result with the provided value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const as = internal.as;\n/**\n * A sink that collects all elements into a `Chunk`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAll = internal.collectAll;\n/**\n * A sink that collects first `n` elements into a chunk.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllN = internal.collectAllN;\n/**\n * Repeatedly runs the sink and accumulates its results into a `Chunk`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const collectAllFrom = internal.collectAllFrom;\n/**\n * A sink that collects all of its inputs into a map. The keys are extracted\n * from inputs using the keying function `key`; if multiple inputs use the\n * same key, they are merged using the `merge` function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllToMap = internal.collectAllToMap;\n/**\n * A sink that collects first `n` keys into a map. The keys are calculated\n * from inputs using the keying function `key`; if multiple inputs use the the\n * same key, they are merged using the `merge` function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllToMapN = internal.collectAllToMapN;\n/**\n * A sink that collects all of its inputs into a set.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllToSet = internal.collectAllToSet;\n/**\n * A sink that collects first `n` distinct inputs into a set.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllToSetN = internal.collectAllToSetN;\n/**\n * Accumulates incoming elements into a chunk until predicate `p` is\n * satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllUntil = internal.collectAllUntil;\n/**\n * Accumulates incoming elements into a chunk until effectful predicate `p` is\n * satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllUntilEffect = internal.collectAllUntilEffect;\n/**\n * Accumulates incoming elements into a chunk as long as they verify predicate\n * `p`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllWhile = internal.collectAllWhile;\n/**\n * Accumulates incoming elements into a chunk as long as they verify effectful\n * predicate `p`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAllWhileEffect = internal.collectAllWhileEffect;\n/**\n * Repeatedly runs the sink for as long as its results satisfy the predicate\n * `p`. The sink's results will be accumulated using the stepping function `f`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const collectAllWhileWith = internal.collectAllWhileWith;\n/**\n * Collects the leftovers from the stream when the sink succeeds and returns\n * them as part of the sink's result.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const collectLeftover = internal.collectLeftover;\n/**\n * Transforms this sink's input elements.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput = internal.mapInput;\n/**\n * Effectfully transforms this sink's input elements.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInputEffect = internal.mapInputEffect;\n/**\n * Transforms this sink's input chunks. `f` must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInputChunks = internal.mapInputChunks;\n/**\n * Effectfully transforms this sink's input chunks. `f` must preserve\n * chunking-invariance.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInputChunksEffect = internal.mapInputChunksEffect;\n/**\n * A sink that counts the number of elements fed to it.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const count = internal.count;\n/**\n * Creates a sink halting with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const die = internal.die;\n/**\n * Creates a sink halting with the specified message, wrapped in a\n * `RuntimeException`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieMessage = internal.dieMessage;\n/**\n * Creates a sink halting with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieSync = internal.dieSync;\n/**\n * Transforms both inputs and result of this sink using the provided\n * functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const dimap = internal.dimap;\n/**\n * Effectfully transforms both inputs and result of this sink using the\n * provided functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const dimapEffect = internal.dimapEffect;\n/**\n * Transforms both input chunks and result of this sink using the provided\n * functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const dimapChunks = internal.dimapChunks;\n/**\n * Effectfully transforms both input chunks and result of this sink using the\n * provided functions. `f` and `g` must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const dimapChunksEffect = internal.dimapChunksEffect;\n/**\n * A sink that ignores its inputs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const drain = internal.drain;\n/**\n * Creates a sink that drops `n` elements.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const drop = internal.drop;\n/**\n * Drops incoming elements until the predicate is satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropUntil = internal.dropUntil;\n/**\n * Drops incoming elements until the effectful predicate is satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropUntilEffect = internal.dropUntilEffect;\n/**\n * Drops incoming elements as long as the predicate is satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropWhile = internal.dropWhile;\n/**\n * Drops incoming elements as long as the effectful predicate is satisfied.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dropWhileEffect = internal.dropWhileEffect;\n/**\n * Returns a new sink with an attached finalizer. The finalizer is guaranteed\n * to be executed so long as the sink begins execution (and regardless of\n * whether or not it completes).\n *\n * @since 2.0.0\n * @category finalization\n */\nexport const ensuring = internal.ensuring;\n/**\n * Returns a new sink with an attached finalizer. The finalizer is guaranteed\n * to be executed so long as the sink begins execution (and regardless of\n * whether or not it completes).\n *\n * @since 2.0.0\n * @category finalization\n */\nexport const ensuringWith = internal.ensuringWith;\n/**\n * Accesses the whole context of the sink.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const context = internal.context;\n/**\n * Accesses the context of the sink.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWith = internal.contextWith;\n/**\n * Accesses the context of the sink in the context of an effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWithEffect = internal.contextWithEffect;\n/**\n * Accesses the context of the sink in the context of a sink.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWithSink = internal.contextWithSink;\n/**\n * A sink that returns whether all elements satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const every = internal.every;\n/**\n * A sink that always fails with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail = internal.fail;\n/**\n * A sink that always fails with the specified lazily evaluated error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failSync = internal.failSync;\n/**\n * Creates a sink halting with a specified `Cause`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failCause = internal.failCause;\n/**\n * Creates a sink halting with a specified lazily evaluated `Cause`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failCauseSync = internal.failCauseSync;\n/**\n * Filters the sink's input with the given predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterInput = internal.filterInput;\n/**\n * Effectfully filter the input of this sink using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterInputEffect = internal.filterInputEffect;\n/**\n * Creates a sink that produces values until one verifies the predicate `f`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findEffect = internal.findEffect;\n/**\n * A sink that folds its inputs with the provided function, termination\n * predicate and initial state.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const fold = internal.fold;\n/**\n * Folds over the result of the sink\n *\n * @since 2.0.0\n * @category folding\n */\nexport const foldSink = internal.foldSink;\n/**\n * A sink that folds its input chunks with the provided function, termination\n * predicate and initial state. `contFn` condition is checked only for the\n * initial value and at the end of processing of each chunk. `f` and `contFn`\n * must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldChunks = internal.foldChunks;\n/**\n * A sink that effectfully folds its input chunks with the provided function,\n * termination predicate and initial state. `contFn` condition is checked only\n * for the initial value and at the end of processing of each chunk. `f` and\n * `contFn` must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldChunksEffect = internal.foldChunksEffect;\n/**\n * A sink that effectfully folds its inputs with the provided function,\n * termination predicate and initial state.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldEffect = internal.foldEffect;\n/**\n * A sink that folds its inputs with the provided function and initial state.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldLeft = internal.foldLeft;\n/**\n * A sink that folds its input chunks with the provided function and initial\n * state. `f` must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldLeftChunks = internal.foldLeftChunks;\n/**\n * A sink that effectfully folds its input chunks with the provided function\n * and initial state. `f` must preserve chunking-invariance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldLeftChunksEffect = internal.foldLeftChunksEffect;\n/**\n * A sink that effectfully folds its inputs with the provided function and\n * initial state.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldLeftEffect = internal.foldLeftEffect;\n/**\n * Creates a sink that folds elements of type `In` into a structure of type\n * `S` until `max` elements have been folded.\n *\n * Like `Sink.foldWeighted`, but with a constant cost function of `1`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldUntil = internal.foldUntil;\n/**\n * Creates a sink that effectfully folds elements of type `In` into a\n * structure of type `S` until `max` elements have been folded.\n *\n * Like `Sink.foldWeightedEffect` but with a constant cost function of `1`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldUntilEffect = internal.foldUntilEffect;\n/**\n * Creates a sink that folds elements of type `In` into a structure of type `S`,\n * until `max` worth of elements (determined by the `costFn`) have been folded.\n *\n * **Note**\n *\n * Elements that have an individual cost larger than `max` will force the sink\n * to cross the `max` cost. See `Sink.foldWeightedDecompose` for a variant\n * that can handle these cases.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldWeighted = internal.foldWeighted;\n/**\n * Creates a sink that folds elements of type `In` into a structure of type\n * `S`, until `max` worth of elements (determined by the `costFn`) have been\n * folded.\n *\n * The `decompose` function will be used for decomposing elements that cause\n * an `S` aggregate to cross `max` into smaller elements. For example:\n *\n * ```ts skip-type-checking\n * pipe(\n *   Stream.make(1, 5, 1),\n *   Stream.transduce(\n *     Sink.foldWeightedDecompose(\n *       Chunk.empty<number>(),\n *       4,\n *       (n: number) => n,\n *       (n: number) => Chunk.make(n - 1, 1),\n *       (acc, el) => pipe(acc, Chunk.append(el))\n *     )\n *   ),\n *   Stream.runCollect\n * )\n * ```\n *\n * The stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.\n *\n * Be vigilant with this function, it has to generate \"simpler\" values or the\n * fold may never end. A value is considered indivisible if `decompose` yields\n * the empty chunk or a single-valued chunk. In these cases, there is no other\n * choice than to yield a value that will cross the threshold.\n *\n * `Sink.foldWeightedDecomposeEffect` allows the decompose function to return an\n * effect value, and consequently it allows the sink to fail.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldWeightedDecompose = internal.foldWeightedDecompose;\n/**\n * Creates a sink that effectfully folds elements of type `In` into a\n * structure of type `S`, until `max` worth of elements (determined by the\n * `costFn`) have been folded.\n *\n * The `decompose` function will be used for decomposing elements that cause\n * an `S` aggregate to cross `max` into smaller elements. Be vigilant with\n * this function, it has to generate \"simpler\" values or the fold may never\n * end. A value is considered indivisible if `decompose` yields the empty\n * chunk or a single-valued chunk. In these cases, there is no other choice\n * than to yield a value that will cross the threshold.\n *\n * See `Sink.foldWeightedDecompose` for an example.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldWeightedDecomposeEffect = internal.foldWeightedDecomposeEffect;\n/**\n * Creates a sink that effectfully folds elements of type `In` into a\n * structure of type `S`, until `max` worth of elements (determined by the\n * `costFn`) have been folded.\n *\n * @note\n *   Elements that have an individual cost larger than `max` will force the\n *   sink to cross the `max` cost. See `Sink.foldWeightedDecomposeEffect` for\n *   a variant that can handle these cases.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const foldWeightedEffect = internal.foldWeightedEffect;\n/**\n * A sink that executes the provided effectful function for every element fed\n * to it.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const forEach = internal.forEach;\n/**\n * A sink that executes the provided effectful function for every chunk fed to\n * it.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const forEachChunk = internal.forEachChunk;\n/**\n * A sink that executes the provided effectful function for every chunk fed to\n * it until `f` evaluates to `false`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const forEachChunkWhile = internal.forEachChunkWhile;\n/**\n * A sink that executes the provided effectful function for every element fed\n * to it until `f` evaluates to `false`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const forEachWhile = internal.forEachWhile;\n/**\n * Runs this sink until it yields a result, then uses that result to create\n * another sink from the provided function which will continue to run until it\n * yields a result.\n *\n * This function essentially runs sinks in sequence.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = internal.flatMap;\n/**\n * Creates a sink from a `Channel`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromChannel = internal.fromChannel;\n/**\n * Creates a `Channel` from a Sink.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const toChannel = internal.toChannel;\n/**\n * Creates a single-value sink produced from an effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEffect = internal.fromEffect;\n/**\n * Create a sink which publishes each element to the specified `PubSub`.\n *\n * If the `shutdown` parameter is `true`, the `PubSub` will be shutdown after\n * the sink is evaluated (defaults to `false`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromPubSub = internal.fromPubSub;\n/**\n * Creates a sink from a chunk processing function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromPush = internal.fromPush;\n/**\n * Create a sink which enqueues each element into the specified queue.\n *\n * If the `shutdown` parameter is `true`, the queue will be shutdown after the\n * sink is evaluated (defaults to `false`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromQueue = internal.fromQueue;\n/**\n * Creates a sink containing the first value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const head = internal.head;\n/**\n * Drains the remaining elements from the stream after the sink finishes\n *\n * @since 2.0.0\n * @category utils\n */\nexport const ignoreLeftover = internal.ignoreLeftover;\n/**\n * Creates a sink containing the last value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const last = internal.last;\n/**\n * Creates a sink that does not consume any input but provides the given chunk\n * as its leftovers\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const leftover = internal.leftover;\n/**\n * Transforms this sink's result.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = internal.map;\n/**\n * Effectfully transforms this sink's result.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapEffect = internal.mapEffect;\n/**\n * Transforms the errors emitted by this sink using `f`.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapError = internal.mapError;\n/**\n * Transforms the leftovers emitted by this sink using `f`.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapLeftover = internal.mapLeftover;\n/**\n * Creates a sink which transforms it's inputs into a string.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const mkString = internal.mkString;\n/**\n * Creates a sink which never terminates.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const never = internal.never;\n/**\n * Switch to another sink in case of failure\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElse = internal.orElse;\n/**\n * Provides the sink with its required context, which eliminates its\n * dependency on `R`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideContext = internal.provideContext;\n/**\n * Runs both sinks in parallel on the input, , returning the result or the\n * error from the one that finishes first.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const race = internal.race;\n/**\n * Runs both sinks in parallel on the input, returning the result or the error\n * from the one that finishes first.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const raceBoth = internal.raceBoth;\n/**\n * Runs both sinks in parallel on the input, using the specified merge\n * function as soon as one result or the other has been computed.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const raceWith = internal.raceWith;\n/**\n * @since 2.0.0\n * @category error handling\n */\nexport const refineOrDie = internal.refineOrDie;\n/**\n * @since 2.0.0\n * @category error handling\n */\nexport const refineOrDieWith = internal.refineOrDieWith;\n/**\n * A sink that returns whether an element satisfies the specified predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const some = internal.some;\n/**\n * Splits the sink on the specified predicate, returning a new sink that\n * consumes elements until an element after the first satisfies the specified\n * predicate.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const splitWhere = internal.splitWhere;\n/**\n * A sink that immediately ends with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed = internal.succeed;\n/**\n * A sink that sums incoming numeric values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sum = internal.sum;\n/**\n * Summarize a sink by running an effect when the sink starts and again when\n * it completes.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const summarized = internal.summarized;\n/**\n * Returns a lazily constructed sink that may require effects for its\n * creation.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const suspend = internal.suspend;\n/**\n * A sink that immediately ends with the specified lazy value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync = internal.sync;\n/**\n * A sink that takes the specified number of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const take = internal.take;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const timed = internal.timed;\n/**\n * Creates a sink produced from an effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unwrap = internal.unwrap;\n/**\n * Creates a sink produced from a scoped effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unwrapScoped = internal.unwrapScoped;\n/**\n * Constructs a `Sink` from a function which receives a `Scope` and returns\n * an effect that will result in a `Sink` if successful.\n *\n * @since 3.11.0\n * @category constructors\n */\nexport const unwrapScopedWith = internal.unwrapScopedWith;\n/**\n * Returns the sink that executes this one and times its execution.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const withDuration = internal.withDuration;\n/**\n * Feeds inputs to this sink until it yields a result, then switches over to\n * the provided sink until it yields a result, finally combining the two\n * results into a tuple.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip = internal.zip;\n/**\n * Like `Sink.zip` but keeps only the result from this sink.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft = internal.zipLeft;\n/**\n * Like `Sink.zip` but keeps only the result from `that` sink.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight = internal.zipRight;\n/**\n * Feeds inputs to this sink until it yields a result, then switches over to\n * the provided sink until it yields a result, finally combining the two\n * results with `f`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith = internal.zipWith;\n//# sourceMappingURL=Sink.js.map",
      "start": 1768772628414,
      "end": 1768772628414
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628414,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628434,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628478,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
