{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/Utils.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport { identity } from \"./Function.js\";\nimport { globalValue } from \"./GlobalValue.js\";\nimport { getBugErrorMessage } from \"./internal/errors.js\";\nimport { isNullable, isObject } from \"./Predicate.js\";\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const GenKindTypeId = /*#__PURE__*/Symbol.for(\"effect/Gen/GenKind\");\n/**\n * @category predicates\n * @since 3.0.6\n */\nexport const isGenKind = u => isObject(u) && GenKindTypeId in u;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class GenKindImpl {\n  value;\n  constructor(\n  /**\n   * @since 2.0.0\n   */\n  value) {\n    this.value = value;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return identity;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [GenKindTypeId] = GenKindTypeId;\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  /**\n   * @since 2.0.0\n   */\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  /**\n   * @since 2.0.0\n   */\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  /**\n   * @since 2.0.0\n   */\n  throw(e) {\n    throw e;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const makeGenKind = kind => new GenKindImpl(kind);\n/**\n * @category adapters\n * @since 2.0.0\n */\nexport const adapter = () => function () {\n  let x = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x);\n  }\n  return new GenKindImpl(x);\n};\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nexport class PCGRandom {\n  _state;\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNullable(seedLo) && isNullable(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNullable(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNullable(incLo) && isNullable(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNullable(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max) {\n    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n/**\n * @since 3.0.6\n */\nexport const YieldWrapTypeId = /*#__PURE__*/Symbol.for(\"effect/Utils/YieldWrap\");\n/**\n * @since 3.0.6\n */\nexport class YieldWrap {\n  /**\n   * @since 3.0.6\n   */\n  #value;\n  constructor(value) {\n    this.#value = value;\n  }\n  /**\n   * @since 3.0.6\n   */\n  [YieldWrapTypeId]() {\n    return this.#value;\n  }\n}\n/**\n * @since 3.0.6\n */\nexport function yieldWrapGet(self) {\n  if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n    return self[YieldWrapTypeId]();\n  }\n  throw new Error(getBugErrorMessage(\"yieldWrapGet\"));\n}\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegionState = /*#__PURE__*/globalValue(\"effect/Utils/isStructuralRegion\", () => ({\n  enabled: false,\n  tester: undefined\n}));\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegion = (body, tester) => {\n  const current = structuralRegionState.enabled;\n  const currentTester = structuralRegionState.tester;\n  structuralRegionState.enabled = true;\n  if (tester) {\n    structuralRegionState.tester = tester;\n  }\n  try {\n    return body();\n  } finally {\n    structuralRegionState.enabled = current;\n    structuralRegionState.tester = currentTester;\n  }\n};\nconst standard = {\n  effect_internal_function: body => {\n    return body();\n  }\n};\nconst forced = {\n  effect_internal_function: body => {\n    try {\n      return body();\n    } finally {\n      //\n    }\n  }\n};\nconst isNotOptimizedAway = /*#__PURE__*/standard.effect_internal_function(() => new Error().stack)?.includes(\"effect_internal_function\") === true;\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */\nexport const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;\nconst genConstructor = function* () {}.constructor;\n/**\n * @since 3.11.0\n */\nexport const isGeneratorFunction = u => isObject(u) && u.constructor === genConstructor;\n//# sourceMappingURL=Utils.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628477,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
