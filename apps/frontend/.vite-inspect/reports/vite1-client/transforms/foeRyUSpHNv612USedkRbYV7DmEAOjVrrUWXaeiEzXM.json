{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/HttpLayerRouter.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as HttpServerRequest from \"@effect/platform/HttpServerRequest\";\nimport * as HttpServerResponse from \"@effect/platform/HttpServerResponse\";\nimport * as Arr from \"effect/Array\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport { compose, constant, dual, identity } from \"effect/Function\";\nimport * as Layer from \"effect/Layer\";\nimport * as Option from \"effect/Option\";\nimport * as Scope from \"effect/Scope\";\nimport * as Tracer from \"effect/Tracer\";\nimport * as FindMyWay from \"find-my-way-ts\";\nimport * as HttpApiBuilder from \"./HttpApiBuilder.js\";\nimport * as HttpApp from \"./HttpApp.js\";\nimport * as HttpMiddleware from \"./HttpMiddleware.js\";\nimport { RouteContext, RouteContextTypeId } from \"./HttpRouter.js\";\nimport * as HttpServer from \"./HttpServer.js\";\nimport * as HttpServerError from \"./HttpServerError.js\";\nimport * as OpenApi from \"./OpenApi.js\";\n/**\n * @since 1.0.0\n * @category Re-exports\n */\nexport * as FindMyWay from \"find-my-way-ts\";\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpLayerRouter/HttpRouter\");\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const HttpRouter = /*#__PURE__*/Context.GenericTag(\"@effect/platform/HttpLayerRouter\");\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const make = /*#__PURE__*/Effect.gen(function* () {\n  const router = FindMyWay.make(yield* RouterConfig);\n  const middleware = new Set();\n  const addAll = routes => Effect.contextWith(context => {\n    const middleware = getMiddleware(context);\n    const applyMiddleware = effect => {\n      for (let i = 0; i < middleware.length; i++) {\n        effect = middleware[i](effect);\n      }\n      return effect;\n    };\n    for (let i = 0; i < routes.length; i++) {\n      const route = middleware.length === 0 ? routes[i] : makeRoute({\n        ...routes[i],\n        handler: applyMiddleware(routes[i].handler)\n      });\n      if (route.method === \"*\") {\n        router.all(route.path, route);\n      } else {\n        router.on(route.method, route.path, route);\n      }\n    }\n  });\n  return HttpRouter.of({\n    [TypeId]: TypeId,\n    prefixed(prefix) {\n      return HttpRouter.of({\n        ...this,\n        prefixed: newPrefix => this.prefixed(prefixPath(prefix, newPrefix)),\n        addAll: routes => addAll(routes.map(prefixRoute(prefix))),\n        add: (method, path, handler, options) => addAll([makeRoute({\n          method,\n          path: prefixPath(path, prefix),\n          handler: Effect.isEffect(handler) ? handler : Effect.flatMap(HttpServerRequest.HttpServerRequest, handler),\n          uninterruptible: options?.uninterruptible ?? false,\n          prefix: Option.some(prefix)\n        })])\n      });\n    },\n    addAll,\n    add: (method, path, handler, options) => addAll([route(method, path, handler, options)]),\n    addGlobalMiddleware: middleware_ => Effect.sync(() => {\n      middleware.add(middleware_);\n    }),\n    asHttpEffect() {\n      let handler = Effect.withFiberRuntime(fiber => {\n        const contextMap = new Map(fiber.currentContext.unsafeMap);\n        const request = contextMap.get(HttpServerRequest.HttpServerRequest.key);\n        let result = router.find(request.method, request.url);\n        if (result === undefined && request.method === \"HEAD\") {\n          result = router.find(\"GET\", request.url);\n        }\n        if (result === undefined) {\n          return Effect.fail(new HttpServerError.RouteNotFound({\n            request\n          }));\n        }\n        const route = result.handler;\n        if (route.prefix._tag === \"Some\") {\n          contextMap.set(HttpServerRequest.HttpServerRequest.key, sliceRequestUrl(request, route.prefix.value));\n        }\n        contextMap.set(HttpServerRequest.ParsedSearchParams.key, result.searchParams);\n        contextMap.set(RouteContext.key, {\n          [RouteContextTypeId]: RouteContextTypeId,\n          route,\n          params: result.params\n        });\n        const span = contextMap.get(Tracer.ParentSpan.key);\n        if (span && span._tag === \"Span\") {\n          span.attribute(\"http.route\", route.path);\n        }\n        return Effect.locally(route.uninterruptible ? route.handler : Effect.interruptible(route.handler), FiberRef.currentContext, Context.unsafeMake(contextMap));\n      });\n      if (middleware.size === 0) return handler;\n      for (const fn of Arr.reverse(middleware)) {\n        handler = fn(handler);\n      }\n      return handler;\n    }\n  });\n});\nfunction sliceRequestUrl(request, prefix) {\n  const prefexLen = prefix.length;\n  return request.modify({\n    url: request.url.length <= prefexLen ? \"/\" : request.url.slice(prefexLen)\n  });\n}\n/**\n * @since 1.0.0\n * @category Configuration\n */\nexport class RouterConfig extends /*#__PURE__*/Context.Reference()(\"@effect/platform/HttpLayerRouter/RouterConfig\", {\n  defaultValue: /*#__PURE__*/constant({})\n}) {}\nexport {\n/**\n * @since 1.0.0\n * @category Route context\n */\nparams,\n/**\n * @since 1.0.0\n * @category Route context\n */\nRouteContext,\n/**\n * @since 1.0.0\n * @category Route context\n */\nschemaJson,\n/**\n * @since 1.0.0\n * @category Route context\n */\nschemaNoBody,\n/**\n * @since 1.0.0\n * @category Route context\n */\nschemaParams,\n/**\n * @since 1.0.0\n * @category Route context\n */\nschemaPathParams } from \"./HttpRouter.js\";\n/**\n * A helper function that is the equivalent of:\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n *\n * const MyRoute = Layer.scopedDiscard(Effect.gen(function*() {\n *   const router = yield* HttpLayerRouter.HttpRouter\n *\n *   // then use `yield* router.add(...)` to add a route\n * }))\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const use = f => Layer.scopedDiscard(Effect.flatMap(HttpRouter, f));\n/**\n * Create a layer that adds a single route to the HTTP router.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n *\n * const Route = HttpLayerRouter.add(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\"))\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const add = (method, path, handler, options) => use(router => router.add(method, path, handler, options));\n/**\n * Create a layer that adds multiple routes to the HTTP router.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n *\n * const Routes = HttpLayerRouter.addAll([\n *   HttpLayerRouter.route(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\"))\n * ])\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const addAll = (routes, options) => Layer.scopedDiscard(Effect.gen(function* () {\n  const toAdd = Effect.isEffect(routes) ? yield* routes : routes;\n  let router = yield* HttpRouter;\n  if (options?.prefix) {\n    router = router.prefixed(options.prefix);\n  }\n  yield* router.addAll(toAdd);\n}));\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const layer = /*#__PURE__*/Layer.effect(HttpRouter, make);\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const toHttpEffect = appLayer => Effect.gen(function* () {\n  const scope = yield* Effect.scope;\n  const memoMap = yield* Layer.CurrentMemoMap;\n  const context = yield* Layer.buildWithMemoMap(Layer.provideMerge(appLayer, layer), memoMap, scope);\n  const router = Context.get(context, HttpRouter);\n  return router.asHttpEffect();\n});\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const RouteTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpLayerRouter/Route\");\nconst makeRoute = options => ({\n  ...options,\n  uninterruptible: options.uninterruptible ?? false,\n  prefix: options.prefix ?? Option.none(),\n  [RouteTypeId]: RouteTypeId\n});\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const route = (method, path, handler, options) => makeRoute({\n  ...options,\n  method,\n  path,\n  handler: Effect.isEffect(handler) ? handler : Effect.flatMap(HttpServerRequest.HttpServerRequest, handler),\n  uninterruptible: options?.uninterruptible ?? false\n});\nconst removeTrailingSlash = path => path.endsWith(\"/\") ? path.slice(0, -1) : path;\n/**\n * @since 1.0.0\n * @category PathInput\n */\nexport const prefixPath = /*#__PURE__*/dual(2, (self, prefix) => {\n  prefix = removeTrailingSlash(prefix);\n  return self === \"/\" ? prefix : prefix + self;\n});\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const prefixRoute = /*#__PURE__*/dual(2, (self, prefix) => makeRoute({\n  ...self,\n  path: prefixPath(self.path, prefix),\n  prefix: Option.match(self.prefix, {\n    onNone: () => Option.some(prefix),\n    onSome: existingPrefix => Option.some(prefixPath(existingPrefix, prefix))\n  })\n}));\n/**\n * @since 1.0.0\n * @category Middleware\n */\nexport const MiddlewareTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpLayerRouter/Middleware\");\n/**\n * Create a middleware layer that can be used to modify requests and responses.\n *\n * By default, the middleware only affects the routes that it is provided to.\n *\n * If you want to create a middleware that applies globally to all routes, pass\n * the `global` option as `true`.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpMiddleware from \"@effect/platform/HttpMiddleware\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n * import * as Context from \"effect/Context\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n *\n * // Here we are defining a CORS middleware\n * const CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors()).layer\n * // You can also use HttpLayerRouter.cors() to create a CORS middleware\n *\n * class CurrentSession extends Context.Tag(\"CurrentSession\")<CurrentSession, {\n *   readonly token: string\n * }>() {}\n *\n * // You can create middleware that provides a service to the HTTP requests.\n * const SessionMiddleware = HttpLayerRouter.middleware<{\n *   provides: CurrentSession\n * }>()(\n *   Effect.gen(function*() {\n *     yield* Effect.log(\"SessionMiddleware initialized\")\n *\n *     return (httpEffect) =>\n *       Effect.provideService(httpEffect, CurrentSession, {\n *         token: \"dummy-token\"\n *       })\n *   })\n * ).layer\n *\n * Effect.gen(function*() {\n *   const router = yield* HttpLayerRouter.HttpRouter\n *   yield* router.add(\n *     \"GET\",\n *     \"/hello\",\n *     Effect.gen(function*() {\n *       // Requests can now access the current session\n *       const session = yield* CurrentSession\n *       return HttpServerResponse.text(`Hello, World! Your token is ${session.token}`)\n *     })\n *   )\n * }).pipe(\n *   Layer.effectDiscard,\n *   // Provide the SessionMiddleware & CorsMiddleware to some routes\n *   Layer.provide([SessionMiddleware, CorsMiddleware])\n * )\n * ```\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const middleware = function () {\n  if (arguments.length === 0) {\n    return makeMiddleware;\n  }\n  return makeMiddleware(arguments[0], arguments[1]);\n};\nconst makeMiddleware = (middleware, options) => options?.global ? Layer.scopedDiscard(Effect.gen(function* () {\n  const router = yield* HttpRouter;\n  const fn = Effect.isEffect(middleware) ? yield* middleware : middleware;\n  yield* router.addGlobalMiddleware(fn);\n})) : new MiddlewareImpl(Effect.isEffect(middleware) ? Layer.scopedContext(Effect.map(middleware, fn => Context.unsafeMake(new Map([[fnContextKey, fn]])))) : Layer.succeedContext(Context.unsafeMake(new Map([[fnContextKey, middleware]]))));\nlet middlewareId = 0;\nconst fnContextKey = \"@effect/platform/HttpLayerRouter/MiddlewareFn\";\nclass MiddlewareImpl {\n  layerFn;\n  dependencies;\n  [MiddlewareTypeId] = {};\n  constructor(layerFn, dependencies) {\n    this.layerFn = layerFn;\n    this.dependencies = dependencies;\n    const contextKey = `@effect/platform/HttpLayerRouter/Middleware-${++middlewareId}`;\n    this.layer = Layer.scopedContext(Effect.gen(this, function* () {\n      const context = yield* Effect.context();\n      const stack = [context.unsafeMap.get(fnContextKey)];\n      if (this.dependencies) {\n        const memoMap = yield* Layer.CurrentMemoMap;\n        const scope = Context.get(context, Scope.Scope);\n        const depsContext = yield* Layer.buildWithMemoMap(this.dependencies, memoMap, scope);\n        // eslint-disable-next-line no-restricted-syntax\n        stack.push(...getMiddleware(depsContext));\n      }\n      return Context.unsafeMake(new Map([[contextKey, stack]]));\n    })).pipe(Layer.provide(this.layerFn));\n  }\n  layer;\n  combine(other) {\n    return new MiddlewareImpl(this.layerFn, this.dependencies ? Layer.provideMerge(this.dependencies, other.layer) : other.layer);\n  }\n}\nconst middlewareCache = /*#__PURE__*/new WeakMap();\nconst getMiddleware = context => {\n  let arr = middlewareCache.get(context);\n  if (arr) return arr;\n  const topLevel = Arr.empty();\n  let maxLength = 0;\n  for (const [key, value] of context.unsafeMap) {\n    if (key.startsWith(\"@effect/platform/HttpLayerRouter/Middleware-\")) {\n      topLevel.push(value);\n      if (value.length > maxLength) {\n        maxLength = value.length;\n      }\n    }\n  }\n  if (topLevel.length === 0) {\n    arr = [];\n  } else {\n    const middleware = new Set();\n    for (let i = maxLength - 1; i >= 0; i--) {\n      for (const arr of topLevel) {\n        if (i < arr.length) {\n          middleware.add(arr[i]);\n        }\n      }\n    }\n    arr = Arr.fromIterable(middleware).reverse();\n  }\n  middlewareCache.set(context, arr);\n  return arr;\n};\n/**\n * A middleware that applies CORS headers to the HTTP response.\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const cors = options => middleware(HttpMiddleware.cors(options), {\n  global: true\n});\n/**\n * A middleware that disables the logger for some routes.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n * import * as Layer from \"effect/Layer\"\n *\n * const Route = HttpLayerRouter.add(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\")).pipe(\n *   // disable the logger for this route\n *   Layer.provide(HttpLayerRouter.disableLogger)\n * )\n * ```\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const disableLogger = /*#__PURE__*/middleware(HttpMiddleware.withLoggerDisabled).layer;\n/**\n * ```ts\n * import * as NodeHttpServer from \"@effect/platform-node/NodeHttpServer\"\n * import * as NodeRuntime from \"@effect/platform-node/NodeRuntime\"\n * import * as HttpApi from \"@effect/platform/HttpApi\"\n * import * as HttpApiBuilder from \"@effect/platform/HttpApiBuilder\"\n * import * as HttpApiEndpoint from \"@effect/platform/HttpApiEndpoint\"\n * import * as HttpApiGroup from \"@effect/platform/HttpApiGroup\"\n * import * as HttpApiScalar from \"@effect/platform/HttpApiScalar\"\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpMiddleware from \"@effect/platform/HttpMiddleware\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n * import { createServer } from \"http\"\n *\n * // First, we define our HttpApi\n * class MyApi extends HttpApi.make(\"api\").add(\n *   HttpApiGroup.make(\"users\").add(\n *     HttpApiEndpoint.get(\"me\", \"/me\")\n *   ).prefix(\"/users\")\n * ) {}\n *\n * // Implement the handlers for the API\n * const UsersApiLayer = HttpApiBuilder.group(MyApi, \"users\", (handers) => handers.handle(\"me\", () => Effect.void))\n *\n * // Use `HttpLayerRouter.addHttpApi` to register the API with the router\n * const HttpApiRoutes = HttpLayerRouter.addHttpApi(MyApi, {\n *   openapiPath: \"/docs/openapi.json\"\n * }).pipe(\n *   // Provide the api handlers layer\n *   Layer.provide(UsersApiLayer)\n * )\n *\n * // Create a /docs route for the API documentation\n * const DocsRoute = HttpApiScalar.layerHttpLayerRouter({\n *   api: MyApi,\n *   path: \"/docs\"\n * })\n *\n * const CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors())\n * // You can also use HttpLayerRouter.cors() to create a CORS middleware\n *\n * // Finally, we merge all routes and serve them using the Node HTTP server\n * const AllRoutes = Layer.mergeAll(\n *   HttpApiRoutes,\n *   DocsRoute\n * ).pipe(\n *   Layer.provide(CorsMiddleware.layer)\n * )\n *\n * HttpLayerRouter.serve(AllRoutes).pipe(\n *   Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n *   Layer.launch,\n *   NodeRuntime.runMain\n * )\n * ```\n *\n * @since 1.0.0\n * @category HttpApi\n */\nexport const addHttpApi = (api, options) => {\n  const ApiMiddleware = middleware(HttpApiBuilder.buildMiddleware(api)).layer;\n  return HttpApiBuilder.Router.unwrap(Effect.fnUntraced(function* (router_) {\n    const router = yield* HttpRouter;\n    let existing = existingRoutesMap.get(router);\n    if (!existing) {\n      existing = new Set();\n      existingRoutesMap.set(router, existing);\n    }\n    const context = yield* Effect.context();\n    const routes = Arr.empty();\n    for (const route of router_.routes) {\n      if (existing.has(route)) {\n        continue;\n      }\n      existing.add(route);\n      routes.push(makeRoute({\n        ...route,\n        handler: Effect.provide(route.handler, context)\n      }));\n    }\n    yield* router.addAll(routes);\n    if (options?.openapiPath) {\n      const spec = OpenApi.fromApi(api);\n      yield* router.add(\"GET\", options.openapiPath, Effect.succeed(HttpServerResponse.unsafeJson(spec)));\n    }\n  }, Layer.effectDiscard)).pipe(Layer.provide(ApiMiddleware));\n};\nconst existingRoutesMap = /*#__PURE__*/new WeakMap();\n/**\n * Serves the provided application layer as an HTTP server.\n *\n * @since 1.0.0\n * @category Server\n */\nexport const serve = (appLayer, options) => {\n  let middleware = options?.middleware;\n  if (options?.disableLogger !== true) {\n    middleware = middleware ? compose(middleware, HttpMiddleware.logger) : HttpMiddleware.logger;\n  }\n  const RouterLayer = options?.routerConfig ? Layer.provide(layer, Layer.succeed(RouterConfig, options.routerConfig)) : layer;\n  return Effect.gen(function* () {\n    const router = yield* HttpRouter;\n    const handler = router.asHttpEffect();\n    return middleware ? HttpServer.serve(handler, middleware) : HttpServer.serve(handler);\n  }).pipe(Layer.unwrapScoped, Layer.provideMerge(appLayer), Layer.provide(RouterLayer), options?.disableListenLog ? identity : HttpServer.withLogAddress);\n};\n/**\n * @since 1.0.0\n * @category Server\n */\nexport const toWebHandler = (appLayer, options) => {\n  let middleware = options?.middleware;\n  if (options?.disableLogger !== true) {\n    middleware = middleware ? compose(middleware, HttpMiddleware.logger) : HttpMiddleware.logger;\n  }\n  const RouterLayer = Layer.provideMerge(appLayer, options?.routerConfig ? Layer.provide(layer, Layer.succeed(RouterConfig, options.routerConfig)) : layer);\n  return HttpApp.toWebHandlerLayerWith(RouterLayer, {\n    toHandler: r => Effect.succeed(Context.get(r.context, HttpRouter).asHttpEffect()),\n    middleware,\n    memoMap: options?.memoMap\n  });\n};\n//# sourceMappingURL=HttpLayerRouter.js.map",
      "start": 1768772628586,
      "end": 1768772628586
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628586,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628618,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628648,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
