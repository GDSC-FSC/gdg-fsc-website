{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/Multipart.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Channel from \"effect/Channel\";\nimport * as Chunk from \"effect/Chunk\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as Exit from \"effect/Exit\";\nimport { constant, dual } from \"effect/Function\";\nimport * as Inspectable from \"effect/Inspectable\";\nimport * as Mailbox from \"effect/Mailbox\";\nimport * as Option from \"effect/Option\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as Schema from \"effect/Schema\";\nimport * as Stream from \"effect/Stream\";\nimport * as MP from \"multipasta\";\nimport * as FileSystem from \"./FileSystem.js\";\nimport * as IncomingMessage from \"./HttpIncomingMessage.js\";\nimport * as Path from \"./Path.js\";\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Multipart\");\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isPart = u => Predicate.hasProperty(u, TypeId);\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isField = u => isPart(u) && u._tag === \"Field\";\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isFile = u => isPart(u) && u._tag === \"File\";\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isPersistedFile = u => Predicate.hasProperty(u, TypeId) && Predicate.isTagged(u, \"PersistedFile\");\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport const ErrorTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Multipart/MultipartError\");\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport class MultipartError extends /*#__PURE__*/Schema.TaggedError()(\"MultipartError\", {\n  reason: /*#__PURE__*/Schema.Literal(\"FileTooLarge\", \"FieldTooLarge\", \"BodyTooLarge\", \"TooManyParts\", \"InternalError\", \"Parse\"),\n  cause: Schema.Defect\n}) {\n  /**\n   * @since 1.0.0\n   */\n  [ErrorTypeId] = ErrorTypeId;\n  /**\n   * @since 1.0.0\n   */\n  get message() {\n    return this.reason;\n  }\n}\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const FileSchema = /*#__PURE__*/Schema.declare(isPersistedFile, {\n  typeConstructor: {\n    _tag: \"effect/platform/Multipart.PersistedFile\"\n  },\n  identifier: \"PersistedFile\",\n  jsonSchema: {\n    type: \"string\",\n    format: \"binary\"\n  }\n});\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const FilesSchema = /*#__PURE__*/Schema.Array(FileSchema);\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const SingleFileSchema = /*#__PURE__*/Schema.transform(/*#__PURE__*/FilesSchema.pipe(/*#__PURE__*/Schema.itemsCount(1)), FileSchema, {\n  strict: true,\n  decode: ([file]) => file,\n  encode: file => [file]\n});\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const schemaPersisted = (schema, options) => Schema.decodeUnknown(schema, options);\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const schemaJson = (schema, options) => {\n  const fromJson = Schema.parseJson(schema);\n  return dual(2, (persisted, field) => Effect.map(Schema.decodeUnknown(Schema.Struct({\n    [field]: fromJson\n  }), options)(persisted), _ => _[field]));\n};\n/**\n * @since 1.0.0\n * @category Config\n */\nexport const makeConfig = headers => Effect.withFiberRuntime(fiber => {\n  const mimeTypes = Context.get(fiber.currentContext, FieldMimeTypes);\n  return Effect.succeed({\n    headers,\n    maxParts: Option.getOrUndefined(Context.get(fiber.currentContext, MaxParts)),\n    maxFieldSize: Number(Context.get(fiber.currentContext, MaxFieldSize)),\n    maxPartSize: Context.get(fiber.currentContext, MaxFileSize).pipe(Option.map(Number), Option.getOrUndefined),\n    maxTotalSize: Context.get(fiber.currentContext, IncomingMessage.MaxBodySize).pipe(Option.map(Number), Option.getOrUndefined),\n    isFile: mimeTypes.length === 0 ? undefined : info => !Chunk.some(mimeTypes, _ => info.contentType.includes(_)) && MP.defaultIsFile(info)\n  });\n});\n/**\n * @since 1.0.0\n * @category Parsers\n */\nexport const makeChannel = (headers, bufferSize = 16) => Channel.acquireUseRelease(Effect.all([makeConfig(headers), Mailbox.make(bufferSize)]), ([config, mailbox]) => {\n  let partsBuffer = [];\n  let exit = Option.none();\n  const input = {\n    awaitRead: () => Effect.void,\n    emit(element) {\n      return mailbox.offer(element);\n    },\n    error(cause) {\n      exit = Option.some(Exit.failCause(cause));\n      return mailbox.end;\n    },\n    done(_value) {\n      return mailbox.end;\n    }\n  };\n  const parser = MP.make({\n    ...config,\n    onField(info, value) {\n      partsBuffer.push(new FieldImpl(info.name, info.contentType, MP.decodeField(info, value)));\n    },\n    onFile(info) {\n      let chunks = [];\n      let finished = false;\n      const take = Channel.suspend(() => {\n        if (chunks.length === 0) {\n          return finished ? Channel.void : Channel.zipRight(pump, take);\n        }\n        const chunk = Chunk.unsafeFromArray(chunks);\n        chunks = [];\n        return finished ? Channel.write(chunk) : Channel.zipRight(Channel.write(chunk), Channel.zipRight(pump, take));\n      });\n      partsBuffer.push(new FileImpl(info, take));\n      return function (chunk) {\n        if (chunk === null) {\n          finished = true;\n        } else {\n          chunks.push(chunk);\n        }\n      };\n    },\n    onError(error_) {\n      exit = Option.some(Exit.fail(convertError(error_)));\n    },\n    onDone() {\n      exit = Option.some(Exit.void);\n    }\n  });\n  const pump = Channel.flatMap(mailbox.takeAll, ([chunks, done]) => Channel.sync(() => {\n    Chunk.forEach(chunks, Chunk.forEach(parser.write));\n    if (done) {\n      parser.end();\n    }\n  }));\n  const partsChannel = Channel.flatMap(pump, () => {\n    if (partsBuffer.length === 0) {\n      return exit._tag === \"None\" ? partsChannel : writeExit(exit.value);\n    }\n    const chunk = Chunk.unsafeFromArray(partsBuffer);\n    partsBuffer = [];\n    return Channel.zipRight(Channel.write(chunk), exit._tag === \"None\" ? partsChannel : writeExit(exit.value));\n  });\n  return Channel.embedInput(partsChannel, input);\n}, ([, mailbox]) => mailbox.shutdown);\nconst writeExit = self => self._tag === \"Success\" ? Channel.void : Channel.failCause(self.cause);\nfunction convertError(cause) {\n  switch (cause._tag) {\n    case \"ReachedLimit\":\n      {\n        switch (cause.limit) {\n          case \"MaxParts\":\n            {\n              return new MultipartError({\n                reason: \"TooManyParts\",\n                cause\n              });\n            }\n          case \"MaxFieldSize\":\n            {\n              return new MultipartError({\n                reason: \"FieldTooLarge\",\n                cause\n              });\n            }\n          case \"MaxPartSize\":\n            {\n              return new MultipartError({\n                reason: \"FileTooLarge\",\n                cause\n              });\n            }\n          case \"MaxTotalSize\":\n            {\n              return new MultipartError({\n                reason: \"BodyTooLarge\",\n                cause\n              });\n            }\n        }\n      }\n    default:\n      {\n        return new MultipartError({\n          reason: \"Parse\",\n          cause\n        });\n      }\n  }\n}\nclass PartBase extends Inspectable.Class {\n  [TypeId];\n  constructor() {\n    super();\n    this[TypeId] = TypeId;\n  }\n}\nclass FieldImpl extends PartBase {\n  key;\n  contentType;\n  value;\n  _tag = \"Field\";\n  constructor(key, contentType, value) {\n    super();\n    this.key = key;\n    this.contentType = contentType;\n    this.value = value;\n  }\n  toJSON() {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"Field\",\n      key: this.key,\n      contentType: this.contentType,\n      value: this.value\n    };\n  }\n}\nclass FileImpl extends PartBase {\n  _tag = \"File\";\n  key;\n  name;\n  contentType;\n  content;\n  contentEffect;\n  constructor(info, channel) {\n    super();\n    this.key = info.name;\n    this.name = info.filename ?? info.name;\n    this.contentType = info.contentType;\n    this.content = Stream.fromChannel(channel);\n    this.contentEffect = channel.pipe(Channel.pipeTo(collectUint8Array), Channel.run, Effect.mapError(cause => new MultipartError({\n      reason: \"InternalError\",\n      cause\n    })));\n  }\n  toJSON() {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"File\",\n      key: this.key,\n      name: this.name,\n      contentType: this.contentType\n    };\n  }\n}\nconst defaultWriteFile = (path, file) => Effect.flatMap(FileSystem.FileSystem, fs => Effect.mapError(Stream.run(file.content, fs.sink(path)), cause => new MultipartError({\n  reason: \"InternalError\",\n  cause\n})));\n/**\n * @since 1.0.0\n */\nexport const collectUint8Array = /*#__PURE__*/Channel.suspend(() => {\n  let accumulator = new Uint8Array(0);\n  const loop = Channel.readWithCause({\n    onInput(chunk) {\n      for (const element of chunk) {\n        const newAccumulator = new Uint8Array(accumulator.length + element.length);\n        newAccumulator.set(accumulator, 0);\n        newAccumulator.set(element, accumulator.length);\n        accumulator = newAccumulator;\n      }\n      return loop;\n    },\n    onFailure: cause => Channel.failCause(cause),\n    onDone: () => Channel.succeed(accumulator)\n  });\n  return loop;\n});\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toPersisted = (stream, writeFile = defaultWriteFile) => Effect.gen(function* () {\n  const fs = yield* FileSystem.FileSystem;\n  const path_ = yield* Path.Path;\n  const dir = yield* fs.makeTempDirectoryScoped();\n  const persisted = Object.create(null);\n  yield* Stream.runForEach(stream, part => {\n    if (part._tag === \"Field\") {\n      if (!(part.key in persisted)) {\n        persisted[part.key] = part.value;\n      } else if (typeof persisted[part.key] === \"string\") {\n        persisted[part.key] = [persisted[part.key], part.value];\n      } else {\n        ;\n        persisted[part.key].push(part.value);\n      }\n      return Effect.void;\n    } else if (part.name === \"\") {\n      return Effect.void;\n    }\n    const file = part;\n    const path = path_.join(dir, path_.basename(file.name).slice(-128));\n    const filePart = new PersistedFileImpl(file.key, file.name, file.contentType, path);\n    if (Array.isArray(persisted[part.key])) {\n      ;\n      persisted[part.key].push(filePart);\n    } else {\n      persisted[part.key] = [filePart];\n    }\n    return writeFile(path, file);\n  });\n  return persisted;\n}).pipe(Effect.catchTags({\n  SystemError: cause => Effect.fail(new MultipartError({\n    reason: \"InternalError\",\n    cause\n  })),\n  BadArgument: cause => Effect.fail(new MultipartError({\n    reason: \"InternalError\",\n    cause\n  }))\n}));\nclass PersistedFileImpl extends PartBase {\n  key;\n  name;\n  contentType;\n  path;\n  _tag = \"PersistedFile\";\n  constructor(key, name, contentType, path) {\n    super();\n    this.key = key;\n    this.name = name;\n    this.contentType = contentType;\n    this.path = path;\n  }\n  toJSON() {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"PersistedFile\",\n      key: this.key,\n      name: this.name,\n      contentType: this.contentType,\n      path: this.path\n    };\n  }\n}\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withLimits = /*#__PURE__*/dual(2, (effect, options) => Effect.provide(effect, withLimitsContext(options)));\nconst withLimitsContext = options => {\n  const contextMap = new Map();\n  if (options.maxParts !== undefined) {\n    contextMap.set(MaxParts.key, options.maxParts);\n  }\n  if (options.maxFieldSize !== undefined) {\n    contextMap.set(MaxFieldSize.key, FileSystem.Size(options.maxFieldSize));\n  }\n  if (options.maxFileSize !== undefined) {\n    contextMap.set(MaxFileSize.key, Option.map(options.maxFileSize, FileSystem.Size));\n  }\n  if (options.maxTotalSize !== undefined) {\n    contextMap.set(IncomingMessage.MaxBodySize.key, Option.map(options.maxTotalSize, FileSystem.Size));\n  }\n  if (options.fieldMimeTypes !== undefined) {\n    contextMap.set(FieldMimeTypes.key, Chunk.fromIterable(options.fieldMimeTypes));\n  }\n  return Context.unsafeMake(contextMap);\n};\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withLimitsStream = /*#__PURE__*/dual(2, (stream, options) => Stream.provideSomeContext(stream, withLimitsContext(options)));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxParts extends /*#__PURE__*/Context.Reference()(\"@effect/platform/Multipart/MaxParts\", {\n  defaultValue: Option.none\n}) {}\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxParts = /*#__PURE__*/dual(2, (effect, count) => Effect.provideService(effect, MaxParts, count));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxFieldSize extends /*#__PURE__*/Context.Reference()(\"@effect/platform/Multipart/MaxFieldSize\", {\n  defaultValue: /*#__PURE__*/constant(/*#__PURE__*/FileSystem.Size(10 * 1024 * 1024))\n}) {}\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxFieldSize = /*#__PURE__*/dual(2, (effect, size) => Effect.provideService(effect, MaxFieldSize, FileSystem.Size(size)));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxFileSize extends /*#__PURE__*/Context.Reference()(\"@effect/platform/Multipart/MaxFileSize\", {\n  defaultValue: Option.none\n}) {}\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxFileSize = /*#__PURE__*/dual(2, (effect, size) => Effect.provideService(effect, MaxFileSize, Option.map(size, FileSystem.Size)));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class FieldMimeTypes extends /*#__PURE__*/Context.Reference()(\"@effect/platform/Multipart/FieldMimeTypes\", {\n  defaultValue: /*#__PURE__*/constant(/*#__PURE__*/Chunk.make(\"application/json\"))\n}) {}\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withFieldMimeTypes = /*#__PURE__*/dual(2, (effect, mimeTypes) => Effect.provideService(effect, FieldMimeTypes, Chunk.fromIterable(mimeTypes)));\n//# sourceMappingURL=Multipart.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628706,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
