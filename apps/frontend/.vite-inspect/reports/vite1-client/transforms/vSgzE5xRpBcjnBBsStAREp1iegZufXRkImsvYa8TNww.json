{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/core-stream.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"../Cause.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Effect from \"../Effect.js\";\nimport * as Either from \"../Either.js\";\nimport { constVoid, dual, identity } from \"../Function.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as childExecutorDecision from \"./channel/childExecutorDecision.js\";\nimport { ContinuationKImpl } from \"./channel/continuation.js\";\nimport * as upstreamPullStrategy from \"./channel/upstreamPullStrategy.js\";\nimport * as OpCodes from \"./opCodes/channel.js\";\n/** @internal */\nconst ChannelSymbolKey = \"effect/Channel\";\n/** @internal */\nexport const ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);\nconst channelVariance = {\n  /* c8 ignore next */\n  _Env: _ => _,\n  /* c8 ignore next */\n  _InErr: _ => _,\n  /* c8 ignore next */\n  _InElem: _ => _,\n  /* c8 ignore next */\n  _InDone: _ => _,\n  /* c8 ignore next */\n  _OutErr: _ => _,\n  /* c8 ignore next */\n  _OutElem: _ => _,\n  /* c8 ignore next */\n  _OutDone: _ => _\n};\n/** @internal */\nconst proto = {\n  [ChannelTypeId]: channelVariance,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const isChannel = u => hasProperty(u, ChannelTypeId) || Effect.isEffect(u);\n/** @internal */\nexport const acquireReleaseOut = /*#__PURE__*/dual(2, (self, release) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BRACKET_OUT;\n  op.acquire = () => self;\n  op.finalizer = release;\n  return op;\n});\n/** @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(succeed, f);\n  return op;\n});\n/** @internal */\nexport const collectElements = self => {\n  return suspend(() => {\n    const builder = [];\n    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [Chunk.fromIterable(builder), value]));\n  });\n};\n/** @internal */\nconst collectElementsReader = builder => readWith({\n  onInput: outElem => flatMap(sync(() => {\n    builder.push(outElem);\n  }), () => collectElementsReader(builder)),\n  onFailure: fail,\n  onDone: succeedNow\n});\n/** @internal */\nexport const concatAll = channels => concatAllWith(channels, constVoid, constVoid);\n/** @internal */\nexport const concatAllWith = (channels, f, g) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = f;\n  op.combineAll = g;\n  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());\n  op.onEmit = () => childExecutorDecision.Continue;\n  op.value = () => channels;\n  op.k = identity;\n  return op;\n};\n/** @internal */\nexport const concatMapWith = /*#__PURE__*/dual(4, (self, f, g, h) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = g;\n  op.combineAll = h;\n  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());\n  op.onEmit = () => childExecutorDecision.Continue;\n  op.value = () => self;\n  op.k = f;\n  return op;\n});\n/** @internal */\nexport const concatMapWithCustom = /*#__PURE__*/dual(6, (self, f, g, h, onPull, onEmit) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = g;\n  op.combineAll = h;\n  op.onPull = onPull;\n  op.onEmit = onEmit;\n  op.value = () => self;\n  op.k = f;\n  return op;\n});\n/** @internal */\nexport const embedInput = /*#__PURE__*/dual(2, (self, input) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BRIDGE;\n  op.input = input;\n  op.channel = self;\n  return op;\n});\n/** @internal */\nexport const ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_ENSURING;\n  op.channel = self;\n  op.finalizer = finalizer;\n  return op;\n});\n/** @internal */\nexport const fail = error => failCause(Cause.fail(error));\n/** @internal */\nexport const failSync = evaluate => failCauseSync(() => Cause.fail(evaluate()));\n/** @internal */\nexport const failCause = cause => failCauseSync(() => cause);\n/** @internal */\nexport const failCauseSync = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FAIL;\n  op.error = evaluate;\n  return op;\n};\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(f, failCause);\n  return op;\n});\n/** @internal */\nexport const foldCauseChannel = /*#__PURE__*/dual(2, (self, options) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);\n  return op;\n});\n/** @internal */\nexport const fromEffect = effect => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FROM_EFFECT;\n  op.effect = () => effect;\n  return op;\n};\n/** @internal */\nexport const pipeTo = /*#__PURE__*/dual(2, (self, that) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PIPE_TO;\n  op.left = () => self;\n  op.right = () => that;\n  return op;\n});\n/** @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, env) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PROVIDE;\n  op.context = () => env;\n  op.inner = self;\n  return op;\n});\n/** @internal */\nexport const readOrFail = error => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_READ;\n  op.more = succeed;\n  op.done = new ContinuationKImpl(() => fail(error), () => fail(error));\n  return op;\n};\n/** @internal */\nexport const readWith = options => readWithCause({\n  onInput: options.onInput,\n  onFailure: cause => Either.match(Cause.failureOrCause(cause), {\n    onLeft: options.onFailure,\n    onRight: failCause\n  }),\n  onDone: options.onDone\n});\n/** @internal */\nexport const readWithCause = options => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_READ;\n  op.more = options.onInput;\n  op.done = new ContinuationKImpl(options.onDone, options.onFailure);\n  return op;\n};\n/** @internal */\nexport const succeed = value => sync(() => value);\n/** @internal */\nexport const succeedNow = result => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUCCEED_NOW;\n  op.terminal = result;\n  return op;\n};\n/** @internal */\nexport const suspend = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUSPEND;\n  op.channel = evaluate;\n  return op;\n};\nexport const sync = evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUCCEED;\n  op.evaluate = evaluate;\n  return op;\n};\nconst void_ = /*#__PURE__*/succeedNow(void 0);\nexport { /** @internal */\nvoid_ as void };\n/** @internal */\nexport const write = out => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_EMIT;\n  op.out = out;\n  return op;\n};\n//# sourceMappingURL=core-stream.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
