{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/scopedCache.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Context from \"../Context.js\";\nimport * as Data from \"../Data.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as Equal from \"../Equal.js\";\nimport * as Exit from \"../Exit.js\";\nimport { pipe } from \"../Function.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport * as MutableHashMap from \"../MutableHashMap.js\";\nimport * as MutableQueue from \"../MutableQueue.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Scope from \"../Scope.js\";\nimport * as cache_ from \"./cache.js\";\nimport * as effect from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\n/** @internal */\nexport const makeCacheState = (map, keys, accesses, updating, hits, misses) => ({\n  map,\n  keys,\n  accesses,\n  updating,\n  hits,\n  misses\n});\n/**\n * Constructs an initial cache state.\n *\n * @internal\n */\nexport const initialCacheState = () => makeCacheState(MutableHashMap.empty(), cache_.makeKeySet(), MutableQueue.unbounded(), MutableRef.make(false), 0, 0);\n/** @internal */\nexport const complete = (key, exit, ownerCount, entryStats, timeToLive) => Data.struct({\n  _tag: \"Complete\",\n  key,\n  exit,\n  ownerCount,\n  entryStats,\n  timeToLive\n});\n/** @internal */\nexport const pending = (key, scoped) => Data.struct({\n  _tag: \"Pending\",\n  key,\n  scoped\n});\n/** @internal */\nexport const refreshing = (scoped, complete) => Data.struct({\n  _tag: \"Refreshing\",\n  scoped,\n  complete\n});\n/** @internal */\nexport const toScoped = self => Exit.matchEffect(self.exit, {\n  onFailure: cause => core.failCause(cause),\n  onSuccess: ([value]) => fiberRuntime.acquireRelease(core.as(core.sync(() => MutableRef.incrementAndGet(self.ownerCount)), value), () => releaseOwner(self))\n});\n/** @internal */\nexport const releaseOwner = self => Exit.matchEffect(self.exit, {\n  onFailure: () => core.void,\n  onSuccess: ([, finalizer]) => core.flatMap(core.sync(() => MutableRef.decrementAndGet(self.ownerCount)), numOwner => effect.when(finalizer(Exit.void), () => numOwner === 0))\n});\n/** @internal */\nconst ScopedCacheSymbolKey = \"effect/ScopedCache\";\n/** @internal */\nexport const ScopedCacheTypeId = /*#__PURE__*/Symbol.for(ScopedCacheSymbolKey);\nconst scopedCacheVariance = {\n  /* c8 ignore next */\n  _Key: _ => _,\n  /* c8 ignore next */\n  _Error: _ => _,\n  /* c8 ignore next */\n  _Value: _ => _\n};\nclass ScopedCacheImpl {\n  capacity;\n  scopedLookup;\n  clock;\n  timeToLive;\n  context;\n  [ScopedCacheTypeId] = scopedCacheVariance;\n  cacheState;\n  constructor(capacity, scopedLookup, clock, timeToLive, context) {\n    this.capacity = capacity;\n    this.scopedLookup = scopedLookup;\n    this.clock = clock;\n    this.timeToLive = timeToLive;\n    this.context = context;\n    this.cacheState = initialCacheState();\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  get cacheStats() {\n    return core.sync(() => cache_.makeCacheStats({\n      hits: this.cacheState.hits,\n      misses: this.cacheState.misses,\n      size: MutableHashMap.size(this.cacheState.map)\n    }));\n  }\n  getOption(key) {\n    return core.suspend(() => Option.match(MutableHashMap.get(this.cacheState.map, key), {\n      onNone: () => effect.succeedNone,\n      onSome: value => core.flatten(this.resolveMapValue(value))\n    }));\n  }\n  getOptionComplete(key) {\n    return core.suspend(() => Option.match(MutableHashMap.get(this.cacheState.map, key), {\n      onNone: () => effect.succeedNone,\n      onSome: value => core.flatten(this.resolveMapValue(value, true))\n    }));\n  }\n  contains(key) {\n    return core.sync(() => MutableHashMap.has(this.cacheState.map, key));\n  }\n  entryStats(key) {\n    return core.sync(() => {\n      const value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n      if (value === undefined) {\n        return Option.none();\n      }\n      switch (value._tag) {\n        case \"Complete\":\n          {\n            return Option.some(cache_.makeEntryStats(value.entryStats.loadedMillis));\n          }\n        case \"Pending\":\n          {\n            return Option.none();\n          }\n        case \"Refreshing\":\n          {\n            return Option.some(cache_.makeEntryStats(value.complete.entryStats.loadedMillis));\n          }\n      }\n    });\n  }\n  get(key) {\n    return pipe(this.lookupValueOf(key), effect.memoize, core.flatMap(lookupValue => core.suspend(() => {\n      let k = undefined;\n      let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n      if (value === undefined) {\n        k = cache_.makeMapKey(key);\n        if (MutableHashMap.has(this.cacheState.map, key)) {\n          value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n        } else {\n          MutableHashMap.set(this.cacheState.map, key, pending(k, lookupValue));\n        }\n      }\n      if (value === undefined) {\n        this.trackMiss();\n        return core.zipRight(this.ensureMapSizeNotExceeded(k), lookupValue);\n      }\n      return core.map(this.resolveMapValue(value), core.flatMap(Option.match({\n        onNone: () => {\n          const val = value;\n          const current = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n          if (Equal.equals(current, value)) {\n            MutableHashMap.remove(this.cacheState.map, key);\n          }\n          return pipe(this.ensureMapSizeNotExceeded(val.key), core.zipRight(releaseOwner(val)), core.zipRight(this.get(key)));\n        },\n        onSome: core.succeed\n      })));\n    })), core.flatten);\n  }\n  invalidate(key) {\n    return core.suspend(() => {\n      if (MutableHashMap.has(this.cacheState.map, key)) {\n        const mapValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n        MutableHashMap.remove(this.cacheState.map, key);\n        switch (mapValue._tag) {\n          case \"Complete\":\n            {\n              return releaseOwner(mapValue);\n            }\n          case \"Pending\":\n            {\n              return core.void;\n            }\n          case \"Refreshing\":\n            {\n              return releaseOwner(mapValue.complete);\n            }\n        }\n      }\n      return core.void;\n    });\n  }\n  get invalidateAll() {\n    return fiberRuntime.forEachConcurrentDiscard(HashSet.fromIterable(Array.from(this.cacheState.map).map(([key]) => key)), key => this.invalidate(key), false, false);\n  }\n  refresh(key) {\n    return pipe(this.lookupValueOf(key), effect.memoize, core.flatMap(scoped => {\n      let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n      let newKey = undefined;\n      if (value === undefined) {\n        newKey = cache_.makeMapKey(key);\n        if (MutableHashMap.has(this.cacheState.map, key)) {\n          value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n        } else {\n          MutableHashMap.set(this.cacheState.map, key, pending(newKey, scoped));\n        }\n      }\n      let finalScoped;\n      if (value === undefined) {\n        finalScoped = core.zipRight(this.ensureMapSizeNotExceeded(newKey), scoped);\n      } else {\n        switch (value._tag) {\n          case \"Complete\":\n            {\n              if (this.hasExpired(value.timeToLive)) {\n                finalScoped = core.succeed(this.get(key));\n              } else {\n                const current = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n                if (Equal.equals(current, value)) {\n                  const mapValue = refreshing(scoped, value);\n                  MutableHashMap.set(this.cacheState.map, key, mapValue);\n                  finalScoped = scoped;\n                } else {\n                  finalScoped = core.succeed(this.get(key));\n                }\n              }\n              break;\n            }\n          case \"Pending\":\n            {\n              finalScoped = value.scoped;\n              break;\n            }\n          case \"Refreshing\":\n            {\n              finalScoped = value.scoped;\n              break;\n            }\n        }\n      }\n      return core.flatMap(finalScoped, s => fiberRuntime.scopedEffect(core.asVoid(s)));\n    }));\n  }\n  get size() {\n    return core.sync(() => MutableHashMap.size(this.cacheState.map));\n  }\n  resolveMapValue(value, ignorePending = false) {\n    switch (value._tag) {\n      case \"Complete\":\n        {\n          this.trackHit();\n          if (this.hasExpired(value.timeToLive)) {\n            return core.succeed(effect.succeedNone);\n          }\n          return core.as(this.ensureMapSizeNotExceeded(value.key), effect.asSome(toScoped(value)));\n        }\n      case \"Pending\":\n        {\n          this.trackHit();\n          if (ignorePending) {\n            return core.succeed(effect.succeedNone);\n          }\n          return core.zipRight(this.ensureMapSizeNotExceeded(value.key), core.map(value.scoped, effect.asSome));\n        }\n      case \"Refreshing\":\n        {\n          this.trackHit();\n          if (this.hasExpired(value.complete.timeToLive)) {\n            if (ignorePending) {\n              return core.succeed(effect.succeedNone);\n            }\n            return core.zipRight(this.ensureMapSizeNotExceeded(value.complete.key), core.map(value.scoped, effect.asSome));\n          }\n          return core.as(this.ensureMapSizeNotExceeded(value.complete.key), effect.asSome(toScoped(value.complete)));\n        }\n    }\n  }\n  lookupValueOf(key) {\n    return pipe(core.onInterrupt(core.flatMap(Scope.make(), scope => pipe(this.scopedLookup(key), core.provideContext(pipe(this.context, Context.add(Scope.Scope, scope))), core.exit, core.map(exit => [exit, exit => Scope.close(scope, exit)]))), () => core.sync(() => MutableHashMap.remove(this.cacheState.map, key))), core.flatMap(([exit, release]) => {\n      const now = this.clock.unsafeCurrentTimeMillis();\n      const expiredAt = now + Duration.toMillis(this.timeToLive(exit));\n      switch (exit._tag) {\n        case \"Success\":\n          {\n            const exitWithFinalizer = Exit.succeed([exit.value, release]);\n            const completedResult = complete(cache_.makeMapKey(key), exitWithFinalizer, MutableRef.make(1), cache_.makeEntryStats(now), expiredAt);\n            let previousValue = undefined;\n            if (MutableHashMap.has(this.cacheState.map, key)) {\n              previousValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n            }\n            MutableHashMap.set(this.cacheState.map, key, completedResult);\n            return core.sync(() => core.flatten(core.as(this.cleanMapValue(previousValue), toScoped(completedResult))));\n          }\n        case \"Failure\":\n          {\n            const completedResult = complete(cache_.makeMapKey(key), exit, MutableRef.make(0), cache_.makeEntryStats(now), expiredAt);\n            let previousValue = undefined;\n            if (MutableHashMap.has(this.cacheState.map, key)) {\n              previousValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key));\n            }\n            MutableHashMap.set(this.cacheState.map, key, completedResult);\n            return core.zipRight(release(exit), core.sync(() => core.flatten(core.as(this.cleanMapValue(previousValue), toScoped(completedResult)))));\n          }\n      }\n    }), effect.memoize, core.flatten);\n  }\n  hasExpired(timeToLive) {\n    return this.clock.unsafeCurrentTimeMillis() > timeToLive;\n  }\n  trackHit() {\n    this.cacheState.hits = this.cacheState.hits + 1;\n  }\n  trackMiss() {\n    this.cacheState.misses = this.cacheState.misses + 1;\n  }\n  trackAccess(key) {\n    const cleanedKeys = [];\n    MutableQueue.offer(this.cacheState.accesses, key);\n    if (MutableRef.compareAndSet(this.cacheState.updating, false, true)) {\n      let loop = true;\n      while (loop) {\n        const key = MutableQueue.poll(this.cacheState.accesses, MutableQueue.EmptyMutableQueue);\n        if (key === MutableQueue.EmptyMutableQueue) {\n          loop = false;\n        } else {\n          this.cacheState.keys.add(key);\n        }\n      }\n      let size = MutableHashMap.size(this.cacheState.map);\n      loop = size > this.capacity;\n      while (loop) {\n        const key = this.cacheState.keys.remove();\n        if (key === undefined) {\n          loop = false;\n        } else {\n          if (MutableHashMap.has(this.cacheState.map, key.current)) {\n            const removed = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key.current));\n            MutableHashMap.remove(this.cacheState.map, key.current);\n            size = size - 1;\n            cleanedKeys.push(removed);\n            loop = size > this.capacity;\n          }\n        }\n      }\n      MutableRef.set(this.cacheState.updating, false);\n    }\n    return cleanedKeys;\n  }\n  cleanMapValue(mapValue) {\n    if (mapValue === undefined) {\n      return core.void;\n    }\n    switch (mapValue._tag) {\n      case \"Complete\":\n        {\n          return releaseOwner(mapValue);\n        }\n      case \"Pending\":\n        {\n          return core.void;\n        }\n      case \"Refreshing\":\n        {\n          return releaseOwner(mapValue.complete);\n        }\n    }\n  }\n  ensureMapSizeNotExceeded(key) {\n    return fiberRuntime.forEachConcurrentDiscard(this.trackAccess(key), cleanedMapValue => this.cleanMapValue(cleanedMapValue), false, false);\n  }\n}\n/** @internal */\nexport const make = options => {\n  const timeToLive = Duration.decode(options.timeToLive);\n  return makeWith({\n    capacity: options.capacity,\n    lookup: options.lookup,\n    timeToLive: () => timeToLive\n  });\n};\n/** @internal */\nexport const makeWith = options => core.flatMap(effect.clock, clock => buildWith(options.capacity, options.lookup, clock, exit => Duration.decode(options.timeToLive(exit))));\nconst buildWith = (capacity, scopedLookup, clock, timeToLive) => fiberRuntime.acquireRelease(core.flatMap(core.context(), context => core.sync(() => new ScopedCacheImpl(capacity, scopedLookup, clock, timeToLive, context))), cache => cache.invalidateAll);\n//# sourceMappingURL=scopedCache.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
