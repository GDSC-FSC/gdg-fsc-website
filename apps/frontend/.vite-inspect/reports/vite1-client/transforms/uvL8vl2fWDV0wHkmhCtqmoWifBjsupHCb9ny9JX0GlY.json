{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/stm/core.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Cause from \"../../Cause.js\";\nimport * as Context from \"../../Context.js\";\nimport * as Effect from \"../../Effect.js\";\nimport * as Either from \"../../Either.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Exit from \"../../Exit.js\";\nimport * as FiberRef from \"../../FiberRef.js\";\nimport { constVoid, dual, pipe } from \"../../Function.js\";\nimport * as Hash from \"../../Hash.js\";\nimport { pipeArguments } from \"../../Pipeable.js\";\nimport { hasProperty } from \"../../Predicate.js\";\nimport { internalCall, YieldWrap } from \"../../Utils.js\";\nimport { ChannelTypeId } from \"../core-stream.js\";\nimport { withFiberRuntime } from \"../core.js\";\nimport { effectVariance, StreamTypeId } from \"../effectable.js\";\nimport { OP_COMMIT } from \"../opCodes/effect.js\";\nimport { SingleShotGen } from \"../singleShotGen.js\";\nimport { SinkTypeId } from \"../sink.js\";\nimport * as Journal from \"./journal.js\";\nimport * as OpCodes from \"./opCodes/stm.js\";\nimport * as TExitOpCodes from \"./opCodes/tExit.js\";\nimport * as TryCommitOpCodes from \"./opCodes/tryCommit.js\";\nimport * as STMState from \"./stmState.js\";\nimport * as TExit from \"./tExit.js\";\nimport * as TryCommit from \"./tryCommit.js\";\nimport * as TxnId from \"./txnId.js\";\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n/** @internal */\nexport const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\nconst stmVariance = {\n  /* c8 ignore next */\n  _R: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _\n};\n/** @internal */\nclass STMPrimitive {\n  effect_instruction_i0;\n  _op = OP_COMMIT;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  [Effect.EffectTypeId];\n  [StreamTypeId];\n  [SinkTypeId];\n  [ChannelTypeId];\n  get [STMTypeId]() {\n    return stmVariance;\n  }\n  constructor(effect_instruction_i0) {\n    this.effect_instruction_i0 = effect_instruction_i0;\n    this[Effect.EffectTypeId] = effectVariance;\n    this[StreamTypeId] = stmVariance;\n    this[SinkTypeId] = stmVariance;\n    this[ChannelTypeId] = stmVariance;\n  }\n  [Equal.symbol](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this));\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n  commit() {\n    return unsafeAtomically(this, constVoid, constVoid);\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nexport const isSTM = u => hasProperty(u, STMTypeId);\n/** @internal */\nexport const commit = self => unsafeAtomically(self, constVoid, constVoid);\n/** @internal */\nexport const unsafeAtomically = (self, onDone, onInterrupt) => withFiberRuntime(state => {\n  const fiberId = state.id();\n  const env = state.getFiberRef(FiberRef.currentContext);\n  const scheduler = state.getFiberRef(FiberRef.currentScheduler);\n  const priority = state.getFiberRef(FiberRef.currentSchedulingPriority);\n  const commitResult = tryCommitSync(fiberId, self, env, scheduler, priority);\n  switch (commitResult._tag) {\n    case TryCommitOpCodes.OP_DONE:\n      {\n        onDone(commitResult.exit);\n        return commitResult.exit;\n      }\n    case TryCommitOpCodes.OP_SUSPEND:\n      {\n        const txnId = TxnId.make();\n        const state = {\n          value: STMState.running\n        };\n        const effect = Effect.async(k => tryCommitAsync(fiberId, self, txnId, state, env, scheduler, priority, k));\n        return Effect.uninterruptibleMask(restore => pipe(restore(effect), Effect.catchAllCause(cause => {\n          let currentState = state.value;\n          if (STMState.isRunning(currentState)) {\n            state.value = STMState.interrupted;\n          }\n          currentState = state.value;\n          if (STMState.isDone(currentState)) {\n            onDone(currentState.exit);\n            return currentState.exit;\n          }\n          onInterrupt();\n          return Effect.failCause(cause);\n        })));\n      }\n  }\n});\n/** @internal */\nconst tryCommit = (fiberId, stm, state, env, scheduler, priority) => {\n  const journal = new Map();\n  const tExit = new STMDriver(stm, journal, fiberId, env).run();\n  const analysis = Journal.analyzeJournal(journal);\n  if (analysis === Journal.JournalAnalysisReadWrite) {\n    Journal.commitJournal(journal);\n  } else if (analysis === Journal.JournalAnalysisInvalid) {\n    throw new Error(\"BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  switch (tExit._tag) {\n    case TExitOpCodes.OP_SUCCEED:\n      {\n        state.value = STMState.fromTExit(tExit);\n        return completeTodos(Exit.succeed(tExit.value), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_FAIL:\n      {\n        state.value = STMState.fromTExit(tExit);\n        const cause = Cause.fail(tExit.error);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_DIE:\n      {\n        state.value = STMState.fromTExit(tExit);\n        const cause = Cause.die(tExit.defect);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_INTERRUPT:\n      {\n        state.value = STMState.fromTExit(tExit);\n        const cause = Cause.interrupt(fiberId);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_RETRY:\n      {\n        return TryCommit.suspend(journal);\n      }\n  }\n};\n/** @internal */\nconst tryCommitSync = (fiberId, stm, env, scheduler, priority) => {\n  const journal = new Map();\n  const tExit = new STMDriver(stm, journal, fiberId, env).run();\n  const analysis = Journal.analyzeJournal(journal);\n  if (analysis === Journal.JournalAnalysisReadWrite && TExit.isSuccess(tExit)) {\n    Journal.commitJournal(journal);\n  } else if (analysis === Journal.JournalAnalysisInvalid) {\n    throw new Error(\"BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  switch (tExit._tag) {\n    case TExitOpCodes.OP_SUCCEED:\n      {\n        return completeTodos(Exit.succeed(tExit.value), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_FAIL:\n      {\n        const cause = Cause.fail(tExit.error);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_DIE:\n      {\n        const cause = Cause.die(tExit.defect);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_INTERRUPT:\n      {\n        const cause = Cause.interrupt(fiberId);\n        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);\n      }\n    case TExitOpCodes.OP_RETRY:\n      {\n        return TryCommit.suspend(journal);\n      }\n  }\n};\n/** @internal */\nconst tryCommitAsync = (fiberId, self, txnId, state, context, scheduler, priority, k) => {\n  if (STMState.isRunning(state.value)) {\n    const result = tryCommit(fiberId, self, state, context, scheduler, priority);\n    switch (result._tag) {\n      case TryCommitOpCodes.OP_DONE:\n        {\n          completeTryCommit(result.exit, k);\n          break;\n        }\n      case TryCommitOpCodes.OP_SUSPEND:\n        {\n          Journal.addTodo(txnId, result.journal, () => tryCommitAsync(fiberId, self, txnId, state, context, scheduler, priority, k));\n          break;\n        }\n    }\n  }\n};\n/** @internal */\nconst completeTodos = (exit, journal, scheduler, priority) => {\n  const todos = Journal.collectTodos(journal);\n  if (todos.size > 0) {\n    scheduler.scheduleTask(() => Journal.execTodos(todos), priority);\n  }\n  return TryCommit.done(exit);\n};\n/** @internal */\nconst completeTryCommit = (exit, k) => {\n  k(exit);\n};\n/** @internal */\nexport const context = () => effect((_, __, env) => env);\n/** @internal */\nexport const contextWith = f => map(context(), f);\n/** @internal */\nexport const contextWithSTM = f => flatMap(context(), f);\n/** @internal */\nexport class STMDriver {\n  self;\n  journal;\n  fiberId;\n  contStack = [];\n  env;\n  constructor(self, journal, fiberId, r0) {\n    this.self = self;\n    this.journal = journal;\n    this.fiberId = fiberId;\n    this.env = r0;\n  }\n  getEnv() {\n    return this.env;\n  }\n  pushStack(cont) {\n    this.contStack.push(cont);\n  }\n  popStack() {\n    return this.contStack.pop();\n  }\n  nextSuccess() {\n    let current = this.popStack();\n    while (current !== undefined && current.effect_instruction_i0 !== OpCodes.OP_ON_SUCCESS) {\n      current = this.popStack();\n    }\n    return current;\n  }\n  nextFailure() {\n    let current = this.popStack();\n    while (current !== undefined && current.effect_instruction_i0 !== OpCodes.OP_ON_FAILURE) {\n      current = this.popStack();\n    }\n    return current;\n  }\n  nextRetry() {\n    let current = this.popStack();\n    while (current !== undefined && current.effect_instruction_i0 !== OpCodes.OP_ON_RETRY) {\n      current = this.popStack();\n    }\n    return current;\n  }\n  run() {\n    let curr = this.self;\n    let exit = undefined;\n    while (exit === undefined && curr !== undefined) {\n      try {\n        const current = curr;\n        if (current) {\n          switch (current._op) {\n            case \"Tag\":\n              {\n                curr = effect((_, __, env) => Context.unsafeGet(env, current));\n                break;\n              }\n            case \"Left\":\n              {\n                curr = fail(current.left);\n                break;\n              }\n            case \"None\":\n              {\n                curr = fail(new Cause.NoSuchElementException());\n                break;\n              }\n            case \"Right\":\n              {\n                curr = succeed(current.right);\n                break;\n              }\n            case \"Some\":\n              {\n                curr = succeed(current.value);\n                break;\n              }\n            case \"Commit\":\n              {\n                switch (current.effect_instruction_i0) {\n                  case OpCodes.OP_DIE:\n                    {\n                      exit = TExit.die(internalCall(() => current.effect_instruction_i1()));\n                      break;\n                    }\n                  case OpCodes.OP_FAIL:\n                    {\n                      const cont = this.nextFailure();\n                      if (cont === undefined) {\n                        exit = TExit.fail(internalCall(() => current.effect_instruction_i1()));\n                      } else {\n                        curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));\n                      }\n                      break;\n                    }\n                  case OpCodes.OP_RETRY:\n                    {\n                      const cont = this.nextRetry();\n                      if (cont === undefined) {\n                        exit = TExit.retry;\n                      } else {\n                        curr = internalCall(() => cont.effect_instruction_i2());\n                      }\n                      break;\n                    }\n                  case OpCodes.OP_INTERRUPT:\n                    {\n                      exit = TExit.interrupt(this.fiberId);\n                      break;\n                    }\n                  case OpCodes.OP_WITH_STM_RUNTIME:\n                    {\n                      curr = internalCall(() => current.effect_instruction_i1(this));\n                      break;\n                    }\n                  case OpCodes.OP_ON_SUCCESS:\n                  case OpCodes.OP_ON_FAILURE:\n                  case OpCodes.OP_ON_RETRY:\n                    {\n                      this.pushStack(current);\n                      curr = current.effect_instruction_i1;\n                      break;\n                    }\n                  case OpCodes.OP_PROVIDE:\n                    {\n                      const env = this.env;\n                      this.env = internalCall(() => current.effect_instruction_i2(env));\n                      curr = pipe(current.effect_instruction_i1, ensuring(sync(() => this.env = env)));\n                      break;\n                    }\n                  case OpCodes.OP_SUCCEED:\n                    {\n                      const value = current.effect_instruction_i1;\n                      const cont = this.nextSuccess();\n                      if (cont === undefined) {\n                        exit = TExit.succeed(value);\n                      } else {\n                        curr = internalCall(() => cont.effect_instruction_i2(value));\n                      }\n                      break;\n                    }\n                  case OpCodes.OP_SYNC:\n                    {\n                      const value = internalCall(() => current.effect_instruction_i1());\n                      const cont = this.nextSuccess();\n                      if (cont === undefined) {\n                        exit = TExit.succeed(value);\n                      } else {\n                        curr = internalCall(() => cont.effect_instruction_i2(value));\n                      }\n                      break;\n                    }\n                }\n                break;\n              }\n          }\n        }\n      } catch (e) {\n        curr = die(e);\n      }\n    }\n    return exit;\n  }\n}\n/** @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, f) => {\n  const stm = new STMPrimitive(OpCodes.OP_ON_FAILURE);\n  stm.effect_instruction_i1 = self;\n  stm.effect_instruction_i2 = f;\n  return stm;\n});\n/** @internal */\nexport const mapInputContext = /*#__PURE__*/dual(2, (self, f) => {\n  const stm = new STMPrimitive(OpCodes.OP_PROVIDE);\n  stm.effect_instruction_i1 = self;\n  stm.effect_instruction_i2 = f;\n  return stm;\n});\n/** @internal */\nexport const die = defect => dieSync(() => defect);\n/** @internal */\nexport const dieMessage = message => dieSync(() => new Cause.RuntimeException(message));\n/** @internal */\nexport const dieSync = evaluate => {\n  const stm = new STMPrimitive(OpCodes.OP_DIE);\n  stm.effect_instruction_i1 = evaluate;\n  return stm;\n};\n/** @internal */\nexport const effect = f => withSTMRuntime(_ => succeed(f(_.journal, _.fiberId, _.getEnv())));\n/** @internal */\nexport const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => matchSTM(self, {\n  onFailure: e => zipRight(finalizer, fail(e)),\n  onSuccess: a => zipRight(finalizer, succeed(a))\n}));\n/** @internal */\nexport const fail = error => failSync(() => error);\n/** @internal */\nexport const failSync = evaluate => {\n  const stm = new STMPrimitive(OpCodes.OP_FAIL);\n  stm.effect_instruction_i1 = evaluate;\n  return stm;\n};\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const stm = new STMPrimitive(OpCodes.OP_ON_SUCCESS);\n  stm.effect_instruction_i1 = self;\n  stm.effect_instruction_i2 = f;\n  return stm;\n});\n/** @internal */\nexport const matchSTM = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => pipe(self, map(Either.right), catchAll(e => pipe(onFailure(e), map(Either.left))), flatMap(either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return succeed(either.left);\n      }\n    case \"Right\":\n      {\n        return onSuccess(either.right);\n      }\n  }\n})));\n/** @internal */\nexport const withSTMRuntime = f => {\n  const stm = new STMPrimitive(OpCodes.OP_WITH_STM_RUNTIME);\n  stm.effect_instruction_i1 = f;\n  return stm;\n};\n/** @internal */\nexport const interrupt = /*#__PURE__*/withSTMRuntime(_ => {\n  const stm = new STMPrimitive(OpCodes.OP_INTERRUPT);\n  stm.effect_instruction_i1 = _.fiberId;\n  return stm;\n});\n/** @internal */\nexport const interruptAs = fiberId => {\n  const stm = new STMPrimitive(OpCodes.OP_INTERRUPT);\n  stm.effect_instruction_i1 = fiberId;\n  return stm;\n};\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => pipe(self, flatMap(a => sync(() => f(a)))));\n/** @internal */\nexport const orTry = /*#__PURE__*/dual(2, (self, that) => {\n  const stm = new STMPrimitive(OpCodes.OP_ON_RETRY);\n  stm.effect_instruction_i1 = self;\n  stm.effect_instruction_i2 = that;\n  return stm;\n});\n/** @internal */\nexport const retry = /*#__PURE__*/new STMPrimitive(OpCodes.OP_RETRY);\n/** @internal */\nexport const succeed = value => {\n  const stm = new STMPrimitive(OpCodes.OP_SUCCEED);\n  stm.effect_instruction_i1 = value;\n  return stm;\n};\n/** @internal */\nexport const sync = evaluate => {\n  const stm = new STMPrimitive(OpCodes.OP_SYNC);\n  stm.effect_instruction_i1 = evaluate;\n  return stm;\n};\n/** @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => pipe(self, zipWith(that, (a, a1) => [a, a1])));\n/** @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => pipe(self, flatMap(a => pipe(that, map(() => a)))));\n/** @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => pipe(self, flatMap(() => that)));\n/** @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => pipe(self, flatMap(a => pipe(that, map(b => f(a, b))))));\n//# sourceMappingURL=core.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628706,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
