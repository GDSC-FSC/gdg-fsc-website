{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/HttpApiSchema.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Effect from \"effect/Effect\";\nimport * as Effectable from \"effect/Effectable\";\nimport { constant, constVoid, dual } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport * as Option from \"effect/Option\";\nimport { hasProperty } from \"effect/Predicate\";\nimport * as Schema from \"effect/Schema\";\nimport * as AST from \"effect/SchemaAST\";\nimport * as Struct from \"effect/Struct\";\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipart = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationMultipart\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipartStream = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationMultipartStream\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationStatus = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationStatus\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEmptyDecodeable = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationEmptyDecodeable\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEncoding = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationEncoding\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationParam = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationParam\");\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const extractAnnotations = ast => {\n  const result = {};\n  if (AnnotationStatus in ast) {\n    result[AnnotationStatus] = ast[AnnotationStatus];\n  }\n  if (AnnotationEmptyDecodeable in ast) {\n    result[AnnotationEmptyDecodeable] = ast[AnnotationEmptyDecodeable];\n  }\n  if (AnnotationEncoding in ast) {\n    result[AnnotationEncoding] = ast[AnnotationEncoding];\n  }\n  if (AnnotationParam in ast) {\n    result[AnnotationParam] = ast[AnnotationParam];\n  }\n  if (AnnotationMultipart in ast) {\n    result[AnnotationMultipart] = ast[AnnotationMultipart];\n  }\n  if (AnnotationMultipartStream in ast) {\n    result[AnnotationMultipartStream] = ast[AnnotationMultipartStream];\n  }\n  return result;\n};\nconst mergedAnnotations = ast => ast._tag === \"Transformation\" ? {\n  ...ast.to.annotations,\n  ...ast.annotations\n} : ast.annotations;\nconst getAnnotation = (ast, key) => mergedAnnotations(ast)[key];\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getStatus = (ast, defaultStatus) => getAnnotation(ast, AnnotationStatus) ?? defaultStatus;\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEmptyDecodeable = ast => getAnnotation(ast, AnnotationEmptyDecodeable) ?? false;\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipart = ast => getAnnotation(ast, AnnotationMultipart);\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipartStream = ast => getAnnotation(ast, AnnotationMultipartStream);\nconst encodingJson = {\n  kind: \"Json\",\n  contentType: \"application/json\"\n};\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEncoding = (ast, fallback = encodingJson) => getAnnotation(ast, AnnotationEncoding) ?? fallback;\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getParam = ast => {\n  const annotations = ast._tag === \"PropertySignatureTransformation\" ? ast.to.annotations : ast.annotations;\n  return annotations[AnnotationParam]?.name;\n};\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const annotations = annotations => {\n  const result = Struct.omit(annotations, \"status\");\n  if (annotations.status !== undefined) {\n    result[AnnotationStatus] = annotations.status;\n  }\n  return result;\n};\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const isVoid = ast => {\n  switch (ast._tag) {\n    case \"VoidKeyword\":\n      {\n        return true;\n      }\n    case \"Transformation\":\n      {\n        return isVoid(ast.from);\n      }\n    case \"Suspend\":\n      {\n        return isVoid(ast.f());\n      }\n    default:\n      {\n        return false;\n      }\n  }\n};\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccessAST = ast => getStatus(ast, isVoid(ast) ? 204 : 200);\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccess = self => getStatusSuccessAST(self.ast);\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusErrorAST = ast => getStatus(ast, 500);\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusError = self => getStatusErrorAST(self.ast);\n/**\n * Extracts all individual types from a union type recursively.\n *\n * **Details**\n *\n * This function traverses an AST and collects all the types within a union,\n * even if they are nested. It ensures that every type in a union (including\n * deeply nested unions) is included in the resulting array. The returned array\n * contains each type as an individual AST node, preserving the order in which\n * they appear.\n *\n * @internal\n */\nexport const extractUnionTypes = ast => {\n  function process(ast) {\n    if (AST.isUnion(ast)) {\n      for (const type of ast.types) {\n        process(type);\n      }\n    } else {\n      out.push(ast);\n    }\n  }\n  const out = [];\n  process(ast);\n  return out;\n};\n/** @internal */\nexport const UnionUnifyAST = (self, that) => AST.Union.make(Array.from(new Set([...extractUnionTypes(self), ...extractUnionTypes(that)])));\n/**\n * @since 1.0.0\n */\nexport const UnionUnify = (self, that) => Schema.make(UnionUnifyAST(self.ast, that.ast));\n/**\n * @since 1.0.0\n * @category path params\n */\nexport const param = /*#__PURE__*/dual(2, (name, schema) => {\n  const annotations = {\n    [AnnotationParam]: {\n      name,\n      schema\n    }\n  };\n  if (Schema.isSchema(schema)) {\n    const identifier = AST.getIdentifierAnnotation(schema.ast);\n    if (Option.isSome(identifier)) {\n      annotations[AST.IdentifierAnnotationId] = identifier.value;\n    }\n  }\n  return schema.annotations(annotations);\n});\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Empty = status => Schema.Void.annotations(annotations({\n  status\n}));\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const asEmpty = /*#__PURE__*/dual(2, (self, options) => Schema.transform(Schema.Void.annotations(self.ast.annotations), Schema.typeSchema(self), {\n  decode: options.decode,\n  encode: constVoid\n}).annotations(annotations({\n  status: options.status,\n  [AnnotationEmptyDecodeable]: true\n})));\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Created = /*#__PURE__*/Empty(201);\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Accepted = /*#__PURE__*/Empty(202);\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const NoContent = /*#__PURE__*/Empty(204);\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/Multipart\");\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const Multipart = (self, options) => self.annotations({\n  [AnnotationMultipart]: options ?? {}\n});\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStreamTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/HttpApiSchema/MultipartStream\");\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStream = (self, options) => self.annotations({\n  [AnnotationMultipartStream]: options ?? {}\n});\nconst defaultContentType = encoding => {\n  switch (encoding) {\n    case \"Json\":\n      {\n        return \"application/json\";\n      }\n    case \"UrlParams\":\n      {\n        return \"application/x-www-form-urlencoded\";\n      }\n    case \"Uint8Array\":\n      {\n        return \"application/octet-stream\";\n      }\n    case \"Text\":\n      {\n        return \"text/plain\";\n      }\n  }\n};\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const withEncoding = /*#__PURE__*/dual(2, (self, options) => self.annotations({\n  [AnnotationEncoding]: {\n    kind: options.kind,\n    contentType: options.contentType ?? defaultContentType(options.kind)\n  },\n  ...(options.kind === \"Uint8Array\" ? {\n    jsonSchema: {\n      type: \"string\",\n      format: \"binary\"\n    }\n  } : undefined)\n}));\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Text = options => withEncoding(Schema.String, {\n  kind: \"Text\",\n  ...options\n});\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Uint8Array = options => withEncoding(Schema.Uint8ArrayFromSelf, {\n  kind: \"Uint8Array\",\n  ...options\n});\nconst astCache = /*#__PURE__*/globalValue(\"@effect/platform/HttpApiSchema/astCache\", () => new WeakMap());\n/**\n * @since 1.0.0\n */\nexport const deunionize = (schemas, schema) => {\n  if (astCache.has(schema.ast)) {\n    schemas.add(astCache.get(schema.ast));\n    return;\n  }\n  const ast = schema.ast;\n  if (ast._tag === \"Union\") {\n    for (const astType of ast.types) {\n      if (astCache.has(astType)) {\n        schemas.add(astCache.get(astType));\n        continue;\n      }\n      const memberSchema = Schema.make(AST.annotations(astType, {\n        ...ast.annotations,\n        ...astType.annotations\n      }));\n      astCache.set(astType, memberSchema);\n      schemas.add(memberSchema);\n    }\n  } else {\n    astCache.set(ast, schema);\n    schemas.add(schema);\n  }\n};\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport const EmptyError = () => options => {\n  const symbol = Symbol.for(`@effect/platform/HttpApiSchema/EmptyError/${options.tag}`);\n  class EmptyError extends Effectable.StructuralClass {\n    _tag = options.tag;\n    commit() {\n      return Effect.fail(this);\n    }\n  }\n  ;\n  EmptyError.prototype[symbol] = symbol;\n  Object.assign(EmptyError, {\n    [Schema.TypeId]: Schema.Void[Schema.TypeId],\n    pipe: Schema.Void.pipe,\n    annotations(annotations) {\n      return Schema.make(this.ast).annotations(annotations);\n    }\n  });\n  let transform;\n  Object.defineProperty(EmptyError, \"ast\", {\n    get() {\n      if (transform) {\n        return transform.ast;\n      }\n      const self = this;\n      transform = asEmpty(Schema.declare(u => hasProperty(u, symbol), {\n        identifier: options.tag,\n        title: options.tag\n      }), {\n        status: options.status,\n        decode: constant(new self())\n      });\n      return transform.ast;\n    }\n  });\n  return EmptyError;\n};\n//# sourceMappingURL=HttpApiSchema.js.map",
      "start": 1768772628588,
      "end": 1768772628588
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628588,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628650,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628705,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
