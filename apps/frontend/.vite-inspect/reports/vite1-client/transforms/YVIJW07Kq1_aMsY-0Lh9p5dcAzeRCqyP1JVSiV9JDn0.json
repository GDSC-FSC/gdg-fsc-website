{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/SortedMap.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\";\nimport * as Dual from \"./Function.js\";\nimport { pipe } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nimport * as RBT from \"./RedBlackTree.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/SortedMap\");\nconst SortedMapProto = {\n  [TypeId]: {\n    _K: _ => _,\n    _V: _ => _\n  },\n  [Hash.symbol]() {\n    return pipe(Hash.hash(this.tree), Hash.combine(Hash.hash(\"effect/SortedMap\")), Hash.cached(this));\n  },\n  [Equal.symbol](that) {\n    return isSortedMap(that) && Equal.equals(this.tree, that.tree);\n  },\n  [Symbol.iterator]() {\n    return this.tree[Symbol.iterator]();\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"SortedMap\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeImpl = tree => {\n  const self = Object.create(SortedMapProto);\n  self.tree = tree;\n  return self;\n};\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSortedMap = u => hasProperty(u, TypeId);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = ord => makeImpl(RBT.empty(ord));\n/**\n * Creates a new `SortedMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = /*#__PURE__*/Dual.dual(2, (iterable, ord) => makeImpl(RBT.fromIterable(iterable, ord)));\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = ord => (...entries) => fromIterable(ord)(entries);\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const isEmpty = self => size(self) === 0;\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const isNonEmpty = self => size(self) > 0;\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, key) => RBT.findFirst(self.tree, key));\n/**\n * Gets the `Order<K>` that the `SortedMap<K, V>` is using.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOrder = self => RBT.getOrder(self.tree);\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(get(self, key)));\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const headOption = self => RBT.first(self.tree);\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, empty(RBT.getOrder(self.tree)), (acc, v, k) => set(acc, k, f(v, k))));\n/**\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => RBT.reduce(self.tree, zero, f));\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, key) => makeImpl(RBT.removeFirst(self.tree, key)));\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const set = /*#__PURE__*/Dual.dual(3, (self, key, value) => RBT.has(self.tree, key) ? makeImpl(RBT.insert(RBT.removeFirst(self.tree, key), key, value)) : makeImpl(RBT.insert(self.tree, key, value)));\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const size = self => RBT.size(self.tree);\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const keys = self => RBT.keys(self.tree);\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const values = self => RBT.values(self.tree);\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const entries = self => {\n  const iterator = self.tree[Symbol.iterator]();\n  iterator[Symbol.iterator] = () => entries(self);\n  return iterator;\n};\n/**\n * @since 3.1.0\n * @category elements\n */\nexport const lastOption = self => RBT.last(self.tree);\n/**\n * @since 3.1.0\n * @category filtering\n */\nexport const partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  const ord = RBT.getOrder(self.tree);\n  let right = empty(ord);\n  let left = empty(ord);\n  for (const value of self) {\n    if (predicate(value[0])) {\n      right = set(right, value[0], value[1]);\n    } else {\n      left = set(left, value[0], value[1]);\n    }\n  }\n  return [left, right];\n});\n//# sourceMappingURL=SortedMap.js.map",
      "start": 1768772628415,
      "end": 1768772628415
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628415,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628418,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628436,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628478,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
