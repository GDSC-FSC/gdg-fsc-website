{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/HttpApiClient.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport { identity } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport * as Option from \"effect/Option\";\nimport * as ParseResult from \"effect/ParseResult\";\nimport * as Schema from \"effect/Schema\";\nimport * as HttpApi from \"./HttpApi.js\";\nimport * as HttpApiSchema from \"./HttpApiSchema.js\";\nimport * as HttpBody from \"./HttpBody.js\";\nimport * as HttpClient from \"./HttpClient.js\";\nimport * as HttpClientError from \"./HttpClientError.js\";\nimport * as HttpClientRequest from \"./HttpClientRequest.js\";\nimport * as HttpClientResponse from \"./HttpClientResponse.js\";\nimport * as HttpMethod from \"./HttpMethod.js\";\nimport * as UrlParams from \"./UrlParams.js\";\n/**\n * @internal\n */\nconst makeClient = (api, options) => Effect.gen(function* () {\n  const context = yield* Effect.context();\n  const httpClient = options.httpClient.pipe(options?.baseUrl === undefined ? identity : HttpClient.mapRequest(HttpClientRequest.prependUrl(options.baseUrl.toString())));\n  HttpApi.reflect(api, {\n    predicate: options?.predicate,\n    onGroup(onGroupOptions) {\n      options.onGroup?.(onGroupOptions);\n    },\n    onEndpoint(onEndpointOptions) {\n      const {\n        endpoint,\n        errors,\n        successes\n      } = onEndpointOptions;\n      const makeUrl = compilePath(endpoint.path);\n      const decodeMap = {\n        orElse: statusOrElse\n      };\n      const decodeResponse = HttpClientResponse.matchStatus(decodeMap);\n      errors.forEach(({\n        ast\n      }, status) => {\n        if (ast._tag === \"None\") {\n          decodeMap[status] = statusCodeError;\n          return;\n        }\n        const decode = schemaToResponse(ast.value);\n        decodeMap[status] = response => Effect.flatMap(decode(response), Effect.fail);\n      });\n      successes.forEach(({\n        ast\n      }, status) => {\n        decodeMap[status] = ast._tag === \"None\" ? responseAsVoid : schemaToResponse(ast.value);\n      });\n      const encodePath = endpoint.pathSchema.pipe(Option.map(Schema.encodeUnknown));\n      const encodePayloadBody = endpoint.payloadSchema.pipe(Option.map(schema => {\n        if (HttpMethod.hasBody(endpoint.method)) {\n          return Schema.encodeUnknown(payloadSchemaBody(schema));\n        }\n        return Schema.encodeUnknown(schema);\n      }));\n      const encodeHeaders = endpoint.headersSchema.pipe(Option.map(Schema.encodeUnknown));\n      const encodeUrlParams = endpoint.urlParamsSchema.pipe(Option.map(Schema.encodeUnknown));\n      const endpointFn = Effect.fnUntraced(function* (request) {\n        let httpRequest = HttpClientRequest.make(endpoint.method)(endpoint.path);\n        if (request && request.path) {\n          const encodedPathParams = encodePath._tag === \"Some\" ? yield* encodePath.value(request.path) : request.path;\n          httpRequest = HttpClientRequest.setUrl(httpRequest, makeUrl(encodedPathParams));\n        }\n        if (request && request.payload instanceof FormData) {\n          httpRequest = HttpClientRequest.bodyFormData(httpRequest, request.payload);\n        } else if (encodePayloadBody._tag === \"Some\") {\n          if (HttpMethod.hasBody(endpoint.method)) {\n            const body = yield* encodePayloadBody.value(request.payload);\n            httpRequest = HttpClientRequest.setBody(httpRequest, body);\n          } else {\n            const urlParams = yield* encodePayloadBody.value(request.payload);\n            httpRequest = HttpClientRequest.setUrlParams(httpRequest, urlParams);\n          }\n        }\n        if (encodeHeaders._tag === \"Some\") {\n          httpRequest = HttpClientRequest.setHeaders(httpRequest, yield* encodeHeaders.value(request.headers));\n        }\n        if (encodeUrlParams._tag === \"Some\") {\n          httpRequest = HttpClientRequest.appendUrlParams(httpRequest, yield* encodeUrlParams.value(request.urlParams));\n        }\n        const response = yield* httpClient.execute(httpRequest);\n        const value = yield* options.transformResponse === undefined ? decodeResponse(response) : options.transformResponse(decodeResponse(response));\n        return request?.withResponse === true ? [value, response] : value;\n      }, Effect.mapInputContext(input => Context.merge(context, input)));\n      options.onEndpoint({\n        ...onEndpointOptions,\n        endpointFn\n      });\n    }\n  });\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = (api, options) => Effect.flatMap(HttpClient.HttpClient, httpClient => makeWith(api, {\n  ...options,\n  httpClient: options?.transformClient ? options.transformClient(httpClient) : httpClient\n}));\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWith = (api, options) => {\n  const client = {};\n  return makeClient(api, {\n    ...options,\n    onGroup({\n      group\n    }) {\n      if (group.topLevel) return;\n      client[group.identifier] = {};\n    },\n    onEndpoint({\n      endpoint,\n      endpointFn,\n      group\n    }) {\n      ;\n      (group.topLevel ? client : client[group.identifier])[endpoint.name] = endpointFn;\n    }\n  }).pipe(Effect.map(() => client));\n};\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const group = (api, options) => {\n  const client = {};\n  return makeClient(api, {\n    ...options,\n    predicate: ({\n      group\n    }) => group.identifier === options.group,\n    onEndpoint({\n      endpoint,\n      endpointFn\n    }) {\n      client[endpoint.name] = endpointFn;\n    }\n  }).pipe(Effect.map(() => client));\n};\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const endpoint = (api, options) => {\n  let client = undefined;\n  return makeClient(api, {\n    ...options,\n    predicate: ({\n      endpoint,\n      group\n    }) => group.identifier === options.group && endpoint.name === options.endpoint,\n    onEndpoint({\n      endpointFn\n    }) {\n      client = endpointFn;\n    }\n  }).pipe(Effect.map(() => client));\n};\n// ----------------------------------------------------------------------------\nconst paramsRegex = /:(\\w+)\\??/g;\nconst compilePath = path => {\n  const segments = path.split(paramsRegex);\n  const len = segments.length;\n  if (len === 1) {\n    return _ => path;\n  }\n  return params => {\n    let url = segments[0];\n    for (let i = 1; i < len; i++) {\n      if (i % 2 === 0) {\n        url += segments[i];\n      } else {\n        url += params[segments[i]];\n      }\n    }\n    return url;\n  };\n};\nconst schemaToResponse = ast => {\n  const encoding = HttpApiSchema.getEncoding(ast);\n  const decode = Schema.decode(schemaFromArrayBuffer(ast, encoding));\n  return response => Effect.flatMap(response.arrayBuffer, decode);\n};\nconst Uint8ArrayFromArrayBuffer = /*#__PURE__*/Schema.transform(Schema.Unknown, Schema.Uint8ArrayFromSelf, {\n  decode(fromA) {\n    return new Uint8Array(fromA);\n  },\n  encode(arr) {\n    return arr.byteLength === arr.buffer.byteLength ? arr.buffer : arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  }\n});\nconst StringFromArrayBuffer = /*#__PURE__*/Schema.transform(Schema.Unknown, Schema.String, {\n  decode(fromA) {\n    return new TextDecoder().decode(fromA);\n  },\n  encode(toI) {\n    const arr = new TextEncoder().encode(toI);\n    return arr.byteLength === arr.buffer.byteLength ? arr.buffer : arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  }\n});\nconst parseJsonOrVoid = /*#__PURE__*/Schema.transformOrFail(Schema.String, Schema.Unknown, {\n  strict: true,\n  decode: (i, _, ast) => {\n    if (i === \"\") return ParseResult.succeed(void 0);\n    return ParseResult.try({\n      try: () => JSON.parse(i),\n      catch: () => new ParseResult.Type(ast, i, \"Could not parse JSON\")\n    });\n  },\n  encode: (a, _, ast) => {\n    if (a === undefined) return ParseResult.succeed(\"\");\n    return ParseResult.try({\n      try: () => JSON.stringify(a),\n      catch: () => new ParseResult.Type(ast, a, \"Could not encode as JSON\")\n    });\n  }\n});\nconst parseJsonArrayBuffer = /*#__PURE__*/Schema.compose(StringFromArrayBuffer, parseJsonOrVoid);\nconst schemaFromArrayBuffer = (ast, encoding) => {\n  if (ast._tag === \"Union\") {\n    return Schema.Union(...ast.types.map(ast => schemaFromArrayBuffer(ast, HttpApiSchema.getEncoding(ast, encoding))));\n  }\n  const schema = Schema.make(ast);\n  switch (encoding.kind) {\n    case \"Json\":\n      {\n        return Schema.compose(parseJsonArrayBuffer, schema);\n      }\n    case \"UrlParams\":\n      {\n        return Schema.compose(StringFromArrayBuffer, UrlParams.schemaParse(schema));\n      }\n    case \"Uint8Array\":\n      {\n        return Schema.compose(Uint8ArrayFromArrayBuffer, schema);\n      }\n    case \"Text\":\n      {\n        return Schema.compose(StringFromArrayBuffer, schema);\n      }\n  }\n};\nconst statusOrElse = response => Effect.fail(new HttpClientError.ResponseError({\n  reason: \"Decode\",\n  request: response.request,\n  response\n}));\nconst statusCodeError = response => Effect.fail(new HttpClientError.ResponseError({\n  reason: \"StatusCode\",\n  request: response.request,\n  response\n}));\nconst responseAsVoid = _response => Effect.void;\nconst HttpBodyFromSelf = /*#__PURE__*/Schema.declare(HttpBody.isHttpBody);\nconst payloadSchemaBody = schema => {\n  const members = schema.ast._tag === \"Union\" ? schema.ast.types : [schema.ast];\n  return Schema.Union(...members.map(bodyFromPayload));\n};\nconst bodyFromPayloadCache = /*#__PURE__*/globalValue(\"@effect/platform/HttpApiClient/bodyFromPayloadCache\", () => new WeakMap());\nconst bodyFromPayload = ast => {\n  if (bodyFromPayloadCache.has(ast)) {\n    return bodyFromPayloadCache.get(ast);\n  }\n  const schema = Schema.make(ast);\n  const encoding = HttpApiSchema.getEncoding(ast);\n  const transform = Schema.transformOrFail(HttpBodyFromSelf, schema, {\n    decode(fromA, _, ast) {\n      return ParseResult.fail(new ParseResult.Forbidden(ast, fromA, \"encode only schema\"));\n    },\n    encode(toI, _, ast) {\n      switch (encoding.kind) {\n        case \"Json\":\n          {\n            try {\n              return ParseResult.succeed(HttpBody.text(JSON.stringify(toI), encoding.contentType));\n            } catch {\n              return ParseResult.fail(new ParseResult.Type(ast, toI, \"Could not encode as JSON\"));\n            }\n          }\n        case \"Text\":\n          {\n            if (typeof toI !== \"string\") {\n              return ParseResult.fail(new ParseResult.Type(ast, toI, \"Expected a string\"));\n            }\n            return ParseResult.succeed(HttpBody.text(toI, encoding.contentType));\n          }\n        case \"UrlParams\":\n          {\n            return ParseResult.succeed(HttpBody.urlParams(UrlParams.fromInput(toI)));\n          }\n        case \"Uint8Array\":\n          {\n            if (!(toI instanceof Uint8Array)) {\n              return ParseResult.fail(new ParseResult.Type(ast, toI, \"Expected a Uint8Array\"));\n            }\n            return ParseResult.succeed(HttpBody.uint8Array(toI, encoding.contentType));\n          }\n      }\n    }\n  });\n  bodyFromPayloadCache.set(ast, transform);\n  return transform;\n};\n//# sourceMappingURL=HttpApiClient.js.map",
      "start": 1768772628585,
      "end": 1768772628585
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628585,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628619,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628647,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
