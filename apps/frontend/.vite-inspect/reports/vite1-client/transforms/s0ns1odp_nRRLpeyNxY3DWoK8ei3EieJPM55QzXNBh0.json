{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/MutableHashMap.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Equal from \"./Equal.js\";\nimport { dual } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/MutableHashMap\");\nconst MutableHashMapProto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    return new MutableHashMapIterator(this);\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"MutableHashMap\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nclass MutableHashMapIterator {\n  self;\n  referentialIterator;\n  bucketIterator;\n  constructor(self) {\n    this.self = self;\n    this.referentialIterator = self.referential[Symbol.iterator]();\n  }\n  next() {\n    if (this.bucketIterator !== undefined) {\n      return this.bucketIterator.next();\n    }\n    const result = this.referentialIterator.next();\n    if (result.done) {\n      this.bucketIterator = new BucketIterator(this.self.buckets.values());\n      return this.next();\n    }\n    return result;\n  }\n  [Symbol.iterator]() {\n    return new MutableHashMapIterator(this.self);\n  }\n}\nclass BucketIterator {\n  backing;\n  constructor(backing) {\n    this.backing = backing;\n  }\n  currentBucket;\n  next() {\n    if (this.currentBucket === undefined) {\n      const result = this.backing.next();\n      if (result.done) {\n        return result;\n      }\n      this.currentBucket = result.value[Symbol.iterator]();\n    }\n    const result = this.currentBucket.next();\n    if (result.done) {\n      this.currentBucket = undefined;\n      return this.next();\n    }\n    return result;\n  }\n}\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = () => {\n  const self = Object.create(MutableHashMapProto);\n  self.referential = new Map();\n  self.buckets = new Map();\n  self.bucketsSize = 0;\n  return self;\n};\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (...entries) => fromIterable(entries);\n/**\n * Creates a new `MutableHashMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = entries => {\n  const self = empty();\n  for (const [key, value] of entries) {\n    set(self, key, value);\n  }\n  return self;\n};\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const get = /*#__PURE__*/dual(2, (self, key) => {\n  if (Equal.isEqual(key) === false) {\n    return self.referential.has(key) ? Option.some(self.referential.get(key)) : Option.none();\n  }\n  const hash = key[Hash.symbol]();\n  const bucket = self.buckets.get(hash);\n  if (bucket === undefined) {\n    return Option.none();\n  }\n  return getFromBucket(self, bucket, key);\n});\n/**\n * @since 3.8.0\n * @category elements\n */\nexport const keys = self => {\n  const keys = Array.from(self.referential.keys());\n  for (const bucket of self.buckets.values()) {\n    for (let i = 0, len = bucket.length; i < len; i++) {\n      keys.push(bucket[i][0]);\n    }\n  }\n  return keys;\n};\n/**\n * @since 3.8.0\n * @category elements\n */\nexport const values = self => {\n  const values = Array.from(self.referential.values());\n  for (const bucket of self.buckets.values()) {\n    for (let i = 0, len = bucket.length; i < len; i++) {\n      values.push(bucket[i][1]);\n    }\n  }\n  return values;\n};\nconst getFromBucket = (self, bucket, key, remove = false) => {\n  for (let i = 0, len = bucket.length; i < len; i++) {\n    if (key[Equal.symbol](bucket[i][0])) {\n      const value = bucket[i][1];\n      if (remove) {\n        bucket.splice(i, 1);\n        self.bucketsSize--;\n      }\n      return Option.some(value);\n    }\n  }\n  return Option.none();\n};\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const has = /*#__PURE__*/dual(2, (self, key) => Option.isSome(get(self, key)));\n/**\n * @since 2.0.0\n */\nexport const set = /*#__PURE__*/dual(3, (self, key, value) => {\n  if (Equal.isEqual(key) === false) {\n    self.referential.set(key, value);\n    return self;\n  }\n  const hash = key[Hash.symbol]();\n  const bucket = self.buckets.get(hash);\n  if (bucket === undefined) {\n    self.buckets.set(hash, [[key, value]]);\n    self.bucketsSize++;\n    return self;\n  }\n  removeFromBucket(self, bucket, key);\n  bucket.push([key, value]);\n  self.bucketsSize++;\n  return self;\n});\nconst removeFromBucket = (self, bucket, key) => {\n  for (let i = 0, len = bucket.length; i < len; i++) {\n    if (key[Equal.symbol](bucket[i][0])) {\n      bucket.splice(i, 1);\n      self.bucketsSize--;\n      return;\n    }\n  }\n};\n/**\n * Updates the value of the specified key within the `MutableHashMap` if it exists.\n *\n * @since 2.0.0\n */\nexport const modify = /*#__PURE__*/dual(3, (self, key, f) => {\n  if (Equal.isEqual(key) === false) {\n    if (self.referential.has(key)) {\n      self.referential.set(key, f(self.referential.get(key)));\n    }\n    return self;\n  }\n  const hash = key[Hash.symbol]();\n  const bucket = self.buckets.get(hash);\n  if (bucket === undefined) {\n    return self;\n  }\n  const value = getFromBucket(self, bucket, key, true);\n  if (Option.isNone(value)) {\n    return self;\n  }\n  bucket.push([key, f(value.value)]);\n  self.bucketsSize++;\n  return self;\n});\n/**\n * Set or remove the specified key in the `MutableHashMap` using the specified\n * update function.\n *\n * @since 2.0.0\n */\nexport const modifyAt = /*#__PURE__*/dual(3, (self, key, f) => {\n  if (Equal.isEqual(key) === false) {\n    const result = f(get(self, key));\n    if (Option.isSome(result)) {\n      set(self, key, result.value);\n    } else {\n      remove(self, key);\n    }\n    return self;\n  }\n  const hash = key[Hash.symbol]();\n  const bucket = self.buckets.get(hash);\n  if (bucket === undefined) {\n    const result = f(Option.none());\n    return Option.isSome(result) ? set(self, key, result.value) : self;\n  }\n  const result = f(getFromBucket(self, bucket, key, true));\n  if (Option.isNone(result)) {\n    if (bucket.length === 0) {\n      self.buckets.delete(hash);\n    }\n    return self;\n  }\n  bucket.push([key, result.value]);\n  self.bucketsSize++;\n  return self;\n});\n/**\n * @since 2.0.0\n */\nexport const remove = /*#__PURE__*/dual(2, (self, key) => {\n  if (Equal.isEqual(key) === false) {\n    self.referential.delete(key);\n    return self;\n  }\n  const hash = key[Hash.symbol]();\n  const bucket = self.buckets.get(hash);\n  if (bucket === undefined) {\n    return self;\n  }\n  removeFromBucket(self, bucket, key);\n  if (bucket.length === 0) {\n    self.buckets.delete(hash);\n  }\n  return self;\n});\n/**\n * @since 2.0.0\n */\nexport const clear = self => {\n  self.referential.clear();\n  self.buckets.clear();\n  self.bucketsSize = 0;\n  return self;\n};\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const size = self => {\n  return self.referential.size + self.bucketsSize;\n};\n/**\n * @since 2.0.0\n */\nexport const isEmpty = self => size(self) === 0;\n/**\n * @since 2.0.0\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => {\n  self.referential.forEach(f);\n  for (const bucket of self.buckets.values()) {\n    for (const [key, value] of bucket) {\n      f(value, key);\n    }\n  }\n});\n//# sourceMappingURL=MutableHashMap.js.map",
      "start": 1768772628413,
      "end": 1768772628413
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628413,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628432,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
