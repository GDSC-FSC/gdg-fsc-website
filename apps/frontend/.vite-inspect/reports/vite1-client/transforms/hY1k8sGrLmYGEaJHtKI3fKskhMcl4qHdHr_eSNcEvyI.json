{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/internal/schedule.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import * as Chunk from \"../Chunk.js\";\nimport * as Clock from \"../Clock.js\";\nimport * as Context from \"../Context.js\";\nimport * as Cron from \"../Cron.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport { constVoid, dual, pipe } from \"../Function.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as Random from \"../Random.js\";\nimport * as ScheduleDecision from \"../ScheduleDecision.js\";\nimport * as Interval from \"../ScheduleInterval.js\";\nimport * as Intervals from \"../ScheduleIntervals.js\";\nimport * as internalCause from \"./cause.js\";\nimport * as effect from \"./core-effect.js\";\nimport * as core from \"./core.js\";\nimport { forkScoped } from \"./effect/circular.js\";\nimport * as ref from \"./ref.js\";\n/** @internal */\nconst ScheduleSymbolKey = \"effect/Schedule\";\n/** @internal */\nexport const ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);\n/** @internal */\nexport const isSchedule = u => hasProperty(u, ScheduleTypeId);\n/** @internal */\nconst ScheduleDriverSymbolKey = \"effect/ScheduleDriver\";\n/** @internal */\nexport const ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey);\n/** @internal */\nconst defaultIterationMetadata = {\n  start: 0,\n  now: 0,\n  input: undefined,\n  output: undefined,\n  elapsed: Duration.zero,\n  elapsedSincePrevious: Duration.zero,\n  recurrence: 0\n};\n/** @internal */\nexport const CurrentIterationMetadata = /*#__PURE__*/Context.Reference()(\"effect/Schedule/CurrentIterationMetadata\", {\n  defaultValue: () => defaultIterationMetadata\n});\nconst scheduleVariance = {\n  /* c8 ignore next */\n  _Out: _ => _,\n  /* c8 ignore next */\n  _In: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\nconst scheduleDriverVariance = {\n  /* c8 ignore next */\n  _Out: _ => _,\n  /* c8 ignore next */\n  _In: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\n/** @internal */\nclass ScheduleImpl {\n  initial;\n  step;\n  [ScheduleTypeId] = scheduleVariance;\n  constructor(initial, step) {\n    this.initial = initial;\n    this.step = step;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nconst updateInfo = (iterationMetaRef, now, input, output) => ref.update(iterationMetaRef, prev => prev.recurrence === 0 ? {\n  now,\n  input,\n  output,\n  recurrence: prev.recurrence + 1,\n  elapsed: Duration.zero,\n  elapsedSincePrevious: Duration.zero,\n  start: now\n} : {\n  now,\n  input,\n  output,\n  recurrence: prev.recurrence + 1,\n  elapsed: Duration.millis(now - prev.start),\n  elapsedSincePrevious: Duration.millis(now - prev.now),\n  start: prev.start\n});\n/** @internal */\nclass ScheduleDriverImpl {\n  schedule;\n  ref;\n  [ScheduleDriverTypeId] = scheduleDriverVariance;\n  constructor(schedule, ref) {\n    this.schedule = schedule;\n    this.ref = ref;\n  }\n  get state() {\n    return core.map(ref.get(this.ref), tuple => tuple[1]);\n  }\n  get last() {\n    return core.flatMap(ref.get(this.ref), ([element, _]) => {\n      switch (element._tag) {\n        case \"None\":\n          {\n            return core.failSync(() => new core.NoSuchElementException());\n          }\n        case \"Some\":\n          {\n            return core.succeed(element.value);\n          }\n      }\n    });\n  }\n  iterationMeta = /*#__PURE__*/ref.unsafeMake(defaultIterationMetadata);\n  get reset() {\n    return ref.set(this.ref, [Option.none(), this.schedule.initial]).pipe(core.zipLeft(ref.set(this.iterationMeta, defaultIterationMetadata)));\n  }\n  next(input) {\n    return pipe(core.map(ref.get(this.ref), tuple => tuple[1]), core.flatMap(state => pipe(Clock.currentTimeMillis, core.flatMap(now => pipe(core.suspend(() => this.schedule.step(now, input, state)), core.flatMap(([state, out, decision]) => {\n      const setState = ref.set(this.ref, [Option.some(out), state]);\n      if (ScheduleDecision.isDone(decision)) {\n        return setState.pipe(core.zipRight(core.fail(Option.none())));\n      }\n      const millis = Intervals.start(decision.intervals) - now;\n      if (millis <= 0) {\n        return setState.pipe(core.zipRight(updateInfo(this.iterationMeta, now, input, out)), core.as(out));\n      }\n      const duration = Duration.millis(millis);\n      return pipe(setState, core.zipRight(updateInfo(this.iterationMeta, now, input, out)), core.zipRight(effect.sleep(duration)), core.as(out));\n    }))))));\n  }\n}\n/** @internal */\nexport const makeWithState = (initial, step) => new ScheduleImpl(initial, step);\n/** @internal */\nexport const addDelay = /*#__PURE__*/dual(2, (self, f) => addDelayEffect(self, out => core.sync(() => f(out))));\n/** @internal */\nexport const addDelayEffect = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.map(f(out), delay => Duration.sum(duration, Duration.decode(delay)))));\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, that) => map(andThenEither(self, that), Either.merge));\n/** @internal */\nexport const andThenEither = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? core.flatMap(self.step(now, input, state[0]), ([lState, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], Either.right(out), decision]);\n  }\n  return core.succeed([[lState, state[1], true], Either.left(out), decision]);\n}) : core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], Either.right(out), decision])));\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, out) => map(self, () => out));\n/** @internal */\nexport const asVoid = self => map(self, constVoid);\n/** @internal */\nexport const bothInOut = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => core.zipWith(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const interval = pipe(lDecision.intervals, Intervals.union(rDecision.intervals));\n    return [[lState, rState], [out, out2], ScheduleDecision.continue(interval)];\n  }\n  return [[lState, rState], [out, out2], ScheduleDecision.done];\n})));\n/** @internal */\nexport const check = /*#__PURE__*/dual(2, (self, test) => checkEffect(self, (input, out) => core.sync(() => test(input, out))));\n/** @internal */\nexport const checkEffect = /*#__PURE__*/dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, ScheduleDecision.done]);\n  }\n  return core.map(test(input, out), cont => cont ? [state, out, decision] : [state, out, ScheduleDecision.done]);\n})));\n/** @internal */\nexport const collectAllInputs = () => collectAllOutputs(identity());\n/** @internal */\nexport const collectAllOutputs = self => reduce(self, Chunk.empty(), (outs, out) => pipe(outs, Chunk.append(out)));\n/** @internal */\nexport const collectUntil = f => collectAllOutputs(recurUntil(f));\n/** @internal */\nexport const collectUntilEffect = f => collectAllOutputs(recurUntilEffect(f));\n/** @internal */\nexport const collectWhile = f => collectAllOutputs(recurWhile(f));\n/** @internal */\nexport const collectWhileEffect = f => collectAllOutputs(recurWhileEffect(f));\n/** @internal */\nexport const compose = /*#__PURE__*/dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(self.step(now, input, state[0]), ([lState, out, lDecision]) => core.map(that.step(now, out, state[1]), ([rState, out2, rDecision]) => ScheduleDecision.isDone(lDecision) ? [[lState, rState], out2, ScheduleDecision.done] : ScheduleDecision.isDone(rDecision) ? [[lState, rState], out2, ScheduleDecision.done] : [[lState, rState], out2, ScheduleDecision.continue(pipe(lDecision.intervals, Intervals.max(rDecision.intervals)))]))));\n/** @internal */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => mapInputEffect(self, input2 => core.sync(() => f(input2))));\n/** @internal */\nexport const mapInputContext = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.mapInputContext(self.step(now, input, state), f)));\n/** @internal */\nexport const mapInputEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input2, state) => core.flatMap(f(input2), input => self.step(now, input, state))));\n/** @internal */\nexport const cron = (expression, tz) => {\n  const parsed = Cron.isCron(expression) ? Either.right(expression) : Cron.parse(expression, tz);\n  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now, _, [initial, previous]) => {\n    if (now < previous[0]) {\n      return core.succeed([[false, previous], [previous[1], previous[2]], ScheduleDecision.continueWith(Interval.make(previous[1], previous[2]))]);\n    }\n    if (Either.isLeft(parsed)) {\n      return core.die(parsed.left);\n    }\n    const cron = parsed.right;\n    const date = new Date(now);\n    let next;\n    if (initial && Cron.match(cron, date)) {\n      next = now;\n    }\n    next = Cron.next(cron, date).getTime();\n    const start = beginningOfSecond(next);\n    const end = endOfSecond(next);\n    return core.succeed([[false, [next, start, end]], [start, end], ScheduleDecision.continueWith(Interval.make(start, end))]);\n  });\n};\n/** @internal */\nexport const dayOfMonth = day => {\n  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 31 < day) {\n      return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDayOfMonth(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n};\n/** @internal */\nexport const dayOfWeek = day => {\n  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 7 < day) {\n      return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDay(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n};\n/** @internal */\nexport const delayed = /*#__PURE__*/dual(2, (self, f) => delayedEffect(self, duration => core.sync(() => f(duration))));\n/** @internal */\nexport const delayedEffect = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (_, delay) => f(delay)));\n/** @internal */\nexport const delayedSchedule = schedule => addDelay(schedule, x => x);\n/** @internal */\nexport const delays = self => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), core.flatMap(([state, _, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, Duration.zero, decision]);\n  }\n  return core.succeed([state, Duration.millis(Intervals.start(decision.intervals) - now), decision]);\n})));\n/** @internal */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, {\n  onInput,\n  onOutput\n}) => map(mapInput(self, onInput), onOutput));\n/** @internal */\nexport const mapBothEffect = /*#__PURE__*/dual(2, (self, {\n  onInput,\n  onOutput\n}) => mapEffect(mapInputEffect(self, onInput), onOutput));\n/** @internal */\nexport const driver = self => pipe(ref.make([Option.none(), self.initial]), core.map(ref => new ScheduleDriverImpl(self, ref)));\n/** @internal */\nexport const duration = durationInput => {\n  const duration = Duration.decode(durationInput);\n  const durationMillis = Duration.toMillis(duration);\n  return makeWithState(true, (now, _, state) => core.succeed(state ? [false, duration, ScheduleDecision.continueWith(Interval.after(now + durationMillis))] : [false, Duration.zero, ScheduleDecision.done]));\n};\n/** @internal */\nexport const either = /*#__PURE__*/dual(2, (self, that) => union(self, that));\n/** @internal */\nexport const eitherWith = /*#__PURE__*/dual(3, (self, that, f) => unionWith(self, that, f));\n/** @internal */\nexport const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.as(finalizer, [state, out, decision]) : core.succeed([state, out, decision]))));\n/** @internal */\nexport const exponential = (baseInput, factor = 2.0) => {\n  const base = Duration.decode(baseInput);\n  return delayedSchedule(map(forever, i => Duration.times(base, Math.pow(factor, i))));\n};\n/** @internal */\nexport const fibonacci = oneInput => {\n  const one = Duration.decode(oneInput);\n  return delayedSchedule(pipe(unfold([one, one], ([a, b]) => [b, Duration.sum(a, b)]), map(out => out[0])));\n};\n/** @internal */\nexport const fixed = intervalInput => {\n  const interval = Duration.decode(intervalInput);\n  const intervalMillis = Duration.toMillis(interval);\n  return makeWithState([Option.none(), 0], (now, _, [option, n]) => core.sync(() => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return [[Option.some([now, now + intervalMillis]), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + intervalMillis))];\n        }\n      case \"Some\":\n        {\n          const [startMillis, lastRun] = option.value;\n          const runningBehind = now > lastRun + intervalMillis;\n          const boundary = Equal.equals(interval, Duration.zero) ? interval : Duration.millis(intervalMillis - (now - startMillis) % intervalMillis);\n          const sleepTime = Equal.equals(boundary, Duration.zero) ? interval : boundary;\n          const nextRun = runningBehind ? now : now + Duration.toMillis(sleepTime);\n          return [[Option.some([startMillis, nextRun]), n + 1], n, ScheduleDecision.continueWith(Interval.after(nextRun))];\n        }\n    }\n  }));\n};\n/** @internal */\nexport const fromDelay = delay => duration(delay);\n/** @internal */\nexport const fromDelays = (delay, ...delays) => makeWithState([[delay, ...delays].map(_ => Duration.decode(_)), true], (now, _, [durations, cont]) => core.sync(() => {\n  if (cont) {\n    const x = durations[0];\n    const interval = Interval.after(now + Duration.toMillis(x));\n    if (durations.length >= 2) {\n      return [[durations.slice(1), true], x, ScheduleDecision.continueWith(interval)];\n    }\n    const y = durations.slice(1);\n    return [[[x, ...y], false], x, ScheduleDecision.continueWith(interval)];\n  }\n  return [[durations, false], Duration.zero, ScheduleDecision.done];\n}));\n/** @internal */\nexport const fromFunction = f => map(identity(), f);\n/** @internal */\nexport const hourOfDay = hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {\n    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const hour0 = nextHour(now, hour, initial);\n  const start = beginningOfHour(hour0);\n  const end = endOfHour(hour0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n});\n/** @internal */\nexport const identity = () => makeWithState(void 0, (now, input, state) => core.succeed([state, input, ScheduleDecision.continueWith(Interval.after(now))]));\n/** @internal */\nexport const intersect = /*#__PURE__*/dual(2, (self, that) => intersectWith(self, that, Intervals.intersect));\n/** @internal */\nexport const intersectWith = /*#__PURE__*/dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(core.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), core.flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);\n  }\n  return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n}))));\n/** @internal */\nconst intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {\n  const combined = f(lInterval, rInterval);\n  if (Intervals.isNonEmpty(combined)) {\n    return core.succeed([[lState, rState], [out, out2], ScheduleDecision.continue(combined)]);\n  }\n  if (pipe(lInterval, Intervals.lessThan(rInterval))) {\n    return core.flatMap(self.step(Intervals.end(lInterval), input, lState), ([lState, out, decision]) => {\n      if (ScheduleDecision.isDone(decision)) {\n        return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n      }\n      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);\n    });\n  }\n  return core.flatMap(that.step(Intervals.end(rInterval), input, rState), ([rState, out2, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n    }\n    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);\n  });\n};\n/** @internal */\nexport const jittered = self => jitteredWith(self, {\n  min: 0.8,\n  max: 1.2\n});\n/** @internal */\nexport const jitteredWith = /*#__PURE__*/dual(2, (self, options) => {\n  const {\n    max,\n    min\n  } = Object.assign({\n    min: 0.8,\n    max: 1.2\n  }, options);\n  return delayedEffect(self, duration => core.map(Random.next, random => {\n    const d = Duration.toMillis(duration);\n    const jittered = d * min * (1 - random) + d * max * random;\n    return Duration.millis(jittered);\n  }));\n});\n/** @internal */\nexport const linear = baseInput => {\n  const base = Duration.decode(baseInput);\n  return delayedSchedule(map(forever, i => Duration.times(base, i + 1)));\n};\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => mapEffect(self, out => core.sync(() => f(out))));\n/** @internal */\nexport const mapEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.map(f(out), out2 => [state, out2, decision]))));\n/** @internal */\nexport const minuteOfHour = minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {\n    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const minute0 = nextMinute(now, minute, initial);\n  const start = beginningOfMinute(minute0);\n  const end = endOfMinute(minute0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n});\n/** @internal */\nexport const modifyDelay = /*#__PURE__*/dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.sync(() => f(out, duration))));\n/** @internal */\nexport const modifyDelayEffect = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, decision]);\n  }\n  const intervals = decision.intervals;\n  const delay = Interval.size(Interval.make(now, Intervals.start(intervals)));\n  return core.map(f(out, delay), durationInput => {\n    const duration = Duration.decode(durationInput);\n    const oldStart = Intervals.start(intervals);\n    const newStart = now + Duration.toMillis(duration);\n    const delta = newStart - oldStart;\n    const newEnd = Math.max(0, Intervals.end(intervals) + delta);\n    const newInterval = Interval.make(newStart, newEnd);\n    return [state, out, ScheduleDecision.continueWith(newInterval)];\n  });\n})));\n/** @internal */\nexport const onDecision = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.as(f(out, decision), [state, out, decision]))));\n/** @internal */\nexport const passthrough = self => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), core.map(([state, _, decision]) => [state, input, decision])));\n/** @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, context) => makeWithState(self.initial, (now, input, state) => core.provideContext(self.step(now, input, state), context)));\n/** @internal */\nexport const provideService = /*#__PURE__*/dual(3, (self, tag, service) => makeWithState(self.initial, (now, input, state) => core.contextWithEffect(env => core.provideContext(\n// @ts-expect-error\nself.step(now, input, state), Context.add(env, tag, service)))));\n/** @internal */\nexport const recurUntil = f => untilInput(identity(), f);\n/** @internal */\nexport const recurUntilEffect = f => untilInputEffect(identity(), f);\n/** @internal */\nexport const recurUntilOption = pf => untilOutput(map(identity(), pf), Option.isSome);\n/** @internal */\nexport const recurUpTo = durationInput => {\n  const duration = Duration.decode(durationInput);\n  return whileOutput(elapsed, elapsed => Duration.lessThan(elapsed, duration));\n};\n/** @internal */\nexport const recurWhile = f => whileInput(identity(), f);\n/** @internal */\nexport const recurWhileEffect = f => whileInputEffect(identity(), f);\n/** @internal */\nexport const recurs = n => whileOutput(forever, out => out < n);\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => reduceEffect(self, zero, (z, out) => core.sync(() => f(z, out))));\n/** @internal */\nexport const reduceEffect = /*#__PURE__*/dual(3, (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => core.flatMap(self.step(now, input, s), ([s, out, decision]) => ScheduleDecision.isDone(decision) ? core.succeed([[s, z], z, decision]) : core.map(f(z, out), z2 => [[s, z2], z, decision]))));\n/** @internal */\nexport const repeatForever = self => makeWithState(self.initial, (now, input, state) => {\n  const step = (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? step(now, input, self.initial) : core.succeed([state, out, decision]));\n  return step(now, input, state);\n});\n/** @internal */\nexport const repetitions = self => reduce(self, 0, (n, _) => n + 1);\n/** @internal */\nexport const resetAfter = /*#__PURE__*/dual(2, (self, durationInput) => {\n  const duration = Duration.decode(durationInput);\n  return pipe(self, intersect(elapsed), resetWhen(([, time]) => Duration.greaterThanOrEqualTo(time, duration)), map(out => out[0]));\n});\n/** @internal */\nexport const resetWhen = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => f(out) ? self.step(now, input, self.initial) : core.succeed([state, out, decision]))));\n/** @internal */\nexport const run = /*#__PURE__*/dual(3, (self, now, input) => pipe(runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty()), core.map(list => Chunk.reverse(list))));\n/** @internal */\nconst runLoop = (self, now, inputs, state, acc) => {\n  if (!Chunk.isNonEmpty(inputs)) {\n    return core.succeed(acc);\n  }\n  const input = Chunk.headNonEmpty(inputs);\n  const nextInputs = Chunk.tailNonEmpty(inputs);\n  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.sync(() => pipe(acc, Chunk.prepend(out)));\n    }\n    return runLoop(self, Intervals.start(decision.intervals), nextInputs, state, Chunk.prepend(acc, out));\n  });\n};\n/** @internal */\nexport const secondOfMinute = second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(second) || second < 0 || 59 < second) {\n    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const second0 = nextSecond(now, second, initial);\n  const start = beginningOfSecond(second0);\n  const end = endOfSecond(second0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n});\n/** @internal */\nexport const spaced = duration => addDelay(forever, () => duration);\n/** @internal */\nexport const succeed = value => map(forever, () => value);\n/** @internal */\nexport const sync = evaluate => map(forever, evaluate);\n/** @internal */\nexport const tapInput = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.zipRight(f(input), self.step(now, input, state))));\n/** @internal */\nexport const tapOutput = /*#__PURE__*/dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.tap(self.step(now, input, state), ([, out]) => f(out))));\n/** @internal */\nexport const unfold = (initial, f) => makeWithState(initial, (now, _, state) => core.sync(() => [f(state), state, ScheduleDecision.continueWith(Interval.after(now))]));\n/** @internal */\nexport const union = /*#__PURE__*/dual(2, (self, that) => unionWith(self, that, Intervals.union));\n/** @internal */\nexport const unionWith = /*#__PURE__*/dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.done];\n  }\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(rDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(lDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const combined = f(lDecision.intervals, rDecision.intervals);\n    return [[lState, rState], [l, r], ScheduleDecision.continue(combined)];\n  }\n  throw new Error(\"BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues\");\n})));\n/** @internal */\nexport const untilInput = /*#__PURE__*/dual(2, (self, f) => check(self, (input, _) => !f(input)));\n/** @internal */\nexport const untilInputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (input, _) => effect.negate(f(input))));\n/** @internal */\nexport const untilOutput = /*#__PURE__*/dual(2, (self, f) => check(self, (_, out) => !f(out)));\n/** @internal */\nexport const untilOutputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (_, out) => effect.negate(f(out))));\n/** @internal */\nexport const upTo = /*#__PURE__*/dual(2, (self, duration) => zipLeft(self, recurUpTo(duration)));\n/** @internal */\nexport const whileInput = /*#__PURE__*/dual(2, (self, f) => check(self, (input, _) => f(input)));\n/** @internal */\nexport const whileInputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));\n/** @internal */\nexport const whileOutput = /*#__PURE__*/dual(2, (self, f) => check(self, (_, out) => f(out)));\n/** @internal */\nexport const whileOutputEffect = /*#__PURE__*/dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));\n/** @internal */\nexport const windowed = intervalInput => {\n  const interval = Duration.decode(intervalInput);\n  const millis = Duration.toMillis(interval);\n  return makeWithState([Option.none(), 0], (now, _, [option, n]) => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed([[Option.some(now), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + millis))]);\n        }\n      case \"Some\":\n        {\n          return core.succeed([[Option.some(option.value), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + (millis - (now - option.value) % millis)))]);\n        }\n    }\n  });\n};\n/** @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => map(intersect(self, that), out => out[0]));\n/** @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => map(intersect(self, that), out => out[1]));\n/** @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => map(intersect(self, that), ([out, out2]) => f(out, out2)));\n// -----------------------------------------------------------------------------\n// Seconds\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfSecond = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();\n};\n/** @internal */\nexport const endOfSecond = now => {\n  const date = new Date(beginningOfSecond(now));\n  return date.setSeconds(date.getSeconds() + 1);\n};\n/** @internal */\nexport const nextSecond = (now, second, initial) => {\n  const date = new Date(now);\n  if (date.getSeconds() === second && initial) {\n    return now;\n  }\n  if (date.getSeconds() < second) {\n    return date.setSeconds(second);\n  }\n  // Set seconds to the provided value and add one minute\n  const newDate = new Date(date.setSeconds(second));\n  return newDate.setTime(newDate.getTime() + 1000 * 60);\n};\n// -----------------------------------------------------------------------------\n// Minutes\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfMinute = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();\n};\n/** @internal */\nexport const endOfMinute = now => {\n  const date = new Date(beginningOfMinute(now));\n  return date.setMinutes(date.getMinutes() + 1);\n};\n/** @internal */\nexport const nextMinute = (now, minute, initial) => {\n  const date = new Date(now);\n  if (date.getMinutes() === minute && initial) {\n    return now;\n  }\n  if (date.getMinutes() < minute) {\n    return date.setMinutes(minute);\n  }\n  // Set minutes to the provided value and add one hour\n  const newDate = new Date(date.setMinutes(minute));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);\n};\n// -----------------------------------------------------------------------------\n// Hours\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfHour = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();\n};\n/** @internal */\nexport const endOfHour = now => {\n  const date = new Date(beginningOfHour(now));\n  return date.setHours(date.getHours() + 1);\n};\n/** @internal */\nexport const nextHour = (now, hour, initial) => {\n  const date = new Date(now);\n  if (date.getHours() === hour && initial) {\n    return now;\n  }\n  if (date.getHours() < hour) {\n    return date.setHours(hour);\n  }\n  // Set hours to the provided value and add one day\n  const newDate = new Date(date.setHours(hour));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);\n};\n// -----------------------------------------------------------------------------\n// Days\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfDay = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();\n};\n/** @internal */\nexport const endOfDay = now => {\n  const date = new Date(beginningOfDay(now));\n  return date.setDate(date.getDate() + 1);\n};\n/** @internal */\nexport const nextDay = (now, dayOfWeek, initial) => {\n  const date = new Date(now);\n  if (date.getDay() === dayOfWeek && initial) {\n    return now;\n  }\n  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;\n  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));\n};\n/** @internal */\nexport const nextDayOfMonth = (now, day, initial) => {\n  const date = new Date(now);\n  if (date.getDate() === day && initial) {\n    return now;\n  }\n  if (date.getDate() < day) {\n    return date.setDate(day);\n  }\n  return findNextMonth(now, day, 1);\n};\n/** @internal */\nexport const findNextMonth = (now, day, months) => {\n  const d = new Date(now);\n  const tmp1 = new Date(d.setDate(day));\n  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));\n  if (tmp2.getDate() === day) {\n    const d2 = new Date(now);\n    const tmp3 = new Date(d2.setDate(day));\n    return tmp3.setMonth(tmp3.getMonth() + months);\n  }\n  return findNextMonth(now, day, months + 1);\n};\n// circular with Effect\nconst ScheduleDefectTypeId = /*#__PURE__*/Symbol.for(\"effect/Schedule/ScheduleDefect\");\nclass ScheduleDefect {\n  error;\n  [ScheduleDefectTypeId];\n  constructor(error) {\n    this.error = error;\n    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;\n  }\n}\nconst isScheduleDefect = u => hasProperty(u, ScheduleDefectTypeId);\nconst scheduleDefectWrap = self => core.catchAll(self, e => core.die(new ScheduleDefect(e)));\n/** @internal */\nexport const scheduleDefectRefailCause = cause => Option.match(internalCause.find(cause, _ => internalCause.isDieType(_) && isScheduleDefect(_.defect) ? Option.some(_.defect) : Option.none()), {\n  onNone: () => cause,\n  onSome: error => internalCause.fail(error.error)\n});\n/** @internal */\nexport const scheduleDefectRefail = effect => core.catchAllCause(effect, cause => core.failCause(scheduleDefectRefailCause(cause)));\n/** @internal */\nexport const repeat_Effect = /*#__PURE__*/dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => core.fail(e)));\n/** @internal */\nexport const repeat_combined = /*#__PURE__*/dual(2, (self, options) => {\n  if (isSchedule(options)) {\n    return repeat_Effect(self, options);\n  }\n  const base = options.schedule ?? passthrough(forever);\n  const withWhile = options.while ? whileInputEffect(base, a => {\n    const applied = options.while(a);\n    if (typeof applied === \"boolean\") {\n      return core.succeed(applied);\n    }\n    return scheduleDefectWrap(applied);\n  }) : base;\n  const withUntil = options.until ? untilInputEffect(withWhile, a => {\n    const applied = options.until(a);\n    if (typeof applied === \"boolean\") {\n      return core.succeed(applied);\n    }\n    return scheduleDefectWrap(applied);\n  }) : withWhile;\n  const withTimes = options.times ? intersect(withUntil, recurs(options.times)).pipe(map(intersectionPair => intersectionPair[0])) : withUntil;\n  return scheduleDefectRefail(repeat_Effect(self, withTimes));\n});\n/** @internal */\nexport const repeatOrElse_Effect = /*#__PURE__*/dual(3, (self, schedule, orElse) => core.flatMap(driver(schedule), driver => core.matchEffect(self, {\n  onFailure: error => orElse(error, Option.none()),\n  onSuccess: value => repeatOrElseEffectLoop(effect.provideServiceEffect(self, CurrentIterationMetadata, ref.get(driver.iterationMeta)), driver, (error, option) => effect.provideServiceEffect(orElse(error, option), CurrentIterationMetadata, ref.get(driver.iterationMeta)), value)\n})));\n/** @internal */\nconst repeatOrElseEffectLoop = (self, driver, orElse, value) => core.matchEffect(driver.next(value), {\n  onFailure: () => core.orDie(driver.last),\n  onSuccess: b => core.matchEffect(self, {\n    onFailure: error => orElse(error, Option.some(b)),\n    onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)\n  })\n});\n/** @internal */\nexport const retry_Effect = /*#__PURE__*/dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core.fail(e)));\n/** @internal */\nexport const retry_combined = /*#__PURE__*/dual(2, (self, options) => {\n  if (isSchedule(options)) {\n    return retry_Effect(self, options);\n  }\n  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));\n});\n/** @internal */\nexport const fromRetryOptions = options => {\n  const base = options.schedule ?? forever;\n  const withWhile = options.while ? whileInputEffect(base, e => {\n    const applied = options.while(e);\n    if (typeof applied === \"boolean\") {\n      return core.succeed(applied);\n    }\n    return scheduleDefectWrap(applied);\n  }) : base;\n  const withUntil = options.until ? untilInputEffect(withWhile, e => {\n    const applied = options.until(e);\n    if (typeof applied === \"boolean\") {\n      return core.succeed(applied);\n    }\n    return scheduleDefectWrap(applied);\n  }) : withWhile;\n  return options.times !== undefined ? intersect(withUntil, recurs(options.times)) : withUntil;\n};\n/** @internal */\nexport const retryOrElse_Effect = /*#__PURE__*/dual(3, (self, policy, orElse) => core.flatMap(driver(policy), driver => retryOrElse_EffectLoop(effect.provideServiceEffect(self, CurrentIterationMetadata, ref.get(driver.iterationMeta)), driver, (e, out) => effect.provideServiceEffect(orElse(e, out), CurrentIterationMetadata, ref.get(driver.iterationMeta)))));\n/** @internal */\nconst retryOrElse_EffectLoop = (self, driver, orElse) => {\n  return core.catchAll(self, e => core.matchEffect(driver.next(e), {\n    onFailure: () => pipe(driver.last, core.orDie, core.flatMap(out => orElse(e, out))),\n    onSuccess: () => retryOrElse_EffectLoop(self, driver, orElse)\n  }));\n};\n/** @internal */\nexport const schedule_Effect = /*#__PURE__*/dual(2, (self, schedule) => scheduleFrom_Effect(self, void 0, schedule));\n/** @internal */\nexport const scheduleFrom_Effect = /*#__PURE__*/dual(3, (self, initial, schedule) => core.flatMap(driver(schedule), driver => scheduleFrom_EffectLoop(effect.provideServiceEffect(self, CurrentIterationMetadata, ref.get(driver.iterationMeta)), initial, driver)));\n/** @internal */\nconst scheduleFrom_EffectLoop = (self, initial, driver) => core.matchEffect(driver.next(initial), {\n  onFailure: () => core.orDie(driver.last),\n  onSuccess: () => core.flatMap(self, a => scheduleFrom_EffectLoop(self, a, driver))\n});\n/** @internal */\nexport const count = /*#__PURE__*/unfold(0, n => n + 1);\n/** @internal */\nexport const elapsed = /*#__PURE__*/makeWithState(/*#__PURE__*/Option.none(), (now, _, state) => {\n  switch (state._tag) {\n    case \"None\":\n      {\n        return core.succeed([Option.some(now), Duration.zero, ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n    case \"Some\":\n      {\n        return core.succeed([Option.some(state.value), Duration.millis(now - state.value), ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n  }\n});\n/** @internal */\nexport const forever = /*#__PURE__*/unfold(0, n => n + 1);\n/** @internal */\nexport const once = /*#__PURE__*/asVoid(/*#__PURE__*/recurs(1));\n/** @internal */\nexport const stop = /*#__PURE__*/asVoid(/*#__PURE__*/recurs(0));\n/** @internal */\nexport const scheduleForked = /*#__PURE__*/dual(2, (self, schedule) => forkScoped(schedule_Effect(self, schedule)));\n//# sourceMappingURL=schedule.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628621,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628651,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628706,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
