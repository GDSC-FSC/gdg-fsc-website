{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/effect/dist/esm/BigDecimal.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.\n *\n * A `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors\n * (such as 0.1 + 0.2 â‰  0.3) at the cost of complexity.\n *\n * Internally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the\n * decimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.\n *\n * It is not recommended to convert a floating point number to a decimal directly, as the floating point representation\n * may be unexpected.\n *\n * @module BigDecimal\n * @since 2.0.0\n * @see {@link module:BigInt} for more similar operations on `bigint` types\n * @see {@link module:Number} for more similar operations on `number` types\n */\nimport * as Equal from \"./Equal.js\";\nimport * as equivalence from \"./Equivalence.js\";\nimport { dual, pipe } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { NodeInspectSymbol } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport * as order from \"./Order.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nconst DEFAULT_PRECISION = 100;\nconst FINITE_INT_REGEX = /^[+-]?\\d+$/;\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/BigDecimal\");\nconst BigDecimalProto = {\n  [TypeId]: TypeId,\n  [Hash.symbol]() {\n    const normalized = normalize(this);\n    return pipe(Hash.hash(normalized.value), Hash.combine(Hash.number(normalized.scale)), Hash.cached(this));\n  },\n  [Equal.symbol](that) {\n    return isBigDecimal(that) && equals(this, that);\n  },\n  toString() {\n    return `BigDecimal(${format(this)})`;\n  },\n  toJSON() {\n    return {\n      _id: \"BigDecimal\",\n      value: String(this.value),\n      scale: this.scale\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/**\n * Checks if a given value is a `BigDecimal`.\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isBigDecimal = u => hasProperty(u, TypeId);\n/**\n * Creates a `BigDecimal` from a `bigint` value and a scale.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (value, scale) => {\n  const o = Object.create(BigDecimalProto);\n  o.value = value;\n  o.scale = scale;\n  return o;\n};\n/**\n * Internal function used to create pre-normalized `BigDecimal`s.\n *\n * @internal\n */\nexport const unsafeMakeNormalized = (value, scale) => {\n  if (value !== bigint0 && value % bigint10 === bigint0) {\n    throw new RangeError(\"Value must be normalized\");\n  }\n  const o = make(value, scale);\n  o.normalized = o;\n  return o;\n};\nconst bigint0 = /*#__PURE__*/BigInt(0);\nconst bigint1 = /*#__PURE__*/BigInt(1);\nconst bigint10 = /*#__PURE__*/BigInt(10);\nconst zero = /*#__PURE__*/unsafeMakeNormalized(bigint0, 0);\n/**\n * Normalizes a given `BigDecimal` by removing trailing zeros.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { normalize, make, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(normalize(unsafeFromString(\"123.00000\")), normalize(make(123n, 0)))\n * assert.deepStrictEqual(normalize(unsafeFromString(\"12300000\")), normalize(make(123n, -5)))\n * ```\n *\n * @since 2.0.0\n * @category scaling\n */\nexport const normalize = self => {\n  if (self.normalized === undefined) {\n    if (self.value === bigint0) {\n      self.normalized = zero;\n    } else {\n      const digits = `${self.value}`;\n      let trail = 0;\n      for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] === \"0\") {\n          trail++;\n        } else {\n          break;\n        }\n      }\n      if (trail === 0) {\n        self.normalized = self;\n      }\n      const value = BigInt(digits.substring(0, digits.length - trail));\n      const scale = self.scale - trail;\n      self.normalized = unsafeMakeNormalized(value, scale);\n    }\n  }\n  return self.normalized;\n};\n/**\n * Scales a given `BigDecimal` to the specified scale.\n *\n * If the given scale is smaller than the current scale, the value will be rounded down to\n * the nearest integer.\n *\n * @since 2.0.0\n * @category scaling\n */\nexport const scale = /*#__PURE__*/dual(2, (self, scale) => {\n  if (scale > self.scale) {\n    return make(self.value * bigint10 ** BigInt(scale - self.scale), scale);\n  }\n  if (scale < self.scale) {\n    return make(self.value / bigint10 ** BigInt(self.scale - scale), scale);\n  }\n  return self;\n});\n/**\n * Provides an addition operation on `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sum, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(sum(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"5\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const sum = /*#__PURE__*/dual(2, (self, that) => {\n  if (that.value === bigint0) {\n    return self;\n  }\n  if (self.value === bigint0) {\n    return that;\n  }\n  if (self.scale > that.scale) {\n    return make(scale(that, self.scale).value + self.value, self.scale);\n  }\n  if (self.scale < that.scale) {\n    return make(scale(self, that.scale).value + that.value, that.scale);\n  }\n  return make(self.value + that.value, self.scale);\n});\n/**\n * Provides a multiplication operation on `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { multiply, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(multiply(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"6\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const multiply = /*#__PURE__*/dual(2, (self, that) => {\n  if (that.value === bigint0 || self.value === bigint0) {\n    return zero;\n  }\n  return make(self.value * that.value, self.scale + that.scale);\n});\n/**\n * Provides a subtraction operation on `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { subtract, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(subtract(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"-1\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const subtract = /*#__PURE__*/dual(2, (self, that) => {\n  if (that.value === bigint0) {\n    return self;\n  }\n  if (self.value === bigint0) {\n    return make(-that.value, that.scale);\n  }\n  if (self.scale > that.scale) {\n    return make(self.value - scale(that, self.scale).value, self.scale);\n  }\n  if (self.scale < that.scale) {\n    return make(scale(self, that.scale).value - that.value, that.scale);\n  }\n  return make(self.value - that.value, self.scale);\n});\n/**\n * Internal function used for arbitrary precision division.\n */\nconst divideWithPrecision = (num, den, scale, precision) => {\n  const numNegative = num < bigint0;\n  const denNegative = den < bigint0;\n  const negateResult = numNegative !== denNegative;\n  num = numNegative ? -num : num;\n  den = denNegative ? -den : den;\n  // Shift digits until numerator is larger than denominator (set scale appropriately).\n  while (num < den) {\n    num *= bigint10;\n    scale++;\n  }\n  // First division.\n  let quotient = num / den;\n  let remainder = num % den;\n  if (remainder === bigint0) {\n    // No remainder, return immediately.\n    return make(negateResult ? -quotient : quotient, scale);\n  }\n  // The quotient is guaranteed to be non-negative at this point. No need to consider sign.\n  let count = `${quotient}`.length;\n  // Shift the remainder by 1 decimal; The quotient will be 1 digit upon next division.\n  remainder *= bigint10;\n  while (remainder !== bigint0 && count < precision) {\n    const q = remainder / den;\n    const r = remainder % den;\n    quotient = quotient * bigint10 + q;\n    remainder = r * bigint10;\n    count++;\n    scale++;\n  }\n  if (remainder !== bigint0) {\n    // Round final number with remainder.\n    quotient += roundTerminal(remainder / den);\n  }\n  return make(negateResult ? -quotient : quotient, scale);\n};\n/**\n * Internal function used for rounding.\n *\n * Returns 1 if the most significant digit is >= 5, otherwise 0.\n *\n * This is used after dividing a number by a power of ten and rounding the last digit.\n *\n * @internal\n */\nexport const roundTerminal = n => {\n  const pos = n >= bigint0 ? 0 : 1;\n  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;\n};\n/**\n * Provides a division operation on `BigDecimal`s.\n *\n * If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\n * which represents the integer division rounded down to the nearest integer.\n *\n * If the divisor is `0`, the result will be `None`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"3\")), Option.some(BigDecimal.unsafeFromString(\"2\")))\n * assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"4\")), Option.some(BigDecimal.unsafeFromString(\"1.5\")))\n * assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"0\")), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const divide = /*#__PURE__*/dual(2, (self, that) => {\n  if (that.value === bigint0) {\n    return Option.none();\n  }\n  if (self.value === bigint0) {\n    return Option.some(zero);\n  }\n  const scale = self.scale - that.scale;\n  if (self.value === that.value) {\n    return Option.some(make(bigint1, scale));\n  }\n  return Option.some(divideWithPrecision(self.value, that.value, scale, DEFAULT_PRECISION));\n});\n/**\n * Provides an unsafe division operation on `BigDecimal`s.\n *\n * If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\n * which represents the integer division rounded down to the nearest integer.\n *\n * Throws a `RangeError` if the divisor is `0`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeDivide, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\n * assert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"4\")), unsafeFromString(\"1.5\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const unsafeDivide = /*#__PURE__*/dual(2, (self, that) => {\n  if (that.value === bigint0) {\n    throw new RangeError(\"Division by zero\");\n  }\n  if (self.value === bigint0) {\n    return zero;\n  }\n  const scale = self.scale - that.scale;\n  if (self.value === that.value) {\n    return make(bigint1, scale);\n  }\n  return divideWithPrecision(self.value, that.value, scale, DEFAULT_PRECISION);\n});\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const Order = /*#__PURE__*/order.make((self, that) => {\n  const scmp = order.number(sign(self), sign(that));\n  if (scmp !== 0) {\n    return scmp;\n  }\n  if (self.scale > that.scale) {\n    return order.bigint(self.value, scale(that, self.scale).value);\n  }\n  if (self.scale < that.scale) {\n    return order.bigint(scale(self, that.scale).value, that.value);\n  }\n  return order.bigint(self.value, that.value);\n});\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThan, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(lessThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\n * assert.deepStrictEqual(lessThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\n * assert.deepStrictEqual(lessThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * Checks if a given `BigDecimal` is less than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThan, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(greaterThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\n * assert.deepStrictEqual(greaterThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\n * assert.deepStrictEqual(greaterThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * Checks if a given `BigDecimal` is greater than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal } from \"effect\"\n *\n * const between = BigDecimal.between({\n *   minimum: BigDecimal.unsafeFromString(\"1\"),\n *   maximum: BigDecimal.unsafeFromString(\"5\") }\n * )\n *\n * assert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"3\")), true)\n * assert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"0\")), false)\n * assert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"6\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const between = /*#__PURE__*/order.between(Order);\n/**\n * Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `BigDecimal`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal } from \"effect\"\n *\n * const clamp = BigDecimal.clamp({\n *   minimum: BigDecimal.unsafeFromString(\"1\"),\n *   maximum: BigDecimal.unsafeFromString(\"5\") }\n * )\n *\n * assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"3\")), BigDecimal.unsafeFromString(\"3\"))\n * assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"0\")), BigDecimal.unsafeFromString(\"1\"))\n * assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"6\")), BigDecimal.unsafeFromString(\"5\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * Returns the minimum between two `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { min, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(min(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const min = /*#__PURE__*/order.min(Order);\n/**\n * Returns the maximum between two `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { max, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(max(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"3\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const max = /*#__PURE__*/order.max(Order);\n/**\n * Determines the sign of a given `BigDecimal`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sign, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(sign(unsafeFromString(\"-5\")), -1)\n * assert.deepStrictEqual(sign(unsafeFromString(\"0\")), 0)\n * assert.deepStrictEqual(sign(unsafeFromString(\"5\")), 1)\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const sign = n => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;\n/**\n * Determines the absolute value of a given `BigDecimal`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { abs, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(abs(unsafeFromString(\"-5\")), unsafeFromString(\"5\"))\n * assert.deepStrictEqual(abs(unsafeFromString(\"0\")), unsafeFromString(\"0\"))\n * assert.deepStrictEqual(abs(unsafeFromString(\"5\")), unsafeFromString(\"5\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const abs = n => n.value < bigint0 ? make(-n.value, n.scale) : n;\n/**\n * Provides a negate operation on `BigDecimal`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { negate, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(negate(unsafeFromString(\"3\")), unsafeFromString(\"-3\"))\n * assert.deepStrictEqual(negate(unsafeFromString(\"-6\")), unsafeFromString(\"6\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const negate = n => make(-n.value, n.scale);\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * If the divisor is `0`, the result will be `None`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"2\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\n * assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"3\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"1\")))\n * assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"-4\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const remainder = /*#__PURE__*/dual(2, (self, divisor) => {\n  if (divisor.value === bigint0) {\n    return Option.none();\n  }\n  const max = Math.max(self.scale, divisor.scale);\n  return Option.some(make(scale(self, max).value % scale(divisor, max).value, max));\n});\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * Throws a `RangeError` if the divisor is `0`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeRemainder, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"2\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\n * assert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"3\"), unsafeFromString(\"2\")), unsafeFromString(\"1\"))\n * assert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"-4\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\n * ```\n *\n * @since 2.0.0\n * @category math\n */\nexport const unsafeRemainder = /*#__PURE__*/dual(2, (self, divisor) => {\n  if (divisor.value === bigint0) {\n    throw new RangeError(\"Division by zero\");\n  }\n  const max = Math.max(self.scale, divisor.scale);\n  return make(scale(self, max).value % scale(divisor, max).value, max);\n});\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence = /*#__PURE__*/equivalence.make((self, that) => {\n  if (self.scale > that.scale) {\n    return scale(that, self.scale).value === self.value;\n  }\n  if (self.scale < that.scale) {\n    return scale(self, that.scale).value === that.value;\n  }\n  return self.value === that.value;\n});\n/**\n * Checks if two `BigDecimal`s are equal.\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(self, that));\n/**\n * Creates a `BigDecimal` from a `bigint` value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromBigInt = n => make(n, 0);\n/**\n * Creates a `BigDecimal` from a `number` value.\n *\n * It is not recommended to convert a floating point number to a decimal directly,\n * as the floating point representation may be unexpected.\n *\n * Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeFromNumber, make } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))\n * assert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))\n * ```\n *\n * @since 3.11.0\n * @category constructors\n */\nexport const unsafeFromNumber = n => Option.getOrThrowWith(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));\n/**\n * Creates a `BigDecimal` from a `number` value.\n *\n * It is not recommended to convert a floating point number to a decimal directly,\n * as the floating point representation may be unexpected.\n *\n * Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).\n *\n * @since 2.0.0\n * @category constructors\n * @deprecated Use {@link unsafeFromNumber} instead.\n */\nexport const fromNumber = unsafeFromNumber;\n// TODO(4.0): Rename this to `fromNumber` after removing the current, unsafe implementation of `fromNumber`.\n/**\n * Creates a `BigDecimal` from a `number` value.\n *\n * It is not recommended to convert a floating point number to a decimal directly,\n * as the floating point representation may be unexpected.\n *\n * Returns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))\n * assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))\n * assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())\n * ```\n *\n * @since 3.11.0\n * @category constructors\n */\nexport const safeFromNumber = n => {\n  if (!Number.isFinite(n)) {\n    return Option.none();\n  }\n  const string = `${n}`;\n  if (string.includes(\"e\")) {\n    return fromString(string);\n  }\n  const [lead, trail = \"\"] = string.split(\".\");\n  return Option.some(make(BigInt(`${lead}${trail}`), trail.length));\n};\n/**\n * Parses a numerical `string` into a `BigDecimal`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { BigDecimal, Option } from \"effect\"\n *\n * assert.deepStrictEqual(BigDecimal.fromString(\"123\"), Option.some(BigDecimal.make(123n, 0)))\n * assert.deepStrictEqual(BigDecimal.fromString(\"123.456\"), Option.some(BigDecimal.make(123456n, 3)))\n * assert.deepStrictEqual(BigDecimal.fromString(\"123.abc\"), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromString = s => {\n  if (s === \"\") {\n    return Option.some(zero);\n  }\n  let base;\n  let exp;\n  const seperator = s.search(/[eE]/);\n  if (seperator !== -1) {\n    const trail = s.slice(seperator + 1);\n    base = s.slice(0, seperator);\n    exp = Number(trail);\n    if (base === \"\" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {\n      return Option.none();\n    }\n  } else {\n    base = s;\n    exp = 0;\n  }\n  let digits;\n  let offset;\n  const dot = base.search(/\\./);\n  if (dot !== -1) {\n    const lead = base.slice(0, dot);\n    const trail = base.slice(dot + 1);\n    digits = `${lead}${trail}`;\n    offset = trail.length;\n  } else {\n    digits = base;\n    offset = 0;\n  }\n  if (!FINITE_INT_REGEX.test(digits)) {\n    return Option.none();\n  }\n  const scale = offset - exp;\n  if (!Number.isSafeInteger(scale)) {\n    return Option.none();\n  }\n  return Option.some(make(BigInt(digits), scale));\n};\n/**\n * Parses a numerical `string` into a `BigDecimal`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeFromString, make } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(unsafeFromString(\"123\"), make(123n, 0))\n * assert.deepStrictEqual(unsafeFromString(\"123.456\"), make(123456n, 3))\n * assert.throws(() => unsafeFromString(\"123.abc\"))\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeFromString = s => Option.getOrThrowWith(fromString(s), () => new Error(\"Invalid numerical string\"));\n/**\n * Formats a given `BigDecimal` as a `string`.\n *\n * If the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will\n * be formatted in scientific notation.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { format, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(format(unsafeFromString(\"-5\")), \"-5\")\n * assert.deepStrictEqual(format(unsafeFromString(\"123.456\")), \"123.456\")\n * assert.deepStrictEqual(format(unsafeFromString(\"-0.00000123\")), \"-0.00000123\")\n * ```\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const format = n => {\n  const normalized = normalize(n);\n  if (Math.abs(normalized.scale) >= 16) {\n    return toExponential(normalized);\n  }\n  const negative = normalized.value < bigint0;\n  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;\n  let before;\n  let after;\n  if (normalized.scale >= absolute.length) {\n    before = \"0\";\n    after = \"0\".repeat(normalized.scale - absolute.length) + absolute;\n  } else {\n    const location = absolute.length - normalized.scale;\n    if (location > absolute.length) {\n      const zeros = location - absolute.length;\n      before = `${absolute}${\"0\".repeat(zeros)}`;\n      after = \"\";\n    } else {\n      after = absolute.slice(location);\n      before = absolute.slice(0, location);\n    }\n  }\n  const complete = after === \"\" ? before : `${before}.${after}`;\n  return negative ? `-${complete}` : complete;\n};\n/**\n * Formats a given `BigDecimal` as a `string` in scientific notation.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { toExponential, make } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(toExponential(make(123456n, -5)), \"1.23456e+10\")\n * ```\n *\n * @since 3.11.0\n * @category conversions\n */\nexport const toExponential = n => {\n  if (isZero(n)) {\n    return \"0e+0\";\n  }\n  const normalized = normalize(n);\n  const digits = `${abs(normalized).value}`;\n  const head = digits.slice(0, 1);\n  const tail = digits.slice(1);\n  let output = `${isNegative(normalized) ? \"-\" : \"\"}${head}`;\n  if (tail !== \"\") {\n    output += `.${tail}`;\n  }\n  const exp = tail.length - normalized.scale;\n  return `${output}e${exp >= 0 ? \"+\" : \"\"}${exp}`;\n};\n/**\n * Converts a `BigDecimal` to a `number`.\n *\n * This function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeToNumber, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(unsafeToNumber(unsafeFromString(\"123.456\")), 123.456)\n * ```\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const unsafeToNumber = n => Number(format(n));\n/**\n * Checks if a given `BigDecimal` is an integer.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isInteger, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(isInteger(unsafeFromString(\"0\")), true)\n * assert.deepStrictEqual(isInteger(unsafeFromString(\"1\")), true)\n * assert.deepStrictEqual(isInteger(unsafeFromString(\"1.1\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const isInteger = n => normalize(n).scale <= 0;\n/**\n * Checks if a given `BigDecimal` is `0`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isZero, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(isZero(unsafeFromString(\"0\")), true)\n * assert.deepStrictEqual(isZero(unsafeFromString(\"1\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const isZero = n => n.value === bigint0;\n/**\n * Checks if a given `BigDecimal` is negative.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNegative, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(isNegative(unsafeFromString(\"-1\")), true)\n * assert.deepStrictEqual(isNegative(unsafeFromString(\"0\")), false)\n * assert.deepStrictEqual(isNegative(unsafeFromString(\"1\")), false)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const isNegative = n => n.value < bigint0;\n/**\n * Checks if a given `BigDecimal` is positive.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPositive, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(isPositive(unsafeFromString(\"-1\")), false)\n * assert.deepStrictEqual(isPositive(unsafeFromString(\"0\")), false)\n * assert.deepStrictEqual(isPositive(unsafeFromString(\"1\")), true)\n * ```\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const isPositive = n => n.value > bigint0;\nconst isBigDecimalArgs = args => isBigDecimal(args[0]);\n/**\n * Calculate the ceiling of a `BigDecimal` at the given scale.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { ceil, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(ceil(unsafeFromString(\"145\"), -1), unsafeFromString(\"150\"))\n * assert.deepStrictEqual(ceil(unsafeFromString(\"-14.5\")), unsafeFromString(\"-14\"))\n * ```\n *\n * @since 3.16.0\n * @category math\n */\nexport const ceil = /*#__PURE__*/dual(isBigDecimalArgs, (self, scale = 0) => {\n  const truncated = truncate(self, scale);\n  if (isPositive(self) && lessThan(truncated, self)) {\n    return sum(truncated, make(1n, scale));\n  }\n  return truncated;\n});\n/**\n * Calculate the floor of a `BigDecimal` at the given scale.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { floor, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(floor(unsafeFromString(\"145\"), -1), unsafeFromString(\"140\"))\n * assert.deepStrictEqual(floor(unsafeFromString(\"-14.5\")), unsafeFromString(\"-15\"))\n * ```\n *\n * @since 3.16.0\n * @category math\n */\nexport const floor = /*#__PURE__*/dual(isBigDecimalArgs, (self, scale = 0) => {\n  const truncated = truncate(self, scale);\n  if (isNegative(self) && greaterThan(truncated, self)) {\n    return sum(truncated, make(-1n, scale));\n  }\n  return truncated;\n});\n/**\n * Truncate a `BigDecimal` at the given scale. This is the same operation as rounding away from zero.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { truncate, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(truncate(unsafeFromString(\"145\"), -1), unsafeFromString(\"140\"))\n * assert.deepStrictEqual(truncate(unsafeFromString(\"-14.5\")), unsafeFromString(\"-14\"))\n * ```\n *\n * @since 3.16.0\n * @category math\n */\nexport const truncate = /*#__PURE__*/dual(isBigDecimalArgs, (self, scale = 0) => {\n  if (self.scale <= scale) {\n    return self;\n  }\n  // BigInt division truncates towards zero\n  return make(self.value / 10n ** BigInt(self.scale - scale), scale);\n});\n/**\n * Internal function used by `round` for `half-even` and `half-odd` rounding modes.\n *\n * Returns the digit at the position of the given `scale` within the `BigDecimal`.\n *\n * @internal\n */\nexport const digitAt = /*#__PURE__*/dual(2, (self, scale) => {\n  if (self.scale < scale) {\n    return 0n;\n  }\n  const scaled = self.value / 10n ** BigInt(self.scale - scale);\n  return scaled % 10n;\n});\n/**\n * Rounds a `BigDecimal` at the given scale with the specified rounding mode.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { round, unsafeFromString } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(round(unsafeFromString(\"145\"), { mode: \"from-zero\", scale: -1 }), unsafeFromString(\"150\"))\n * assert.deepStrictEqual(round(unsafeFromString(\"-14.5\")), unsafeFromString(\"-15\"))\n * ```\n *\n * @since 3.16.0\n * @category math\n */\nexport const round = /*#__PURE__*/dual(isBigDecimalArgs, (self, options) => {\n  const mode = options?.mode ?? \"half-from-zero\";\n  const scale = options?.scale ?? 0;\n  switch (mode) {\n    case \"ceil\":\n      return ceil(self, scale);\n    case \"floor\":\n      return floor(self, scale);\n    case \"to-zero\":\n      return truncate(self, scale);\n    case \"from-zero\":\n      return isPositive(self) ? ceil(self, scale) : floor(self, scale);\n    case \"half-ceil\":\n      return floor(sum(self, make(5n, scale + 1)), scale);\n    case \"half-floor\":\n      return ceil(sum(self, make(-5n, scale + 1)), scale);\n    case \"half-to-zero\":\n      return isNegative(self) ? floor(sum(self, make(5n, scale + 1)), scale) : ceil(sum(self, make(-5n, scale + 1)), scale);\n    case \"half-from-zero\":\n      return isNegative(self) ? ceil(sum(self, make(-5n, scale + 1)), scale) : floor(sum(self, make(5n, scale + 1)), scale);\n  }\n  const halfCeil = floor(sum(self, make(5n, scale + 1)), scale);\n  const halfFloor = ceil(sum(self, make(-5n, scale + 1)), scale);\n  const digit = digitAt(halfCeil, scale);\n  switch (mode) {\n    case \"half-even\":\n      return equals(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfCeil : halfFloor;\n    case \"half-odd\":\n      return equals(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfFloor : halfCeil;\n  }\n});\n/**\n * Takes an `Iterable` of `BigDecimal`s and returns their sum as a single `BigDecimal`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeFromString, sumAll } from \"effect/BigDecimal\"\n *\n * assert.deepStrictEqual(sumAll([unsafeFromString(\"2\"), unsafeFromString(\"3\"), unsafeFromString(\"4\")]), unsafeFromString(\"9\"))\n * ```\n *\n * @category math\n * @since 3.16.0\n */\nexport const sumAll = collection => {\n  let out = zero;\n  for (const n of collection) {\n    out = sum(out, n);\n  }\n  return out;\n};\n//# sourceMappingURL=BigDecimal.js.map",
      "start": 1768772628411,
      "end": 1768772628411
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628411,
      "end": 1768772628416,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628417,
      "end": 1768772628421,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628433,
      "end": 1768772628437,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628476,
      "end": 1768772628479,
      "order": "post-post"
    }
  ]
}
