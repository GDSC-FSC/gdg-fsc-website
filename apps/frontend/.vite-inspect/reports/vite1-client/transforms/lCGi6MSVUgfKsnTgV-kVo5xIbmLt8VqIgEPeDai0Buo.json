{
  "resolvedId": "/home/wombocombo/github/wrk/gdg-fsc-website/node_modules/@effect/platform/dist/esm/Socket.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "/**\n * @since 1.0.0\n */\nimport * as Channel from \"effect/Channel\";\nimport * as Context from \"effect/Context\";\nimport * as Deferred from \"effect/Deferred\";\nimport * as Effect from \"effect/Effect\";\nimport * as ExecutionStrategy from \"effect/ExecutionStrategy\";\nimport * as Exit from \"effect/Exit\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as FiberSet from \"effect/FiberSet\";\nimport { dual } from \"effect/Function\";\nimport { globalValue } from \"effect/GlobalValue\";\nimport * as Layer from \"effect/Layer\";\nimport * as Mailbox from \"effect/Mailbox\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as Scope from \"effect/Scope\";\nimport { TypeIdError } from \"./Error.js\";\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Socket\");\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isSocket = u => Predicate.hasProperty(u, TypeId);\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Socket = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Socket\");\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const CloseEventTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Socket/CloseEvent\");\n/**\n * @since 1.0.0\n * @category models\n */\nexport class CloseEvent {\n  code;\n  reason;\n  /**\n   * @since 1.0.0\n   */\n  [CloseEventTypeId];\n  constructor(code = 1000, reason) {\n    this.code = code;\n    this.reason = reason;\n    this[CloseEventTypeId] = CloseEventTypeId;\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return this.reason ? `${this.code}: ${this.reason}` : `${this.code}`;\n  }\n}\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCloseEvent = u => Predicate.hasProperty(u, CloseEventTypeId);\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const SocketErrorTypeId = /*#__PURE__*/Symbol.for(\"@effect/platform/Socket/SocketError\");\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSocketError = u => Predicate.hasProperty(u, SocketErrorTypeId);\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketGenericError extends /*#__PURE__*/TypeIdError(SocketErrorTypeId, \"SocketError\") {\n  get message() {\n    return `An error occurred during ${this.reason}`;\n  }\n}\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketCloseError extends /*#__PURE__*/TypeIdError(SocketErrorTypeId, \"SocketError\") {\n  /**\n   * @since 1.0.0\n   */\n  static is(u) {\n    return isSocketError(u) && u.reason === \"Close\";\n  }\n  /**\n   * @since 1.0.0\n   */\n  static isClean(isClean) {\n    return function (u) {\n      return SocketCloseError.is(u) && isClean(u.code);\n    };\n  }\n  get message() {\n    if (this.closeReason) {\n      return `${this.reason}: ${this.code}: ${this.closeReason}`;\n    }\n    return `${this.reason}: ${this.code}`;\n  }\n}\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelMap = (self, f) => Effect.gen(function* () {\n  const scope = yield* Effect.scope;\n  const mailbox = yield* Mailbox.make();\n  const writeScope = yield* Scope.fork(scope, ExecutionStrategy.sequential);\n  const write = yield* Scope.extend(self.writer, writeScope);\n  function* emit(chunk) {\n    for (const data of chunk) {\n      yield* write(data);\n    }\n  }\n  const input = {\n    awaitRead: () => Effect.void,\n    emit(chunk) {\n      return Effect.catchAllCause(Effect.gen(() => emit(chunk)), cause => mailbox.failCause(cause));\n    },\n    error(error) {\n      return Effect.zipRight(Scope.close(writeScope, Exit.void), mailbox.failCause(error));\n    },\n    done() {\n      return Scope.close(writeScope, Exit.void);\n    }\n  };\n  yield* self.runRaw(data => {\n    mailbox.unsafeOffer(f(data));\n  }).pipe(Mailbox.into(mailbox), Effect.forkIn(scope), Effect.interruptible);\n  return Channel.embedInput(Mailbox.toChannel(mailbox), input);\n}).pipe(Channel.unwrapScoped);\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannel = self => {\n  const encoder = new TextEncoder();\n  return toChannelMap(self, data => typeof data === \"string\" ? encoder.encode(data) : data);\n};\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelString = /*#__PURE__*/dual(args => isSocket(args[0]), (self, encoding) => {\n  const decoder = new TextDecoder(encoding);\n  return toChannelMap(self, data => typeof data === \"string\" ? data : decoder.decode(data));\n});\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelWith = () => self => toChannel(self);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeChannel = () => Channel.unwrap(Effect.map(Socket, toChannelWith()));\n/**\n * @since 1.0.0\n */\nexport const defaultCloseCodeIsError = code => code !== 1000 && code !== 1006;\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocket = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Socket/WebSocket\");\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocketConstructor = /*#__PURE__*/Context.GenericTag(\"@effect/platform/Socket/WebSocketConstructor\");\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocketConstructorGlobal = /*#__PURE__*/Layer.succeed(WebSocketConstructor, (url, protocols) => new globalThis.WebSocket(url, protocols));\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocket = (url, options) => fromWebSocket(Effect.acquireRelease((typeof url === \"string\" ? Effect.succeed(url) : url).pipe(Effect.flatMap(url => Effect.map(WebSocketConstructor, f => f(url, options?.protocols)))), ws => Effect.sync(() => ws.close(1000))), options);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromWebSocket = (acquire, options) => Effect.withFiberRuntime(fiber => {\n  let currentWS;\n  const latch = Effect.unsafeMakeLatch(false);\n  const acquireContext = fiber.currentContext;\n  const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError;\n  const runRaw = (handler, opts) => Effect.scopedWith(Effect.fnUntraced(function* (scope) {\n    const fiberSet = yield* FiberSet.make().pipe(Scope.extend(scope));\n    const ws = yield* Scope.extend(acquire, scope);\n    const run = yield* Effect.provideService(FiberSet.runtime(fiberSet)(), WebSocket, ws);\n    let open = false;\n    function onMessage(event) {\n      if (event.data instanceof Blob) {\n        return Effect.promise(() => event.data.arrayBuffer()).pipe(Effect.andThen(buffer => handler(new Uint8Array(buffer))), run);\n      }\n      const result = handler(event.data);\n      if (Effect.isEffect(result)) {\n        run(result);\n      }\n    }\n    function onError(cause) {\n      ws.removeEventListener(\"message\", onMessage);\n      ws.removeEventListener(\"close\", onClose);\n      Deferred.unsafeDone(fiberSet.deferred, Effect.fail(new SocketGenericError({\n        reason: open ? \"Read\" : \"Open\",\n        cause\n      })));\n    }\n    function onClose(event) {\n      ws.removeEventListener(\"message\", onMessage);\n      ws.removeEventListener(\"error\", onError);\n      Deferred.unsafeDone(fiberSet.deferred, Effect.fail(new SocketCloseError({\n        reason: \"Close\",\n        code: event.code,\n        closeReason: event.reason\n      })));\n    }\n    ws.addEventListener(\"close\", onClose, {\n      once: true\n    });\n    ws.addEventListener(\"error\", onError, {\n      once: true\n    });\n    ws.addEventListener(\"message\", onMessage);\n    if (ws.readyState !== 1) {\n      const openDeferred = Deferred.unsafeMake(fiber.id());\n      ws.addEventListener(\"open\", () => {\n        open = true;\n        Deferred.unsafeDone(openDeferred, Effect.void);\n      }, {\n        once: true\n      });\n      yield* Deferred.await(openDeferred).pipe(Effect.timeoutFail({\n        duration: options?.openTimeout ?? 10000,\n        onTimeout: () => new SocketGenericError({\n          reason: \"OpenTimeout\",\n          cause: \"timeout waiting for \\\"open\\\"\"\n        })\n      }), Effect.raceFirst(FiberSet.join(fiberSet)));\n    }\n    open = true;\n    currentWS = ws;\n    yield* latch.open;\n    if (opts?.onOpen) yield* opts.onOpen;\n    return yield* FiberSet.join(fiberSet).pipe(Effect.catchIf(SocketCloseError.isClean(_ => !closeCodeIsError(_)), _ => Effect.void));\n  })).pipe(Effect.mapInputContext(input => Context.merge(acquireContext, input)), Effect.ensuring(Effect.sync(() => {\n    latch.unsafeClose();\n    currentWS = undefined;\n  })), Effect.interruptible);\n  const encoder = new TextEncoder();\n  const run = (handler, opts) => runRaw(data => typeof data === \"string\" ? handler(encoder.encode(data)) : data instanceof Uint8Array ? handler(data) : handler(new Uint8Array(data)), opts);\n  const write = chunk => latch.whenOpen(Effect.sync(() => {\n    const ws = currentWS;\n    if (isCloseEvent(chunk)) {\n      ws.close(chunk.code, chunk.reason);\n    } else {\n      ws.send(chunk);\n    }\n  }));\n  const writer = Effect.succeed(write);\n  return Effect.succeed(Socket.of({\n    [TypeId]: TypeId,\n    run,\n    runRaw,\n    writer\n  }));\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocketChannel = (url, options) => Channel.unwrapScoped(Effect.map(makeWebSocket(url, options), toChannelWith()));\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocket = (url, options) => Layer.effect(Socket, makeWebSocket(url, options));\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentSendQueueCapacity = /*#__PURE__*/globalValue(\"@effect/platform/Socket/currentSendQueueCapacity\", () => FiberRef.unsafeMake(16));\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromTransformStream = (acquire, options) => Effect.withFiberRuntime(fiber => {\n  const latch = Effect.unsafeMakeLatch(false);\n  let currentStream;\n  const acquireContext = fiber.currentContext;\n  const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError;\n  const runRaw = (handler, opts) => Effect.scopedWith(Effect.fnUntraced(function* (scope) {\n    const stream = yield* Scope.extend(acquire, scope);\n    const reader = stream.readable.getReader();\n    yield* Scope.addFinalizer(scope, Effect.promise(() => reader.cancel()));\n    const fiberSet = yield* FiberSet.make().pipe(Scope.extend(scope));\n    const runFork = yield* FiberSet.runtime(fiberSet)();\n    yield* Effect.tryPromise({\n      try: async () => {\n        while (true) {\n          const {\n            done,\n            value\n          } = await reader.read();\n          if (done) {\n            throw new SocketCloseError({\n              reason: \"Close\",\n              code: 1000\n            });\n          }\n          const result = handler(value);\n          if (Effect.isEffect(result)) {\n            runFork(result);\n          }\n        }\n      },\n      catch: cause => isSocketError(cause) ? cause : new SocketGenericError({\n        reason: \"Read\",\n        cause\n      })\n    }).pipe(FiberSet.run(fiberSet));\n    currentStream = {\n      stream,\n      fiberSet\n    };\n    yield* latch.open;\n    if (opts?.onOpen) yield* opts.onOpen;\n    return yield* FiberSet.join(fiberSet).pipe(Effect.catchIf(SocketCloseError.isClean(_ => !closeCodeIsError(_)), _ => Effect.void));\n  })).pipe(_ => _, Effect.mapInputContext(input => Context.merge(acquireContext, input)), Effect.ensuring(Effect.sync(() => {\n    latch.unsafeClose();\n    currentStream = undefined;\n  })), Effect.interruptible);\n  const encoder = new TextEncoder();\n  const run = (handler, opts) => runRaw(data => typeof data === \"string\" ? handler(encoder.encode(data)) : handler(data), opts);\n  const writers = new WeakMap();\n  const getWriter = stream => {\n    let writer = writers.get(stream);\n    if (!writer) {\n      writer = stream.writable.getWriter();\n      writers.set(stream, writer);\n    }\n    return writer;\n  };\n  const write = chunk => latch.whenOpen(Effect.suspend(() => {\n    const {\n      fiberSet,\n      stream\n    } = currentStream;\n    if (isCloseEvent(chunk)) {\n      return Deferred.fail(fiberSet.deferred, new SocketCloseError({\n        reason: \"Close\",\n        code: chunk.code,\n        closeReason: chunk.reason\n      }));\n    }\n    return Effect.promise(() => getWriter(stream).write(typeof chunk === \"string\" ? encoder.encode(chunk) : chunk));\n  }));\n  const writer = Effect.acquireRelease(Effect.succeed(write), () => Effect.promise(async () => {\n    if (!currentStream) return;\n    await getWriter(currentStream.stream).close();\n  }));\n  return Effect.succeed(Socket.of({\n    [TypeId]: TypeId,\n    run,\n    runRaw,\n    writer\n  }));\n});\n//# sourceMappingURL=Socket.js.map",
      "start": 1768772628587,
      "end": 1768772628587
    },
    {
      "name": "sentry-vite-component-name-annotate-plugin",
      "start": 1768772628587,
      "end": 1768772628588,
      "order": "pre"
    },
    {
      "name": "comlink",
      "start": 1768772628620,
      "end": 1768772628621,
      "order": "normal"
    },
    {
      "name": "sentry-vite-bundle-size-optimizations-plugin",
      "start": 1768772628649,
      "end": 1768772628651,
      "order": "normal"
    },
    {
      "name": "vite-plugin-csp-guard",
      "start": 1768772628704,
      "end": 1768772628706,
      "order": "post-post"
    }
  ]
}
